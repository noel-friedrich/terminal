
// ------------------- js/terminal.js --------------------
let uniqueFileIdCount = 0

const FileType = {
    RAW: "raw",
    DIRECTORY: "directory",
    PLAIN_TEXT: "plaintext",
    DATA_URL: "dataurl"
}

class FilePath {

    static from(obj) {
        if (typeof obj == "string") {
            return this.fromString(obj)
        } else if (obj instanceof FilePath) {
            return obj
        } else if (Array.isArray(obj)) {
            return new FilePath({items: obj})
        } else {
            return new Error(`Can't construct FilePath from "${typeof obj}"`)
        }
    }

    static fromString(str) {
        let parts = str.split(/[\\\/]/g).filter(part => part !== "")
        return new FilePath({items: parts})
    }

    constructor({
        items = [],
        relativeTo = null,
    }={}) {
        this.items = items
        this.relativeTo = relativeTo
    }

    prependFile(file) {
        this.items.unshift(file.name)
    }

    addFile(file) {
        this.items.push(file.name)
    }

    prependItem(str) {
        this.items.unshift(str)
    }

    addItem(str) {
        this.items.push(str)
    }

    pop() {
        return this.files.pop()
    }

    concat(otherFilePath) {
        return new FilePath({items: this.items.concat(otherFilePath.items)})
    }

    get isFilePath() {
        return true
    }

    slice(start, end) {
        return new FilePath({items: this.items.slice(start, end)})
    }

    fromRoot() {
        if (this.relativeTo == null) {
            return this
        } else {
            return this.relativeTo.path.fromRoot().concat(this)
        }
    }

    toString() {
        if (this.relativeTo == null) {
            if (this.items[0] === "root") {
                return this.items.join("/") + "/"
            } else {
                return "root/" + this.items.join("/") + "/"
            }
        } else {
            return this.fromRoot().toString()
        }
    }

    get length() {
        return this.items.length
    }

}

class TerminalFile {

    static classFromType(type) {
        switch (type) {
            case FileType.RAW:
                return TerminalFile
            case FileType.DIRECTORY:
                return DirectoryFile
            case FileType.PLAIN_TEXT:
            case "text": // compatability
            case "executable": // same here
                return PlainTextFile
            case FileType.DATA_URL:
                return DataURLFile
            default:
                throw new Error("Unknown Filetype: " + type)
        }
    }

    constructor(content) {
        this.type = FileType.RAW
        this.content = content
        this.parent = null
        this.id = uniqueFileIdCount++
        this.name = `unnamed-${this.id}`
    }

    setName(name) {
        this.name = name
        return this
    }

    computeSize() {
        return JSON.stringify(this.toObject()).length
    }

    copy() {
        return TerminalFile.fromObject(this.toObject())
    }

    get path() {
        return new FilePath({relativeTo: this.parent, items: [this.name]})
    }

    toObject() {
        return {
            name: this.name,
            type: this.type,
            content: this.content
        }
    }

    static fromObject(obj) {
        let children = []
        let content = obj.content
        if (obj.type === "directory") {
            // compatability with previous versions of filesystem saving
            // that may still exist in some peoples localstorage!
            if (typeof obj.content == "object" && obj.content !== null && !Array.isArray(obj.content)) {
                obj.content = Object.entries(obj.content).map(([fname, fobj]) => {
                    fobj.name = fname
                    return fobj
                })
            }

            children = obj.content.map(c => TerminalFile.fromObject(c))
            content = children
        }

        const file = new (TerminalFile.classFromType(obj.type))(content)
        for (let child of children) {
            child.parent = file
        }

        if (obj.name) {
            file.name = obj.name
        }

        return file
    }

}

class PlainTextFile extends TerminalFile {

    constructor(content) {
        content ??= ""
        super(content)
        this.type = FileType.PLAIN_TEXT
    }

    get text() {
        return this.content
    }

    set text(newText) {
        this.content = newText
    }

    append(text) {
        this.content += text
    }

    write(text) {
        this.content = text
    }

    get isPlainText() {
        return true
    }

}

class DataURLFile extends TerminalFile {

    constructor(content) {
        content ??= ""
        super(content)
        this.type = FileType.DATA_URL
    }

    get dataUrl() {
        return this.content
    }

    set dataUrl(newUrl) {
        this.content = newUrl
    }

    get isDataUrl() {
        return true
    }

}

class DirectoryFile extends TerminalFile {

    constructor(content) {
        content ??= []
        super(content)
        this.type = FileType.DIRECTORY
    }

    get children() {
        return this.content
    }

    toObject() {
        return {
            type: this.type,
            name: this.name,
            content: this.children.map(file => file.toObject()),
        }
    }

    addChild(child) {
        this.content.push(child)
        child.parent = this
    }

    deleteChild(child) {
        this.content = this.children.filter(f => f.id != child.id)
    }

    fileExists(path) {
        return !!this.getFile(path)
    }

    findChildByName(name) {
        return this.children.find(c => c.name == name)
    }

    getFile(path) {
        path = FilePath.from(path)
        let currDirectory = this

        for (let name of path.items) {
            let child = undefined

            if (name == ".") {
                continue
            } else if (name == "..") {
                if (!currDirectory.parent) {
                    return undefined
                } else {
                    currDirectory = currDirectory.parent
                }
            } else if (name == "~") {
                while (currDirectory.parent) {
                    currDirectory = currDirectory.parent
                }
            } else {
                child = currDirectory.findChildByName(name)
                if (!child) {
                    return undefined
                }
                currDirectory = child
            }
        }
        
        return currDirectory
    }

    get allChildren() {
        let files = []
        let stack = [this]
        while (stack.length > 0) {
            let file = stack.pop()
            files.push(file)
            if (file.isDirectory) {
                stack.push(...file.children)
            }
        }
        return files
    }

    get isDirectory() {
        return true
    }

}

class FileSystem {

    constructor() {
        this.root = new DirectoryFile().setName("root")
        this.currDirectory = this.root

        // in session mode, changes don't get saved to local storage
        this.inSessionMode = false
    }

    get pathStr() {
        return this.currDirectory.path.toString()
    }

    get path() {
        return this.currDirectory.path.fromRoot()
    }

    allFiles() {
        return this.root.allChildren
    }

    getFile(path) {
        path = FilePath.from(path)
        if (path.items[0] == "root") {
            return this.root.getFile(path.slice(1))
        } else {
            return this.currDirectory.getFile(path)
        }
    }

    fileExists(path) {
        return !!this.getFile(path)
    }

    filesizeStr(numBytes) {
        if (numBytes < 1e3 ) return `${numBytes} Bytes`
        if (numBytes < 1e6 ) return `${Math.round(numBytes / 1e3 * 10) / 10} KB`
        if (numBytes < 1e9 ) return `${Math.floor(numBytes / 1e6 * 10) / 10} MB`
        if (numBytes < 1e12) return `${Math.floor(numBytes / 1e9 * 10) / 10} GB`
        return `${Math.floor(numBytes / 1e12 * 10 / 10)} TB`
    }

    dumpTooLargeFiles(file, fileSizeLimit) {
        if (file.computeSize() < fileSizeLimit) {
            return
        }

        let allFiles = []
        function getAllFiles(file) {
            allFiles.push(file)
            if (file.isDirectory) {
                for (let [key, value] of Object.entries(file.content)) {
                    getAllFiles(value)
                }
            }
        }

        getAllFiles(file)

        let introducedDumping = false
        function introduceDumping() {
            if (introducedDumping)
                return
            introducedDumping = true

            terminal.printError("Storage limit exceeded!")
            terminal.printLine("I will now delete the largest files to free up space:")
        }

        function dumpLargestFile() {
            let largestFile = null
            let largestSize = 0
            for (let file of allFiles) {
                if (file.isDirectory)
                    continue
                const size = file.computeSize()
                if (size > largestSize) {
                    largestFile = file
                    largestSize = size
                }
            }
            if (largestFile && largestFile.parent) {
                largestFile.parent.deleteChild(largestFile)
                introduceDumping()
                terminal.printLine(`- ${largestFile.path} (${terminal.fileSystem.filesizeStr(largestFile.computeSize())})`)
                allFiles = allFiles.filter(file => file.id !== largestFile.id)
            } else if (largestFile) {
                return "not ready yet"
            }
        }

        let totalSize = file.computeSize()
        while (totalSize > fileSizeLimit) {
            if (dumpLargestFile() === "not ready yet")
                break
            totalSize = file.computeSize()
        }

        if (introducedDumping)
            terminal.printLine("")
    }

    toJSON() {
        if (!this.inSessionMode) {
            let fileSizeLimit = terminal.data.storageSize
            this.dumpTooLargeFiles(this.root, fileSizeLimit)
        }
        return JSON.stringify(this.root.toObject())
    }

    loadJSON(jsonString) {
        let parsed = JSON.parse(jsonString)
        this.root = TerminalFile.fromObject(parsed).setName("root")
        this.currDirectory = this.root
    }

    reset() {
        if (!this.inSessionMode) {
            localStorage.removeItem("terminal-filesystem")
        }

        this.root = new DirectoryFile().setName("root")
        this.currDirectory = this.root
    }

    beginSession() {
        this.inSessionMode = true
    }

    endSession() {
        this.inSessionMode = false
    }

    save() {
        if (this.inSessionMode) {
            return
        }

        localStorage.setItem("terminal-filesystem", this.toJSON())
    }

    async load(jsonVal=undefined) {
        if (this.inSessionMode) {
            return
        }

        let json = jsonVal ?? localStorage.getItem("terminal-filesystem")
        if (json) {
            this.loadJSON(json)
        } else {
            await terminal._loadScript(terminal.defaultFileystemURL)
            this.save()
            this.loadJSON(this.toJSON())
        }
    }

    async reload() {
        this.save()
        await this.load()
    }

    saveTemp() {
        this.tempSave = this.toJSON()
    }

    async restoreTemp() {
        if (!this.tempSave) {
            throw new Error("no save to restore found")
        }
        await this.load(this.tempSave)
    }

}

class TerminalData {

    defaultValues = {
        "background": "#030306",
        "foreground": "#ffffff",
        "font": "\"Cascadia Code\", monospace",
        "accentColor1": "#ffff00",
        "accentColor2": "#8bc34a",
        "history": "[]",
        "storageSize": "1000000",
        "startupCommands": "[\"helloworld\"]",
        "mobile": "2",
        "easterEggs": "[]",
        "maxHistoryLength": "100",
        "sidepanel": "true",
        "path": "[]",
        "aliases": '{"tree": "ls -r","github": "href -f root/github.url","hugeturtlo": "turtlo --size 2","hugehugeturtlo": "turtlo --size 3"}'
    }

    localStoragePrepend = "terminal-"

    getDefault(key) {
        return this.defaultValues[key]
    }

    get(key, defaultValue) {
        if (!defaultValue) defaultValue = this.getDefault(key)
        return localStorage.getItem(this.localStoragePrepend + key) ?? defaultValue
    }

    set(key, value) {
        localStorage.setItem(this.localStoragePrepend + key, value)
    }

    getCSSProperty(key) {
        let value = document.documentElement.style.getPropertyValue(key)
        if (!value) value = this.get(key)
        return value
    }

    setCSSProperty(key, value) {
        document.documentElement.style.setProperty(key, value)
    }

    get background() {
        return Color.fromHex(this.get("background"))
    }

    set background(color) {
        this.set("background", color.string.hex)
        this.setCSSProperty("--background", color.string.hex)
    }

    get foreground() {
        return Color.fromHex(this.get("foreground"))
    }

    set foreground(color) {
        this.set("foreground", color.string.hex)
        this.setCSSProperty("--foreground", color.string.hex)
    }

    get font() {
        return this.get("font")
    }

    set font(font) {
        this.set("font", font)
        this.setCSSProperty("--font", font)
    }

    get accentColor1() {
        return Color.fromHex(this.get("accentColor1"))
    }

    set accentColor1(color) {
        this.set("accentColor1", color.string.hex)
        this.setCSSProperty("--accent-color-1", color.string.hex)
    }

    get accentColor2() {
        return Color.fromHex(this.get("accentColor2"))
    }

    set accentColor2(color) {
        this.set("accentColor2", color.string.hex)
        this.setCSSProperty("--accent-color-2", color.string.hex)
    }

    get history() {
        return JSON.parse(this.get("history"))
    }

    set history(history) {
        this.set("history", JSON.stringify(history))
    }

    get path() {
        return JSON.parse(this.get("path"))
    }
    
    set path(path) {
        this.set("path", JSON.stringify(path))
    }

    get easterEggs() {
        let arr = JSON.parse(this.get("easterEggs"))
        return new Set(arr)
    }

    set easterEggs(newEasterEggs) {
        let arr = Array.from(newEasterEggs)
        this.set("easterEggs", JSON.stringify(arr))
    }

    get aliases() {
        return JSON.parse(this.get("aliases"))
    }

    set aliases(newAliases) {
        this.set("aliases", JSON.stringify(newAliases))
    }

    addAlias(alias, command) {
        let aliases = this.aliases
        aliases[alias] = command
        this.aliases = aliases
    }

    removeAlias(alias) {
        let aliases = this.aliases
        delete aliases[alias]
        this.aliases = aliases
    }

    addEasterEgg(easterEggID) {
        let foundEggs = this.easterEggs
        foundEggs.add(easterEggID)
        this.easterEggs = foundEggs
    }
    
    get mobile() {
        let value = this.get("mobile")
        if (value === "0") return undefined
        if (value === "1") return true
        if (value === "2") return false
        return null
    }

    set mobile(mobile) {
        if (mobile === undefined) mobile = "0"
        if (mobile === true) mobile = "1"
        if (mobile === false) mobile = "2"
        this.set("mobile", mobile)
    }

    get sidepanel() {
        return this.get("sidepanel") === "true"
    }

    set sidepanel(sidepanel) {
        this.set("sidepanel", sidepanel.toString())
    }

    get storageSize() {
        return parseInt(this.get("storageSize"))
    }

    set storageSize(size) {
        this.set("storageSize", size)
    }

    get maxHistoryLength() {
        return parseInt(this.get("maxHistoryLength"))
    }

    set maxHistoryLength(length) {
        this.set("maxHistoryLength", length)
    }

    get lastItemOfHistory() {
        return this.history[this.history.length - 1]
    }

    get startupCommands() {
        return JSON.parse(this.get("startupCommands"))
    }

    set startupCommands(commands) {
        this.set("startupCommands", JSON.stringify(commands))
    }

    addToHistory(command) {
        let history = this.history
        let lastItem = history[history.length - 1]
        if (lastItem == command) return
        history.push(command)
        if (history.length > this.maxHistoryLength) {
            history.shift()
        }
        this.history = history
    }

    constructor() {
        this.background = this.background
        this.foreground = this.foreground
        this.font = this.font
        this.accentColor1 = this.accentColor1
        this.accentColor2 = this.accentColor2
        this.mobile = this.mobile
    }

    resetProperty(key) {
        this.set(key, this.getDefault(key))
        this[key] = this[key]
    }

    resetAll() {
        for (let key in this.defaultValues) {
            this.set(key, this.defaultValues[key])
        }
    }

}

class Color {

    constructor(r, g, b, a) {
        this.r = r
        this.g = g
        this.b = b
        this.a = a ?? 1
    }

    static fromHex(hex) {
        if (!hex.startsWith("#"))
            hex = "#" + hex
        let r = parseInt(hex.substring(1, 3), 16)
        let g = parseInt(hex.substring(3, 5), 16)
        let b = parseInt(hex.substring(5, 7), 16)
        return new Color(r, g, b)
    }

    static fromHSL(h, s, l) {
        let r, g, b
        if (s == 0) {
            r = g = b = l
        } else {
            let hue2rgb = function hue2rgb(p, q, t) {
                if (t < 0) t += 1
                if (t > 1) t -= 1
                if (t < 1/6) return p + (q - p) * 6 * t
                if (t < 1/2) return q
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6
                return p
            }
            let q = l < 0.5 ? l * (1 + s) : l + s - l * s
            let p = 2 * l - q
            r = hue2rgb(p, q, h + 1/3)
            g = hue2rgb(p, q, h)
            b = hue2rgb(p, q, h - 1/3)
        }
        return new Color(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255))
    }

    static hsl(h, s, l) {
        return Color.fromHSL(h, s, l)
    }

    static hsla(h, s, l, a) {
        let color = Color.fromHSL(h, s, l)
        color.a = a
        return color
    }

    static hex(hex) {
        return Color.fromHex(hex)
    }

    static rgb(r, g, b) {
        return new Color(r, g, b)
    }

    static niceRandom() {
        const f = () => Math.floor(Math.random() * 100) + 150
        return new Color(f(), f(), f())
    }

    static random() {
        const f = () => Math.floor(Math.random() * 255)
        return new Color(f(), f(), f())
    }

    eq(color) {
        return this.r == color.r && this.g == color.g && this.b == color.b && this.a == color.a
    }

    equals(color) {
        return this.eq(color)
    }

    distanceTo(color) {
        let r = this.r - color.r
        let g = this.g - color.g
        let b = this.b - color.b
        let a = this.a - color.a
        return Math.sqrt(r * r + g * g + b * b + a * a)
    }

    get hsl() {

        let h = 0
        let s = 0
        let l = 0

        let r = this.r / 255
        let g = this.g / 255
        let b = this.b / 255

        let max = Math.max(r, g, b)
        let min = Math.min(r, g, b)

        if (max == min) h = 0
        else if (max == r) h = 60 * ((g - b) / (max - min))
        else if (max == g) h = 60 * (2 + (b - r) / (max - min))
        else if (max == b) h = 60 * (4 + (r - g) / (max - min))

        if (h < 0) h += 360

        l = (max + min) / 2
        
        if (max == min) s = 0
        else if (l <= 0.5) s = (max - min) / (max + min)
        else if (l > 0.5) s = (max - min) / (2 - max - min)

        return {
            h: h,
            s: s,
            l: l
        }

    }

    get string() {
        let self = this
        return {
            get rgb() {
                return `rgb(${self.r}, ${self.g}, ${self.b})`
            },

            get rgba() {
                return `rgba(${self.r}, ${self.g}, ${self.b}, ${self.a})`
            },

            get hex() {
                let r = self.r.toString(16).padStart(2, "0")
                let g = self.g.toString(16).padStart(2, "0")
                let b = self.b.toString(16).padStart(2, "0")
                return `#${r}${g}${b}`
            },

            get hsl() {
                let h = self.hsl.h
                let s = self.hsl.s * 100
                let l = self.hsl.l * 100
                return `hsl(${h}, ${s}%, ${l}%)`
            }

        }
    }

    toString() {
        return this.string.rgba
    }

    static get COLOR_1() {
        return terminal.data.accentColor1
    }

    static get COLOR_2() {
        return terminal.data.accentColor2
    }

    static get WHITE() {return new Color(255, 255, 255)}
    static get BLACK() {return new Color(0, 0, 0)}
    static get LIGHT_GREEN() {return new Color(0, 255, 0)}
    static get PURPLE() {return new Color(79, 79, 192)}
    static get ERROR() {return new Color(255, 128, 128)}

}

class IntendedError extends Error {
    constructor(message) {
        super(message)
        this.name = "IntendedError"
    }
}

class DeveloperError extends Error {
    constructor(message) {
        super(message)
        this.name = "DeveloperError"
    }
}

class ParserError extends Error {
    constructor(message) {
        super(message)
        this.name = "ParserError"
    }
}

class TerminalParser {

    static isVariable = (token) => /^\$[a-zA-Z][a-zA-Z0-9]*$/.test(token)
    static commandIsAssignment = (command) => /^\$[a-zA-Z][a-zA-Z0-9]*\s*=/.test(command)
    static extractVariableName = (command) => command.match(/^\$([a-zA-Z][a-zA-Z0-9]*)\s*=/)[1]

    static replaceVariables(tokens, variables) {
        return tokens.map(token => {
            if (this.isVariable(token)) {
                let name = this.extractVariableName(token + "=")
                if (name in variables) return variables[name]
            }
            return token
        })
    }
    
    static extractAssignment(command) {
        if (!TerminalParser.commandIsAssignment(command)) return null

        let variableName = TerminalParser.extractVariableName(command)
        let variableValue = command.split("=", 2)[1]
        return {
            name: variableName,
            value: variableValue
        }
    }

    static tokenize(input) {
        let tokens = []
        let tempToken = ""

        let apostropheCharacters = ["'", '"']
        let spaceCharacters = [" ", "\t", "\n"]

        let activeApostrophe = null

        for (let char of input) {
            if (activeApostrophe) {
                if (char == activeApostrophe) {
                    tokens.push(tempToken)
                    tempToken = ""
                    activeApostrophe = null
                } else {
                    tempToken += char
                }
            } else if (apostropheCharacters.includes(char)) {
                activeApostrophe = char
            } else if (spaceCharacters.includes(char)) {
                if (tempToken != "") {
                    tokens.push(tempToken)
                    tempToken = ""
                }
            } else {
                tempToken += char
            }
        }

        if (tempToken != "")
            tokens.push(tempToken)

        return tokens
    }

    static extractCommandAndArgs(tokens) {
        let args = [...tokens]
        let command = args[0]
        args.shift()
        return [command, args]
    }

    static parseArgOptions(argString) {
        // ?a is an optional argument
        // a is a required argument
        // abc is a required argument
        // ?abc is an optional argument
        // a:n is a required argument that is a number
        // ?a:n is an optional argument that is a number
        // a:n:1~100 is a required argument that is a number between 1 and 100
        // ?a:n:1~100 is an optional argument that is a number between 1 and 100
        // *a is a required argument that is a string and expands to the rest of the arguments
        // ?*a is an optional argument that is a string and expands to the rest of the arguments
        // a:b is a required argument that is a boolean

        let argOptions = {
            name: null,
            type: "string",
            typeName: "string",
            stringType: null,
            optional: false,
            min: null,
            max: null,
            expanding: false,
            numtype: undefined,
            default: undefined,
            forms: [],
            get fullName() {
                if (this.forms.length > 0)
                    return this.forms.join("|")
                return this.name
            },
            isHelp: false,
            description: ""
        }

        let name = argString

        if (name.startsWith("?")) {
            argOptions.optional = true
            name = name.substring(1)
        }

        if (name.startsWith("*")) {
            argOptions.expanding = true
            name = name.substring(1)
        }

        if (name.includes(":")) {
            let parts = name.split(":")
            name = parts[0]
            let type = parts[1]
            if (type == "n") {
                argOptions.type = argOptions.typeName = "number"
            } else if (type == "i") {
                argOptions.type = "number"
                argOptions.typeName = "integer"
                argOptions.numtype = "integer"
            } else if (type == "bn") {
                argOptions.type = "bigint"
                argOptions.typeName = "integer"
            } else if (type == "b") {
                argOptions.type = argOptions.typeName = "boolean"
            } else if (type == "s") {
                argOptions.type = argOptions.typeName = "string"
            } else if (type == "f") {
                argOptions.type = argOptions.typeName = "file"
            } else if (type == "c") {
                argOptions.type = argOptions.typeName = "command"
            } else if (type == "sm") {
                argOptions.type = argOptions.typeName = "square-matrix"
            } else if (type == "m") {
                argOptions.type = argOptions.typeName = "matrix"
            } else if (type == "e") {
                argOptions.type = argOptions.typeName = "enum"
            } else if (type == "t") {
                argOptions.type = argOptions.typeName = "string"
                argOptions.stringType = "text"
            } else {
                throw new DeveloperError(`Invalid argument type: ${type}`)
            }

            if (parts.length > 2) {
                if (argOptions.type == "number") {
                    let range = parts[2]
                    if (range.includes("~")) {
                        let rangeParts = range.split("~")
                        argOptions.min = parseFloat(rangeParts[0])
                        argOptions.max = parseFloat(rangeParts[1])
                    } else {
                        argOptions.min = parseFloat(range)
                        argOptions.max = parseFloat(range)
                    }
                } else if (argOptions.type == "enum") {
                    argOptions.enumOptions = parts[2].split("|")
                }
            }
        }

        argOptions.name = name
        argOptions.forms = [name]
        argOptions.description = ""
        argOptions.error = undefined
        argOptions.tokenIndex = undefined
        argOptions.tokenSpan = 0
        argOptions.value = undefined
        argOptions.isManuallySetValue = false

        if (argOptions.name.includes("=")) {
            argOptions.forms = argOptions.name.split("=")
            argOptions.name = argOptions.forms[1]
        }

        if (argOptions.name == "help" || argOptions.name == "h") {
            argOptions.isHelp = true
        }

        return argOptions
    }

    static getArgOption(argOptions, argName) {
        return argOptions.find(arg => arg.name == argName || arg.forms.includes(argName))
    }

    static parseNamedArgs(tokens, argOptions, parsingError) {
        let deleteIndeces = []

        for (let i = 0; i < tokens.length; i++) {
            let currToken = tokens[i]
            let nextToken = tokens[i + 1]
            let deleteNext = true

            const handleArg = name => {
                let argOption = this.getArgOption(argOptions, name)

                if (!argOption) {
                    parsingError.message = `Unexpected property "${name}"`
                    parsingError.tokenIndex = i
                } else if (!argOption.optional) {
                    argOption.tokenIndex = i
                    parsingError.message = `Property "${argOption.name}" is not optional, must be passed directly`
                    parsingError.tokenIndex = i
                    parsingError.tokenSpan = 1
                } else if (argOption.type == "boolean") {
                    argOption.tokenIndex = i
                    this._parseArgumentValue(argOption, true, parsingError)
                    deleteNext = false
                } else {
                    if (nextToken) {
                        argOption.tokenIndex = i
                        argOption.tokenSpan = 1
                        this._parseArgumentValue(argOption, nextToken, parsingError)
                    } else {
                        parsingError.message = `property "${argOption.name}" (${argOption.typeName}) expects a value`
                        parsingError.tokenIndex = i + 1
                    }
                }
            }

            if (currToken.match(/^--?[a-zA-Z][a-zA-Z0-9:_\-:.]*$/g)) {
                if (currToken.startsWith("--")) {
                    let name = currToken.slice(2)
                    handleArg(name)
                } else if (currToken.length == 2) {
                    let name = currToken.slice(1)
                    handleArg(name)
                } else {
                    for (let j = 0; j < currToken.length; j++) {
                        let char = currToken[j]
                        let argOption = this.getArgOption(argOptions, char)
                        if (char == "-") continue
                        if (argOption) {
                            argOption.tokenIndex = i
                            this._parseArgumentValue(argOption, true, parsingError)
                        }
                        if (j == currToken.length - 1) {
                            handleArg(char)
                        } else {
                            if (!argOption) {
                                parsingError.message = `Unexpected property "${char}"`
                                parsingError.tokenIndex = i
                            } else if (argOption.type != "boolean") {
                                parsingError.message = `Property "${char}" is not a boolean and must be assigned a value`
                                parsingError.tokenIndex = i
                            }
                        }

                        if (parsingError.message) return null
                    }
                }

                deleteIndeces.push(i)
                if (deleteNext)
                    deleteIndeces.push(i + 1)
            }

            if (parsingError.message) return null
        }

        return deleteIndeces
    }

    static _parseNumber(numberString, argOption, error) {
        // GRAMMAR:
        // number: "-" number | decimal | number "/" number | "0x" hexint | "0x" hexdecimal |
        //         "0b" binint | "0b" bindecimal | "sqrt(" number ")" |
        //         "sin(" number ")" | "cos(" number ")" | "tan(" number ")" |
        //         decimal "e" int | "pi" | "tau" | "phi" | "e" |
        //         number "*" number | number "^" number | number "-" number | number "+" number
        // decimal: int | int "." int
        // int: "0" int | ... | "9" int | "0" | ... | "9"
        // hexdecimal: hexint | hexint "." hexint
        // hexint: "0" hexint | ... | "f" hexint | "0" | ... | "f"
        // bindecimal: binint | binint "." binint
        // binint: "0" binint | "1" binint | "0" | "1"

        const constants = {
            "pi": Math.PI,
            "tau": 2 * Math.PI,
            "phi": (1 + Math.sqrt(5)) / 2,
            "e": Math.E
        }

        for (const [constant, value] of Object.entries(constants)) {
            if (numberString == constant) {
                return value
            }
        }

        if (numberString == "inf") {
            return error(`At property "${argOption.name}": Infinity is not a number`)
        }

        const decimalRegex = /^[0123456789]+\.[0123456789]+$/
        const intRegex = /^[0123456789]+$/
        const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
        const hexIntRegex = /^0x[0123456789abcdef]+$/
        const binDecimalRegex = /^0b[01]+\.[01]+$/
        const binIntRegex = /^0b[01]+$/
        const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e[0123456789]+$/

        if (numberString.startsWith("-")) {
            const value = this._parseNumber(numberString.slice(1), argOption, error)
            if (value == ParserError) {
                return value
            } else {
                return -value
            }
        }

        const allowedFunctions = {
            "sqrt": {
                compute: n => Math.sqrt(n),
                constraints: [
                    {
                        if: n => (n < 0),
                        err: () => error(`At property "${argOption.name}": sqrt is only defined on [0, inf)`)
                    }
                ]
            },
            "sin":     {compute: n => Math.sin(n)},
            "cos":     {compute: n => Math.cos(n)},
            "tan":     {compute: n => Math.tan(n)},
            "arcsin":  {
                compute: n => Math.asin(n),
                constraints: [
                    {
                        if: n => (n < -1) || (n > 1),
                        err: () => error(`At property "${argOption.name}": arcsin is only defined on [-1, 1]`)
                    }
                ]
            },
            "arccos":  {
                compute: n => Math.acos(n),
                constraints: [
                    {
                        if: n => (n < -1) || (n > 1),
                        err: () => error(`At property "${argOption.name}": arccos is only defined on [-1, 1]`)
                    }
                ]
            },
            "arctan":  {compute: n => Math.atan(n)},
            "sinh":    {compute: n => Math.sinh(n)},
            "cosh":    {compute: n => Math.cosh(n)},
            "tanh":    {compute: n => Math.tanh(n)},
            "arcsinh": {compute: n => Math.asinh(n)},
            "arccosh": {
                compute: n => Math.acosh(n),
                constraints: [
                    {
                        if: n => (n < 1),
                        err: () => error(`At property "${argOption.name}": arccosh is only defined on [1, inf)`)
                    }
                ]
            },
            "arctanh": {
                compute: n => Math.atanh(n),
                constraints: [
                    {
                        if: n => (n <= -1) || (n >= 1),
                        err: () => error(`At property "${argOption.name}": arctanh is only defined on (-1, 1)`)
                    }
                ]
            },
            "": {compute: n => n}
        }

        for (const [functionStr, func] of Object.entries(allowedFunctions)) {
            if (numberString.startsWith(`${functionStr}(`)) {
                // if we find that we closing bracket doesn't belong to opening bracket, abort
                const numberPart = numberString.slice(functionStr.length + 1, -1)
                let openCount = 0
                let abortThisExecution = false
                for (const char of numberPart) {
                    if (char == "(") {
                        openCount++
                    } else if (char == ")") {
                        openCount--
                    }
                    if (openCount < 0) {
                        abortThisExecution = true
                        break
                    }
                }
                if (abortThisExecution) {
                    continue
                }

                const value = this._parseNumber(numberPart, argOption, error)
                if (value == ParserError) return value
                for (const constraint of (func.constraints ?? [])) {
                    if (constraint.if(value)) {
                        return constraint.err()
                    }
                }
                return func.compute(value)
            }
        }

        if (intRegex.test(numberString)) {
            return parseInt(numberString)
        } else if (hexIntRegex.test(numberString)) {
            return parseInt(numberString.slice(2), 16)
        } else if (binIntRegex.test(numberString)) {
            return parseInt(numberString.slice(2), 2)
        }

        if (decimalRegex.test(numberString)) {
            return parseFloat(numberString)
        } else if (binDecimalRegex.test(numberString)) {
            const [before, after] = numberString.split(".")
            const beforeVal = parseInt(before.slice(2), 2)
            const afterVal = parseInt(after, 2)
            return beforeVal + afterVal / (2 ** after.length)
        } else if (hexDecimalRegex.test(numberString)) {
            const [before, after] = numberString.split(".")
            const beforeVal = parseInt(before.slice(2), 16)
            const afterVal = parseInt(after, 16)
            return beforeVal + afterVal / (16 ** after.length)
        }

        if (scientificRegex.test(numberString)) {
            let [decimal, exponent] = numberString.split("e")
            decimal = parseFloat(decimal)
            exponent = parseInt(exponent)
            return decimal * (10 ** exponent)
        }

        // in list of anti-precedence
        const operators = [
            ["+", (a, b) => a + b],
            ["-", (a, b) => a - b],
            ["*", (a, b) => a * b],
            ["/", (a, b) => a / b],
            ["^", (a, b) => a ** b],
        ]

        for (const [operatorName, operatorFunc] of operators) {
            let currLevel = 0
            let foundSplitIndex = null
            for (let i = 0; i < numberString.length; i++) {
                const char = numberString[i]
                if (char == "(") currLevel++
                if (char == ")") currLevel--
                if (currLevel < 0) {
                    return error(`At property "${argOption.name}": Unbalanced parentheses`)
                }
                if (char == operatorName && currLevel == 0) {
                    foundSplitIndex = i
                }
            }

            if (currLevel != 0) {
                return error(`At property "${argOption.name}": Unbalanced parentheses`)
            }

            if (foundSplitIndex === null) {
                continue
            }

            // split into two parts only
            const parts = [
                numberString.slice(0, foundSplitIndex),
                numberString.slice(foundSplitIndex + 1)
            ]

            for (let i = 0; i < 2; i++) {
                parts[i] = this._parseNumber(parts[i], argOption, error)
                if (parts[i] == ParserError) {
                    return parts[i]
                }
            }

            if (parts[1] == 0 && operatorName == "/") {
                return error(`At property "${argOption.name}": Can't divide by zero`)
            }

            return operatorFunc(parts[0], parts[1])
        }

        return error(`At property "${argOption.name}": Invalid number`)
    }

    static _parseArgumentValue(argOption, value, parsingError) {
        function addVal(value) {
            if (argOption.expanding && argOption.value) {
                value = argOption.value + " " + value
            }
            argOption.value = value
            argOption.isManuallySetValue = true
        }

        const error = msg => {
            parsingError.message = msg
            parsingError.tokenIndex = argOption.tokenIndex
            parsingError.tokenSpan = argOption.tokenSpan
            return ParserError
        }

        if (argOption.type == "number") {
            let num = this._parseNumber(value, argOption, error)
            if (num == ParserError) {
                return num
            }

            if (!Number.isFinite(num)) {
                return error(`At property "${argOption.name}": Infinity isn't a number`)
            } else if (Number.isNaN(num)) {
                return error(`At property "${argOption.name}": Not a number`)
            }

            if (argOption.numtype == "integer") {
                if (!Number.isInteger(num)) {
                    return error(`At property "${argOption.name}": Expected an integer`)
                }
            }

            if (argOption.min != null && num < argOption.min) {
                return error(`At property "${argOption.name}": Number must be at least ${argOption.min}`)
            }

            if (argOption.max != null && num > argOption.max) {
                return error(`At property "${argOption.name}": Number must be at most ${argOption.max}`)
            }

            addVal(num)
        } else if (argOption.type == "boolean") {
            const trueForms = ["true", true, "1"]
            const falseForms = ["false", false, "0"]
            if (!trueForms.concat(falseForms).includes(value)) {
                return error(`At property "${argOption.name}": Expected a boolean`)
            }
            addVal(trueForms.includes(value))
        } else if (argOption.type == "bigint") {
            try {
                addVal(BigInt(value))
            } catch {
                return error(`At property "${argOption.name}": Expected an integer`)
            }
        } else if (argOption.type == "file") {
            if (!terminal.fileExists(value)) {
                return error(`File not found: "${value}"`)
            }
            addVal(value)
        } else if (argOption.type == "command") {
            if (!terminal.commandExists(value)) {
                return error(`Command not found: "${value}"`)
            }
            addVal(value)
        } else if (argOption.type == "enum") {
            if (!argOption.enumOptions.includes(value)) {
                return error(`Invalid Option: "${value}"`)
            }
            addVal(value)
        } else if (argOption.type == "matrix" || argOption.type == "square-matrix") {
            // please consider me a regex god for this:
            // (matches any valid matrices)
            if (!/^\[((-?[0-9]+(\.[0-9]+)?)|[a-z])(\,((-?[0-9]+(\.[0-9]+)?)|[a-z]))*(\/((-?[0-9]+(\.[0-9]+)?)|[a-z])(\,((-?[0-9]+(\.[0-9]+)?)|[a-z]))*)*\]$/.test(value)) {
                return error(`Invalid matrix. Use syntax: [1,2/a,4]`)
            }

            let str = value.slice(1, value.length - 1)
            let rows = str.split("/").map(rowStr => {
                let values = rowStr.split(",")
                for (let i = 0; i < values.length; i++) {
                    if (/^(-?[0-9]+(\.[0-9]+)?)$/.test(values[i])) {
                        values[i] = parseFloat(values[i])
                    }
                }
                return values
            })

            if (rows.some(row => row.length != rows[0].length)) {
                return error(`Matrix must have equal sized rows.`)
            }

            if (argOption.type == "square-matrix") {
                if (rows.length != rows[0].length) {
                    return error(`Matrix must be square.`)
                }
            }

            addVal(rows)
        } else {
            addVal(value)
        }
    }

    static parseArguments(tempTokens, command={
        defaultValues: {},
        args: {},
        name: "",
        helpFunc: null,
        info: {}
    }) {
        let args = command.args, defaultValues = command.defaultValues ?? {}

        let argsArray = (args.toString() == "[object Object]") ? Object.keys(args) : args
        let argOptions = argsArray.map(this.parseArgOptions).flat()

        const parsingError = {
            message: undefined,
            tokenIndex: undefined,
            tokenSpan: 0
        }

        Object.entries(defaultValues).forEach(([name, value]) => {
            this.getArgOption(argOptions, name).default = value
            this.getArgOption(argOptions, name).value = value
        })

        if (args.toString() == "[object Object]")
            Object.entries(args).map(([arg, description], i) => {
                argOptions[i].description = description
                if (argOptions[i].type == "enum") {
                    const enumOptionStr = argOptions[i].enumOptions.join(" | ")
                    argOptions[i].description = argOptions[i].description.replaceAll("<enum>", enumOptionStr)
                }
            })
        
        const ignoreIndeces = this.parseNamedArgs(tempTokens, argOptions, parsingError)
        
        if (parsingError.message) {
            return {argOptions, parsingError}
        }

        ignoreIndeces.push(0)

        let argOptionIndex = 0
        for (let i = 0; i < tempTokens.length; i++) {
            if (ignoreIndeces.includes(i))
                continue
            
            const token = tempTokens[i]
            const argOption = argOptions[argOptionIndex]

            if (!argOption) {
                parsingError.message = "Too many arguments"
                parsingError.tokenIndex = i
                parsingError.tokenSpan = 99999
                return {argOptions, parsingError}
            }

            argOptionIndex++
            if (argOption.expanding) {
                if (!argOption._hasExpanded) {
                    argOption.tokenIndex = i
                    argOption.tokenSpan = 0
                    argOption._hasExpanded = true
                } else {
                    argOption.tokenSpan++
                }

                argOptionIndex--
            } else {
                argOption.tokenIndex = i
            }

            this._parseArgumentValue(argOption, token, parsingError)

            if (parsingError.message) {
                return {argOptions, parsingError}
            }
        }

        // check for missing required arguments
        for (let arg of argOptions) {
            if (!arg.optional && !arg.isManuallySetValue) {
                parsingError.message = `argument "${arg.name}" (${arg.typeName}) is missing`
                parsingError.tokenIndex = 99999
                return {argOptions, parsingError}
            }
        }

        return {argOptions, parsingError}
    }

    static _printParserError(command, argOptions, errMessage, {isHelp=false}={}) {
        let tempArgOptions = argOptions.filter(arg => !arg.isHelp)

        terminal.print("$ ", terminal.data.accentColor2)
        terminal.print(command.name + " ")
        if (tempArgOptions.length == 0)
            terminal.print("doesn't accept any arguments")
        terminal.printLine(tempArgOptions.map(arg => {
            let name = arg.name
            if (arg.optional) name = "?" + name
            return `<${name}>`
        }).join(" "), terminal.data.accentColor1)
        
        let maxArgNameLength = Math.max(...tempArgOptions.map(arg => arg.fullName.length))

        for (let argOption of tempArgOptions) {
            let autoDescription = ""

            if (argOption.default) {
                autoDescription += ` [default: ${argOption.default}]`
            } else if (argOption.optional) {
                autoDescription += " [optional]"
            }

            if (argOption.type == "number") {
                autoDescription += " [numeric"
                if (argOption.min != null) {
                    autoDescription += `: ${argOption.min}`
                    autoDescription += ` to ${argOption.max}`
                }
                autoDescription += "]"
            }

            let combinedDescription = autoDescription + " " + argOption.description

            if (combinedDescription.trim().length == 0)
                continue

            terminal.print(" > ")

            let argName = argOption.fullName
            if (argName.length > 1) argName = "--" + argName
            else argName = "-" + argName
            
            terminal.print(argName.padEnd(maxArgNameLength + 3), terminal.data.accentColor1)

            if (combinedDescription.length > 50) {
                terminal.printLine(autoDescription)
                terminal.print(" ".repeat(maxArgNameLength + 7))
                terminal.printLine(argOption.description)
            } else if (combinedDescription.length > 0) {
                terminal.printLine(combinedDescription)
            }
        }

        if (isHelp && command.helpFunc) {
            command.helpFunc()
        }

        if (errMessage)
            terminal.printError(errMessage, "ParseError")
    }

}

class Command {

    constructor(name, callback, info) {
        this.name = name
        this.callback = callback
        this.info = info
        this.args = info.args ?? {}
        this.helpFunc = info.helpFunc ?? null
        this.description = info.description ?? ""
        this.defaultValues = info.defaultValues ?? info.standardVals ?? {}
        this.author = info.author ?? "Noel Friedrich"
        this.windowScope = null
    }

    get terminal() {
        return this.windowScope.terminal
    }

    set terminal(newTerminal) {
        this.windowScope.terminal = newTerminal
    }

    checkArgs(tokens) {
        if (this.info.rawArgMode)
            return true
        try {
            const {parsingError} = TerminalParser.parseArguments(tokens, this)
            return !parsingError.message
        } catch (error) {
            return false
        }
    }

    processArgs(tokens, rawArgs) {
        if (this.info.rawArgMode)
            return rawArgs

        let {argOptions, parsingError} = TerminalParser.parseArguments(tokens, this)
        if (parsingError.message) {
            TerminalParser._printParserError(this, argOptions, parsingError.message)
            throw new IntendedError()
        }

        let valueObject = {}
        for (let argOption of argOptions) {
            for (let form of argOption.forms) {
                valueObject[form] = argOption.value
            }
        }

        return valueObject
    }

    async run(tokens, rawArgs, {callFinishFunc=true, terminalObj=undefined, processArgs=true}={}) {
        if (terminalObj)
            this.terminal = terminalObj
        if (callFinishFunc)
            this.terminal.expectingFinishCommand = true

        try {
            const passingArguments = processArgs
                ? [this.processArgs(tokens, rawArgs)]
                : [rawArgs, tokens]

            if (this.callback.constructor.name === 'AsyncFunction') {
                await this.callback(...passingArguments)
            } else {
                this.callback(...passingArguments)
            }

            if (callFinishFunc)
                this.terminal.finishCommand()
            return true
        } catch (error) {
            if (!(error instanceof IntendedError)) {
                this.terminal.printError(error.message, error.name)
                console.error(error)
            }

            if (callFinishFunc) {
                this.terminal.finishCommand()
            }

            // if the sleep command was called a max number
            // of times, it's considered to be a success
            return this.terminal.tempActivityCallCount === this.terminal.tempMaxActivityCallCount
        }
    }

}

const UtilityFunctions = {

    downloadFile(file) {
        if (file.isDirectory) {
            throw new Error("Cannot download directories")
        }

        let element = document.createElement('a')
        if (file.type == FileType.DATA_URL)
            var dataURL = file.content
        else
            var dataURL = 'data:text/plain;charset=utf-8,' + encodeURIComponent(file.content)
        element.setAttribute('href', dataURL)
        element.setAttribute('download', file.name)
        element.style.display = 'none'
        document.body.appendChild(element)
        element.click()
        document.body.removeChild(element)
    },

    mulberry32(a) {
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    },

    levenshteinDistance(str1, str2) {
        const track = Array(str2.length + 1).fill(null).map(
            () => Array(str1.length + 1).fill(null))

        for (let i = 0; i <= str1.length; i += 1) track[0][i] = i
        for (let j = 0; j <= str2.length; j += 1) track[j][0] = j

        for (let j = 1; j <= str2.length; j += 1) {
            for (let i = 1; i <= str1.length; i += 1) {
                const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1
                track[j][i] = Math.min(
                    track[j][i - 1] + 1,
                    track[j - 1][i] + 1,
                    track[j - 1][i - 1] + indicator,
                )
            }
        }

        return track[str2.length][str1.length]
    },

    stringPad(string, length, char=" ") {
        return string.toString().padStart(length, char)
    },

    stringPadBack(string, length, char=" ") {
        return string.toString().padEnd(length, char)
    },

    stringPadMiddle(string, length, char=" ") {
        string = string.toString()
        while (string.length < length) {
            string = char + string + char
        }
        while (string.length > length) {
            string = string.slice(1)
        }
        return string
    },

    stringMul(string, count) {
        return string.toString().repeat(count)
    },

    strRepeat(string, count) {
        return string.toString().repeat(count)
    },

    Color,

    FileType,
    FilePath,
    TerminalFile,
    DataURLFile,
    DirectoryFile,
    PlainTextFile,

    async playFrequency(f, ms, volume=0.5, destination=null, returnSleep=true) {
        if (!terminal.audioContext) {
            terminal.audioContext = new(window.AudioContext || window.webkitAudioContext)()
            if (!terminal.audioContext)
                throw new Error("Browser doesn't support Audio")
        }
    
        let oscillator = terminal.audioContext.createOscillator()
        oscillator.type = "square"
        oscillator.frequency.value = f
    
        let gain = terminal.audioContext.createGain()
        gain.connect(destination || terminal.audioContext.destination)
        gain.gain.value = volume
    
        oscillator.connect(gain)
        oscillator.start(terminal.audioContext.currentTime)
        oscillator.stop(terminal.audioContext.currentTime + ms / 1000)
    
        if (returnSleep)
            return terminal.sleep(ms)
    },

    parseColor(input) {
        // very slow but works
        // (creates a canvas element and draws the color to it
        //  then reads the color back as RGB)

        let canvas = document.createElement("canvas")
        canvas.width = 1
        canvas.height = 1
        let ctx = canvas.getContext("2d")
        ctx.fillStyle = input
        ctx.fillRect(0, 0, 1, 1)
        let data = ctx.getImageData(0, 0, 1, 1).data
        return new Color(data[0], data[1], data[2])
    },

    TerminalParser: TerminalParser,
    Command: Command,
    IntendedError: IntendedError,

    addAlias(alias, command) {
        if (terminal.inTestMode) return
        terminal.data.addAlias(alias, command)
        terminal.log(`Added alias "${alias}" for command "${command}"`)
    },

    shuffle(array) {
        // shuffles the array in-place and returns it using
        // the fischer-yates shuffle algorithm
        let cI = array.length
        while (cI != 0) {
            const rI = Math.floor(Math.random() * cI)
            cI--
            [array[cI], array[rI]] = [array[rI], array[cI]]
        }
        return array
    }

}

class TerminalModules {

    modulePath = "js/modules"

    constructor() {}

    async load(name, terminalObj) {
        if (terminalObj.inTestMode) {
            terminalObj.tempActivityCallCount = terminalObj.tempMaxActivityCallCount
            throw new IntendedError()
        }

        if (this[name])
            return this[name]

        let url = `${this.modulePath}/${name}.js`
        await terminalObj._loadScript(url)
        return this[name]
    }

    async import(name, window) {
        await this.load(name, window.terminal)
        for (let [key, value] of Object.entries(this[name])) {
            window[key] = value
        }
    }

}

let ALL_TERMINALS = {}
let CORRECTNESS_CACHE = {}

const OutputChannel = {
    USER: "user",
    NONE: "none",
    CACHE_AND_USER: "cache_and_user",
}

class KeyboardShortcut {

    constructor(key, callback, {
        ctrl=undefined,
        alt=undefined,
        shift=undefined
    }={}) {
        this.key = key
        this.callback = callback
        this.ctrl = ctrl
        this.alt = alt
        this.shift = shift
    }

    run(event) {
        this.callback(event)
    }

}

class Terminal {

    parser = TerminalParser

    parentNode = document.getElementById("terminal")
    containerNode = document.querySelector(".terminal-container")
    commandListURL = "js/load-commands.js"
    mobileKeyboardURL = "js/keyboard.js"
    defaultFileystemURL = "js/defaultFilesystem.js"
    sidePanelURL = "js/html/side-panel.js"

    mobileKeyboard = null
    currInputElement = null
    currSuggestionElement = null
    currInputContainer = null
    correctIndicator = null
    expectingFinishCommand = false
    commandCache = {}
    testProcessID = 0
    tempActivityCallCount = 0
    tempMaxActivityCallCount = Infinity
    debugMode = false
    tempCommandInputHistory = []

    guiMode = false

    keyboardShortcuts = []

    name = ""
    data = new TerminalData()
    fileSystem = new FileSystem()
    modules = new TerminalModules()

    outputChannel = OutputChannel.USER
    outputCacheVarName = null

    variableCache = {}

    loadingKey = null
    baseUrl = ""

    getOutputCache(key) {
        if (this.variableCache[key] === undefined)
            return ""
        return this.variableCache[key]
    }

    writeToOutputCache(value) {
        if (this.outputChannel == OutputChannel.NONE)
            throw new Error("Cannot write to output cache when output channel is set to none")
        if (this.outputCacheVarName === null)
            throw new Error("Cannot write to output cache when output cache var name is not set")

        let currCache = this.getOutputCache(this.outputCacheVarName)
        this.variableCache[this.outputCacheVarName] = currCache + value
    }

    getVariableValue(name) {
        return this.variableCache[name]
    }

    async setLoading(file) {
        let randomKey = Math.random().toString()
        this.loadingKey = randomKey

        // wait a bit before showing the loading overlay
        await this.sleep(150)

        if (this.loadingKey != randomKey)
            return

        this.unsetLoading()
        this.loadingElement = terminal.printLine(`\nLoading ${file}`, undefined, {forceElement: true})
    }

    async unsetLoading() {
        this.loadingKey = null
        if (this.loadingElement) {
            this.loadingElement.remove()
            this.loadingElement = null
        }
    }

    scroll(behavior="smooth", toLeft=true) {
        let opts = {
            top: 10 ** 9, // sufficiently large number
            // (number must be lower than 10**10, as firefox doesn't allow those values)
            behavior
        }
        if (toLeft)
            opts.left = 0
        this.parentNode.scrollTo(opts)
        this.containerNode.scrollTo(opts)
    }

    isUrlParamSet(param) {
        return new URLSearchParams(window.location.search).has(param)
    }

    get inTestMode() {
        return this.outputChannel == OutputChannel.NONE
    }

    addKeyboardShortcut(shortcut) {
        this.keyboardShortcuts.push(shortcut)
    }

    removeCurrInput() {
        if (this.currInputContainer) {
            this.currInputContainer.remove()
        }

        if (this.currCorrectnessOutput) {
            this.currCorrectnessOutput.remove()
        }

        this.currInputContainer = null
        this.currCorrectnessOutput = null
        this.currInputElement = null
        this.currSuggestionElement = null
    }

    _interruptSTRGC() {
        if (this.inTestMode)
            return
        
        terminal.printError("Pressed [^c]", "\nInterrupt")
        terminal.expectingFinishCommand = true
        for (let callback of this._interruptCallbackQueue)
            callback()
        this._interruptCallbackQueue = []
        terminal.finishCommand()
    }

    getFile(path, fileType=undefined) {
        // throws error if file not found
        let file = this.fileSystem.getFile(path)
        if (file == null) {
            throw new Error(`File "${path}" not found`)
        }
        if (fileType && file.type != fileType)
            throw new Error(`File "${path}" is not a ${fileType}`)
        return file
    }

    async createFile(fileName, fileType, data) {
        if (!terminal.isValidFileName(fileName))
            throw new Error("Invalid filename")
        if (terminal.fileExists(fileName))
            throw new Error("File already exists")
        let newFile = new (fileType)(data)
        if (!terminal.inTestMode) {
            terminal.currDirectory.content[fileName] = newFile
            await terminal.fileSystem.reload()
        }
        return newFile
    }

    fileExists(path) {
        return !!this.fileSystem.getFile(path)
    }

    updatePath() {
        this.data.path = this.fileSystem.path.items
    }

    isValidFileName(name) {
        return name.match(/^[a-zA-Z0-9_\-\.]{1,100}$/)
    }

    async copy(text, {printMessage=false}={}) {
        if (terminal.inTestMode)
            return
        
        await navigator.clipboard.writeText(text)

        if (printMessage)
            terminal.printLine("Copied to Clipboard ✓")
    }

    async sleep(ms) {
        terminal.tempActivityCallCount++
        if (terminal.tempActivityCallCount === terminal.tempMaxActivityCallCount)
            throw new IntendedError()

        if (terminal.outputChannel == OutputChannel.NONE)
            return

        let running = true
        let aborted = false
        const intervalFunc = () => {
            if (!running) return
            if (terminal.pressed.Control && terminal.pressed.c || terminal._interruptSignal) {
                terminal._interruptSignal = false
                running = false
                clearInterval(interval)
                aborted = true
                terminal._interruptSTRGC()
            }
        }

        let interval = setInterval(intervalFunc, 50)
        intervalFunc()

        return new Promise(resolve => {
            setTimeout(() => {
                running = false
                clearInterval(interval)
                if (!aborted) resolve()
            }, ms)
        })
    }

    interrupt() {
        this._interruptSignal = true
    }

    onInterrupt(callback) {
        this._interruptCallbackQueue.push(callback)
    }

    reload() {
        location.reload()
    }

    href(url) {
        if (terminal.inTestMode)
            return
        window.location.href = url
    }

    setInputCorrectness(correct) {
        if (!this.correctIndicator)
            return
        if (correct) {
            this.correctIndicator.style.color = Color.LIGHT_GREEN.toString()
        } else {
            this.correctIndicator.style.color = Color.ERROR.toString()
        }
    }

    getAutoCompleteOptions(text) {
        let lastWord = text.split(/\s/g).pop()
        const allRelativeFiles = this.fileSystem.allFiles()
            .map(file => file.path.toString())
            .concat(this.fileSystem.currDirectory.allChildren.map(c => c.path.toString().slice(this.fileSystem.pathStr.length)))

        const configMatches = ms => ms.filter(f => f.startsWith(lastWord))
            .sort().sort((a, b) => a.length - b.length)

        const exportMatches = ms => ms.map(match => {
            let words = text.split(" ")
            words.pop()
            words.push(match)
            return words.join(" ")
        }).filter(s => s != text)

        const addApostrophes = ms => ms.map(m => {
            if (m.includes(" ")) {
                let apostrphe = '"'
                if (m.includes(apostrphe)) {
                    apostrphe = "'"
                    if (m.includes(apostrphe)) {
                        apostrphe = ""
                        // TODO: add more apostrophe types to prevent this
                    }
                } 
                return `${apostrphe}${m}${apostrphe}`
            }
            return m
        })

        let commandMatches = configMatches(this.visibleFunctions.map(f => f.name)
            .concat(Object.keys(this.data.aliases)))

        // if is first word
        if (lastWord === text.trim()) {
            return exportMatches(commandMatches)
        }

        let fileMatches = configMatches(addApostrophes(allRelativeFiles))

        const {argOptions} = this.parse(text)

        let currArgOption = {}
        if (text.slice(-1) == " ") {
            const nextArgOption = argOptions.filter(o => !o.isManuallySetValue)[0]
            if (nextArgOption !== undefined) {
                currArgOption = nextArgOption
            }
        } else {
            currArgOption = argOptions.reduce((p, c) => c.tokenIndex ? (c.tokenIndex > p.tokenIndex ? c : p) : p, {tokenIndex: 0})
        }

        // if an argOption is currently being edited
        if (currArgOption.name) {
            if (currArgOption.type == "boolean") {
                return exportMatches(configMatches(argOptions.filter(o => !o.isManuallySetValue)
                    .map(o => o.name.length > 1 ? `--${o.name}` : `-${o.name}`)))
            }

            if (currArgOption.type == "file") {
                return exportMatches(fileMatches)
            }

            if (currArgOption.type == "command") {
                return exportMatches(commandMatches)
            }

            if (currArgOption.type == "enum") {
                return exportMatches(configMatches(currArgOption.enumOptions))
            }
        }

        return []
    }

    sanetizeInput(text) {
        text = text.replaceAll(/![0-9]+/g, match => {
            let index = parseInt(match.slice(1)) - 1
            if (terminal.data.history[index])
                return terminal.data.history[index]
            return match
        })
        text = text.replaceAll(/!!/g, () => {
            return terminal.data.history[terminal.data.history.length - 1] ?? ""
        })
        for (let [alias, command] of Object.entries(terminal.data.aliases)) {
            text = text.replaceAll(RegExp(`^${alias}`, "g"), command)
        }
        return text
    }

    turnToTestMode() {
        this.outputChannel = OutputChannel.NONE
    }

    async updateInputCorrectnessDebug(text) {
        // experimental feature
        // this is a very hacky way to do this
        // and produces a lot of side effects and bugs
        // (for now hidden in debug mode)

        this.testProcessID++

        let virtualTerminal = new Terminal(`v${this.testProcessID}`)
        await virtualTerminal.initFrom(this)
        virtualTerminal.turnToTestMode()
        virtualTerminal.testProcessID = this.testProcessID

        virtualTerminal.tempActivityCallCount = 0
        virtualTerminal.tempMaxActivityCallCount = 1
        
        let wentWell = true

        try {
            wentWell = await virtualTerminal.input(text, true)
        } catch {
            wentWell = false
        }

        if (!wentWell) {
            wentWell = virtualTerminal.tempActivityCallCount === virtualTerminal.tempMaxActivityCallCount
        }

        if (virtualTerminal.testProcessID == this.testProcessID) {
            this.setInputCorrectness(wentWell)
        }

        CORRECTNESS_CACHE[text] = wentWell
    }

    async updateInputCorrectness(text) {
        if (text.trim().length == 0) {
            this.setInputCorrectness(true)
            return
        }

        if (this.debugMode)
            return await this.updateInputCorrectnessDebug(text)

        if (text in CORRECTNESS_CACHE) {
            this.setInputCorrectness(CORRECTNESS_CACHE[text])
            return
        }

        if (TerminalParser.isVariable(text)) {
            let name = TerminalParser.extractVariableName(text + "=")
            this.setInputCorrectness(name in this.variableCache)
            return
        }

        let assignmentInfo = TerminalParser.extractAssignment(text)
        if (assignmentInfo) {
            text = assignmentInfo.value
        }

        let tokens = TerminalParser.tokenize(text)
        tokens = TerminalParser.replaceVariables(tokens, this.variableCache)
        let [commandText, args] = TerminalParser.extractCommandAndArgs(tokens)
        if (!this.commandExists(commandText)) { 
            this.setInputCorrectness(false)
            return
        }

        let commandData = this.commandData[commandText] 
        this.setInputCorrectness(true)

        let tempCommand = new Command(commandText, () => undefined, commandData)
        tempCommand.windowScope = this.window
        tempCommand.terminal = this
        this.setInputCorrectness(tempCommand.checkArgs(tokens))
    }

    _createDefaultGetHistoryFunc() {
        if (this.commandIsExecuting) {
            return () => this.tempCommandInputHistory
        } else {
            return () => this.data.history
        }
    }

    _createDefaultAddToHistoryFunc() {
        if (this.commandIsExecuting) {
            return data => this.tempCommandInputHistory.push(data)
        } else {
            return data => this.data.addToHistory(data)
        }
    }

    focusInput({element=null, options={}}={}) {
        if (this.mobileKeyboard) {
            this.mobileKeyboard.show()
            return
        }

        let input = element ?? this.currInputElement
        if (input) {
            input.focus(options)
        }
    }

    updateCorrectnessText(prompt, element, inputElement) {
        const {text, color} = this.getCorrectnessText(prompt, inputElement)
        element.textContent = text ? "\n" + text : ""
        if (color) {
            element.style.color = color
        }
    }

    parse(prompt) {
        const tokens = TerminalParser.tokenize(prompt)
        let [commandText, args] = TerminalParser.extractCommandAndArgs(tokens)

        if (commandText == undefined) {
            return {argOptions: [], parsingError: {
                message: undefined, tokenIndex: undefined, tokenSpan: 0
            }}
        }

        if (!this.commandExists(commandText)) { 
            return {argOptions: [], parsingError: {
                message: "command not found", tokenIndex: 0, tokenSpan: 0
            }}
        }

        let commandData = this.commandData[commandText]

        let tempCommand = new Command(commandText, () => undefined, commandData)
        tempCommand.windowScope = this.window
        tempCommand.terminal = this

        return TerminalParser.parseArguments(tokens, tempCommand)
    }

    getCorrectnessText(prompt, inputElement) {
        if (prompt.length == 0)
            return ""

        let tokens = TerminalParser.tokenize(prompt)

        const underlinePart = (startIndex, length, message, color=Color.ERROR) => {
            if (message == "") return {text: ""}

            const inputOffset = this.fileSystem.pathStr.length
            let out = " ".repeat(inputOffset + startIndex) + "┬" + "─".repeat(Math.max(length - 1, 0)) + "\n"
            out += " ".repeat(inputOffset + startIndex) + "|\n"
            
            let lines = message.split("\n").filter(l => !!l)
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i]
                let beforeChar = i == lines.length - 1 ? "└" : "├"
                out += " ".repeat(inputOffset + startIndex) + beforeChar + " " + line + "\n"
            }

            return {text: out, color}
        }

        const positionFromToken = tokenIndex => {
            let startPosition = 0
            let tempPrompt = prompt
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i]
                let firstIndex = tempPrompt.indexOf(token)
                tempPrompt = tempPrompt.slice(firstIndex + token.length)
                startPosition = prompt.length - (tempPrompt.length + token.length) + 1

                if (i == tokenIndex) {
                    break
                }
            }
            return startPosition
        }

        const underLineToken = (tokenIndex, tokenSpan, message, color=Color.ERROR) => {
            if (tokenIndex >= tokens.length) {
                let offset = prompt.length + 1
                if (prompt.slice(-1) == " ") offset--
                return underlinePart(offset, 3, message, color)
            }

            tokenSpan = Math.min(tokenSpan, tokens.length - 1 - tokenIndex)

            let startPosition = positionFromToken(tokenIndex)
            let endPosition = startPosition + tokens[tokenIndex].length
            for (let i = 0; i < tokenSpan; i++) {
                endPosition = positionFromToken(tokenIndex + i + 1)
                endPosition += tokens[tokenIndex + i + 1].length
            }

            return underlinePart(startPosition - 1, endPosition - startPosition, message, color)
        }

        let [commandText, args] = TerminalParser.extractCommandAndArgs(tokens)

        if (commandText == undefined) {
            return ""
        }

        if (!this.commandExists(commandText)) { 
            return underlinePart(prompt.indexOf(commandText), commandText.length, `command not found`)
        }

        let commandData = this.commandData[commandText]

        let tempCommand = new Command(commandText, () => undefined, commandData)
        tempCommand.windowScope = this.window
        tempCommand.terminal = this

        let {argOptions, parsingError} = TerminalParser.parseArguments(tokens, tempCommand)

        if (parsingError.message && tokens.length > 1 && !commandData.rawArgMode) {
            return underLineToken(parsingError.tokenIndex, parsingError.tokenSpan, parsingError.message)
        }

        const makeArgumentInfo = argOption => {
            let out = ""
            if (argOption.name.length == 1) {
                out += `-`
            } else {
                out += `--`
            }
            out += `${argOption.name}`

            out += " ("
            if (argOption.optional) {
                out += "optional, "
            }
            out += `${argOption.typeName}) `
            
            if (argOption.type == "enum") {
                const optionStr = argOption.enumOptions.join(" | ")
                return `${out}: ${optionStr.length > 30 ? (optionStr.slice(0, 40) + "...") : optionStr}`
            }

            out += argOption.description

            return out
        }

        const makeCommandInfoString = () => {
            let out = ""

            let filteredOptions = argOptions.filter(o => !o.isManuallySetValue)
            for (let argOption of filteredOptions) {
                out += `${makeArgumentInfo(argOption)}\n`
            }
            
            return out
        }

        let currTokenIndex = 0
        for (let i = 0; i < tokens.length; i++) {
            let position = positionFromToken(i)
            if (inputElement.selectionStart >= position - 1) {
                currTokenIndex = i
            }
        }

        let currArgOption = undefined
        for (let argOption of argOptions) {
            if (argOption.tokenIndex == undefined) {
                continue
            }

            if (currTokenIndex >= argOption.tokenIndex && currTokenIndex <= argOption.tokenIndex + argOption.tokenSpan) {
                currArgOption = argOption
                break
            }
        }

        if ((tokens.length == 1 && prompt.slice(-1) != " ") || argOptions.length == 0 || (currTokenIndex == 0 && tokens.length > 1)) {
            return underLineToken(0, 0, `"${commandData.description}"`, Color.fromHex("#9d64ff"))
        }

        // user is at end of selection and wants more info about arguments
        if (prompt.slice(-1) == " " && prompt.length == inputElement.selectionStart) {
            return underLineToken(9999, 1, makeCommandInfoString(), Color.fromHex("#9d64ff"))
        }

        if (currArgOption) {
            return underLineToken(currArgOption.tokenIndex, currArgOption.tokenSpan,
                makeArgumentInfo(currArgOption), Color.fromHex("#9d64ff"))
        }

        return ""
    }

    createStyledInput() {
        let input = document.createElement("input")
        input.type = "text"
        input.className = "terminal-input"
        input.autocomplete = "off"
        input.autocorrect = "off"
        input.autocapitalize = "off"
        input.spellcheck = "false"
        input.name = "terminal-input"
        return input
    }

    createTerminalButton({
        text="Press here!",
        charWidth=8,
        onPress=undefined
    }={}) {
        let button = this.document.createElement("button")

        button.textContent = text
        button.onclick = onPress
        
        button.style.width = `${this.charWidth * charWidth}px`
        button.style.backgroundColor = terminal.data.foreground.toString()
        button.style.color = terminal.data.background.toString()
        button.style.cursor = "pointer"

        return button
    }

    async prompt(msg, {password=false, affectCorrectness=false,
        getHistory = this._createDefaultGetHistoryFunc(),
        addToHistory = this._createDefaultAddToHistoryFunc(),
        inputCleaning=!this.commandIsExecuting,
        inputSuggestions=!this.commandIsExecuting,
        mobileLayout=undefined,
        printInputAfter=true,
        makeClickCopy=true
    }={}) {
        if (this.inTestMode) {
            this.tempActivityCallCount++
            return ""
        }

        function lastItemOfHistory() {
            let history = getHistory()
            return history[history.length - 1]
        }

        if (msg) terminal.print(msg)

        const createInput = () => {
            let inputContainer = document.createElement("div")
            inputContainer.className = "terminal-input-container"

            let input = this.createStyledInput()

            if (this.mobileKeyboard) {
                input.addEventListener("focus", () => {
                    this.mobileKeyboard.show()
                })
                input.readOnly = true
                input.inputMode = "none"
            }

            // for screen readers (bots) only
            let label = document.createElement("label")
            label.className = "terminal-input-label"
            label.textContent = "Input a terminal command"
            label.style.display = "none"
            label.htmlFor = "terminal-input"
            inputContainer.appendChild(label)

            let suggestion = document.createElement("div")
            suggestion.className = "terminal-suggestion"
            
            inputContainer.appendChild(input)
            inputContainer.appendChild(suggestion)

            if (password) input.type = "password"
            return [input, suggestion, inputContainer]
        }

        let [inputElement, suggestionElement, inputContainer] = createInput()
        this.parentNode.appendChild(inputContainer)
        const inputMinWidth = () => {
            let rect = inputElement.getBoundingClientRect()
            return this.window.innerWidth - rect.left * 2
        }
        inputContainer.style.width = `${inputMinWidth()}px`

        this.currCorrectnessOutput = null
        let thisIsActivePrompt = true

        if (affectCorrectness) {
            this.currCorrectnessOutput = this.print("", Color.ERROR, {forceElement: true})
        }

        this.scroll("smooth", false)
        this.currInputElement = inputElement
        this.currSuggestionElement = suggestionElement
        this.currInputContainer = inputContainer
        this.focusInput({options: {preventScroll: true}})

        function getInputValueSanetized() {
            // IOS produces special characters instead of ascii ("-", "'", etc)
            // ~ Since we don't want em, we replace em ~
            return inputElement.value
                .replaceAll(/[\u2018\u2019\u201B\u2032\u2035]/g, "'")
                .replaceAll(/[\u201C\u201D\u201F\u2033\u2036]/g, '"')
                .replaceAll(/[\u2013\u2014]/g, "-")
        }

        return new Promise(resolve => {
            let inputValue = ""
            let keyListeners = {}

            keyListeners["Enter"] = event => {
                let text = getInputValueSanetized()

                const printText = password ? "•".repeat(text.length) : text
                if (printInputAfter) {
                    if (makeClickCopy) {
                        const outElement = this.printLine(printText, undefined, {forceElement: true})
                        outElement.addEventListener("click", event => {
                            if (this.currInputElement) {
                                this.currInputElement.value += printText
                                event.preventDefault()
                            }
                        })
                        outElement.style.cursor = "pointer"
                    } else {
                        this.printLine(printText)
                    }
                }

                if (inputCleaning) {
                    text = this.sanetizeInput(getInputValueSanetized())
                }

                if (text !== lastItemOfHistory() && text.length > 0) {
                    addToHistory(text)
                }

                this.removeCurrInput()

                if (this.currCorrectnessOutput) {
                    this.currCorrectnessOutput.remove()
                }

                resolve(text)
                thisIsActivePrompt = true
            }

            let tabIndex = 0
            let suggestions = []

            const completeSuggestion = () => {
                if (!inputSuggestions) {
                    inputElement.value += "    "
                    inputElement.oninput()
                    return
                }
                if (suggestions.length > 0) {
                    inputElement.value = suggestions[tabIndex % suggestions.length]
                    suggestionElement.textContent = ""
                    
                    tabIndex = (tabIndex + 1) % suggestions.length
                    inputValue = ""
                }
            }

            keyListeners["Tab"] = event => {
                event.preventDefault()
                completeSuggestion()
            }

            suggestionElement.onclick = () => {
                completeSuggestion()
                inputElement.oninput()
            }

            let historyIndex = getHistory().length
            keyListeners["ArrowUp"] = event => {
                event.preventDefault()
                let history = getHistory()
                if (historyIndex > 0) {
                    historyIndex--
                    inputElement.value = history[historyIndex]
                }
                inputElement.oninput()
            }

            keyListeners["ArrowDown"] = event => {
                event.preventDefault()
                let history = getHistory()
                historyIndex++
                if (historyIndex > history.length - 1) {
                    historyIndex = history.length
                    inputElement.value = ""
                } else {
                    inputElement.value = history[historyIndex]
                }
                inputElement.oninput()
            }

            inputElement.oninput = async event => {
                if (!thisIsActivePrompt) {
                    return
                }

                suggestions = this.getAutoCompleteOptions(getInputValueSanetized())

                if (!inputSuggestions) {
                    suggestionElement.textContent = ""
                    return
                }

                const replaceAlreadywritten = (oldText, replacement=" ") => {
                    let newText = ""
                    for (let i = 0; i < oldText.length; i++) {
                        if (inputElement.value[i]) {
                            newText += replacement
                        } else {
                            newText += oldText[i]
                        }
                    }
                    return newText
                }

                if (suggestions.length > 0 && inputElement.value.trim().length > 0) {
                    suggestionElement.textContent = replaceAlreadywritten(suggestions[0])
                } else {
                    suggestionElement.textContent = ""
                }

                if (affectCorrectness) {
                    let cleanedInput = this.sanetizeInput(getInputValueSanetized())
                    this.updateInputCorrectness(cleanedInput)
                    if (this.currCorrectnessOutput) {
                        this.updateCorrectnessText(getInputValueSanetized(), this.currCorrectnessOutput, inputElement)
                    }
                }

                let textLength = Math.max(inputElement.value.length, suggestionElement.textContent.length)
                // (textLength + 1) to leave room for the next character
                let inputWidth = (textLength + 1) * this.charWidth
                inputContainer.style.width = `max(${inputMinWidth()}px, ${inputWidth}px)`
            }

            inputElement.onselectionchange = () => {
                if (!thisIsActivePrompt) {
                    return
                }

                if (affectCorrectness) {
                    let cleanedInput = this.sanetizeInput(getInputValueSanetized())
                    this.updateInputCorrectness(cleanedInput)
                    if (this.currCorrectnessOutput) {
                        this.updateCorrectnessText(getInputValueSanetized(), this.currCorrectnessOutput, inputElement)
                    }
                }
            }

            inputElement.onkeydown = async (event, addToVal=true) => {
                if (!thisIsActivePrompt) {
                    return
                }

                if (addToVal) {
                    if (event.key.length == 1) // a, b, c, " "
                        inputValue = getInputValueSanetized() + event.key
                    else if (event.key == "Backspace")
                        inputValue = getInputValueSanetized().slice(0, -1)
                    else // Tab, Enter, etc.
                        inputValue = getInputValueSanetized()
                }

                if (keyListeners[event.key]) {
                    if (thisIsActivePrompt) {
                        keyListeners[event.key](event)
                    }
                } else {
                    tabIndex = 0
                }

                if (event.key == "c" && event.ctrlKey) {
                    if (this.currCorrectnessOutput) {
                        this.currCorrectnessOutput.remove()
                    }

                    this.removeCurrInput()
                    this._interruptSTRGC()
                    thisIsActivePrompt = false
                }

                // call async to let selection be updated before event is fired
                setTimeout(inputElement.onselectionchange, 0)
            }

            addEventListener("resize", event => {
                let inputWidth = (inputElement.value.length + 1) * this.charWidth
                inputContainer.style.width = `max(${inputMinWidth()}px, ${inputWidth}px)`
            })

            if (this.mobileKeyboard) {
                if (mobileLayout === undefined)
                    this.mobileKeyboard.updateLayout(this.mobileKeyboard.Layout.DEFAULT)
                else
                    this.mobileKeyboard.updateLayout(mobileLayout)

                this.mobileKeyboard.show()
                this.mobileKeyboard.oninput = event => {
                    if (event.key == "Backspace")
                        inputElement.value = getInputValueSanetized().slice(0, -1)

                    if (!event.isFunctionKey) {
                        inputElement.value += event.keyValue
                    }

                    inputValue = inputElement.value

                    inputElement.onkeydown(event, false)
                    inputElement.oninput(event)

                    this.scroll("smooth", false)
                }
            }

        })

    }

    async acceptPrompt(msg, standardYes=true) {
        const nope = () => {throw new IntendedError("Nope")}
        let extraText = ` [${standardYes ? "Y/n" : "y/N"}] `
        let text = await this.prompt(msg + extraText, {mobileLayout: [["y", "n"], ["<", "Enter"]]})

        if (text == "" && standardYes) return true
        if (text.toLowerCase().startsWith("y")) return true

        nope()
    }

    async promptNum(msg=null, {min=null, max=null, integer=false}={}) {
        min = min ?? -Infinity
        max = max ?? Infinity
        while (true) {
            let inp = await this.prompt(msg)
            if (isNaN(inp) || inp.length == 0) {
                this.printError("You must supply a valid number")
                continue
            }
            let num = parseFloat(inp)
            if (min > num) {
                this.printError(`The number must be larger/equal than ${min}`)
            } else if (max < num) {
                this.printError(`The number must be smaller/equal than ${max}`)
            } else if (integer && !Number.isInteger(num)) {
                this.printError(`The number must be an integer`)
            } else {
                return num
            }
        }
    }

    print(text, color=undefined, {
        forceElement=false, element="span", fontStyle=undefined,
        background=undefined, addToCache=true, outputNode=undefined
    }={}) {
        outputNode ??= this.parentNode

        if (this.outputChannel == OutputChannel.CACHE_AND_USER && addToCache) {
            this.writeToOutputCache(text)
        }

        text ??= ""
        let output = undefined
        if (color === undefined && !forceElement && fontStyle === undefined && background === undefined) {
            let textNode = document.createTextNode(text)
            if (!this.inTestMode)
                outputNode.appendChild(textNode)
            output = textNode
        } else {
            let span = document.createElement(element)
            span.textContent = text
            if (color !== undefined) span.style.color = color.string.hex
            if (fontStyle !== undefined) span.style.fontStyle = fontStyle
            if (background !== undefined) {
                span.style.backgroundColor = background.string.hex
            }

            if (!this.inTestMode) {
                outputNode.appendChild(span)
            }
            output = span
        }
        return output
    }

    printItalic(text, color=undefined, opts) {
        return this.printLine(text, color, {...opts, fontStyle: "italic"})
    }

    printImg(src, {
        altText = "",
        outputNode = undefined
    }={}) {
        outputNode ??= this.parentNode

        if (this.inTestMode)
            return

        let img = outputNode.appendChild(document.createElement("img"))
        img.src = src
        img.alt = altText
        img.classList.add("terminal-img")
        img.onload = this._styleImgElement.bind(this, img)
        return img
    }

    _styleImgElement(img, invertSetting=false, {maxWidth=40, maxHeight=40}={}) {
        img.style.aspectRatio = img.naturalWidth / img.naturalHeight
        let changeCondition = img.clientHeight < img.clientWidth
        if (invertSetting) changeCondition = !changeCondition
        if (changeCondition) {
            img.style.width = "auto"
            let height = Math.min(img.naturalHeight, maxHeight)
            img.style.height = `calc(var(--font-size) * ${height})`
        } else {
            img.style.height = "auto"
            let width = Math.min(img.naturalWidth, maxWidth)
            img.style.width = `calc(var(--font-size) * ${width})`
        }
    }

    printTable(inRows, headerRow=null, opts) {
        let rows = inRows.map(r => r.map(c => (c == undefined) ? " " : c))
        if (headerRow != null) rows.unshift(headerRow)
        const column = i => rows.map(row => row[i])
        const columnWidth = i => Math.max(...column(i)
            .map(e => String((e == undefined) ? " " : e).length))
        for (let rowIndex = 0; rowIndex <= rows.length; rowIndex++) {
            if (rowIndex == 0
                || (rowIndex == 1 && headerRow != null)
                || (rowIndex == rows.length)) {
                let line = ""
                for (let columnIndex = 0; columnIndex < rows[0].length; columnIndex++) {
                    let item = UtilityFunctions.stringMul("-", columnWidth(columnIndex))
                    line += `+-${item}-`
                }
                line += "+"
                this.printLine(line, opts)
            }
            if (rowIndex == rows.length) break
            let line = ""
            for (let columnIndex = 0; columnIndex < rows[0].length; columnIndex++) {
                let itemVal = rows[rowIndex][columnIndex]
                if (itemVal == undefined) itemVal = " "
                let padFunc = (rowIndex == 0 && headerRow != null) ? UtilityFunctions.stringPadMiddle : UtilityFunctions.stringPadBack
                let item = padFunc(itemVal, columnWidth(columnIndex))
                line += `| ${item} `
            }
            line += "|  "
            this.printLine(line, opts)
        }
    }

    async animatePrint(text, interval=50, {newLine=true}={}) {
        if (interval == 0) {
            this.print(text)
        } else {
            for (let char of text) {
                this.print(char)
                await this.sleep(interval)
            }
        }
        if (newLine) this.printLine()
    }

    printLine(text, color, opts) {
        text ??= ""
        return this.print(text + "\n", color, opts)
    }

    printError(text, name="Error", opts) {
        this.print(name, new Color(255, 0, 0), opts)
        this.printLine(": " + text, undefined, opts)
        this.log(text, {type: "error"})
    }

    printSuccess(text) {
        this.printLine(text, new Color(0, 255, 0))
    }

    addLineBreak(n=1) {
        for (let i = 0; i < n; i++)
            this.printLine()
    }

    printClickable(text, callback, color, opts) {
        let element = this.print(text, color, {forceElement: true, ...opts})
        element.onclick = callback
        element.classList.add("clickable")
        if (color) element.style.color = color.string.hex
        return element
    }

    printCommand(commandText, command, color, endLine=true, opts) {
        let element = this.print(commandText, color, {forceElement: true, ...opts})
        element.onclick = this.makeInputFunc(command ?? commandText)
        element.classList.add("clickable")
        if (color) element.style.color = color.string.hex
        if (endLine) this.addLineBreak()
    }

    printEasterEgg(eggName, {endLine=true}={}) {
        if (!terminal.currInputElement)
            terminal.printEasterEggRaw(eggName, endLine)
        else {
            terminal.removeCurrInput()
            terminal.printEasterEggRaw(eggName, endLine)
            terminal.standardInputPrompt()
        }
    }

    printEasterEggRaw(eggName, endLine=true) {
        let displayName = ` ${eggName} `
        let element = this.print(displayName, undefined, {forceElement: true})
        element.onclick = () => {
            if (this.data.easterEggs.has(eggName)) {
                alert("You have already found this one. Enter 'easter-eggs' to see all found ones.")
            } else {
                this.data.addEasterEgg(eggName)
                alert("You found an easter egg! It's added to your basket. Enter 'easter-eggs' to see all found ones.")
            }
        }

        // style egg
        element.classList.add("easter-egg")

        if (endLine) this.addLineBreak()
    }

    printLink(msg, url, color, endLine=true) {
        let element = this.print(msg, color, {forceElement: true, element: "a"})
        element.href = url
        if (endLine) this.printLine()
    }

    async standardInputPrompt() {
        let element = this.print(this.fileSystem.pathStr + " ", undefined, {forceElement: true, addToCache: false})
        element.style.marginLeft = `-${this.charWidth * 3}px`
        this.correctIndicator = this.print("$ ", Color.LIGHT_GREEN, {addToCache: false})
        let text = await this.prompt("", {affectCorrectness: true})
        await this.input(text)
    }

    async input(text, testMode=false) {
        if (!testMode)
            this.log(`Inputted Text: "${text}"`)

        // clear interrupt signal
        this._interruptCallbackQueue = []
        this._interruptSignal = false

        if (this.mobileKeyboard) {
            this.mobileKeyboard.updateLayout(this.mobileKeyboard.Layout.CMD_RUNNING)
        }

        if (TerminalParser.isVariable(text)) {
            let varName = TerminalParser.extractVariableName(text + "=")
            if (this.variableCache[varName] == undefined) {
                this.printError(`Variable '${varName}' is not defined\n`)
            } else {
                let varValue = this.variableCache[varName]
                this.printLine(varValue)
            }
            this.standardInputPrompt()
            return
        }

        let assignmentInfo = TerminalParser.extractAssignment(text)
        if (assignmentInfo) {
            this.variableCache[assignmentInfo.name] = ""
            this.outputCacheVarName = assignmentInfo.name
            text = assignmentInfo.value
            this.outputChannel = OutputChannel.CACHE_AND_USER
        } else {
            this.outputChannel = OutputChannel.USER
        }

        let tokens = TerminalParser.tokenize(text)
        if (tokens.length == 0) {
            this.standardInputPrompt()
            return
        }

        let [commandText, args] = TerminalParser.extractCommandAndArgs(tokens)
        let rawArgs = text.slice(commandText.length)
        if (this.commandExists(commandText)) {
            let command = await this.getCommand(commandText)
            return await command.run(tokens, rawArgs, {callFinishFunc: !testMode, terminalObj: this})
        } else {
            let cmdnotfound = await this.getCommand("cmdnotfound")
            await cmdnotfound.run(["cmdnotfound", commandText, rawArgs], commandText, {
                callFinishFunc: !testMode,
                terminalObj: this,
                processArgs: false
            })
            return false
        }
    }

    get allCommands() {
        return Object.fromEntries(Object.entries(this.commandData).map(([cmd, data]) => {
            return [cmd, data["description"]]
        }))
    }

    commandExists(commandName) {
        return Object.keys(this.allCommands).includes(commandName)
    }

    addCommand(name, callback, info) {
        this.commandCache[name] = new Command(name, callback, info)
    }

    get functions() {
        return Object.entries(this.allCommands).map(d => {
            return {name: d[0], description: d[1]}
        })
    }

    get commandIsExecuting() {
        return this.expectingFinishCommand
    }

    get visibleFunctions() {
        return Object.entries(terminal.commandData)
            .filter(([c, d]) => !d.isSecret)
            .map(([c, d]) => {
                d.name = c
                return d
            })
    }

    get currDirectory() {
        return this.fileSystem.currDirectory
    }

    get lastPrintedChar() {
        return this.parentNode.textContent[this.parentNode.textContent.length - 1]
    }

    get rootDirectory() {
        return this.fileSystem.root
    }

    get prevCommands() {
        return this.data.history
    }

    get widthPx() {
        let computedStyle = getComputedStyle(this.parentNode)
        let elementWidth = this.parentNode.clientWidth
        elementWidth -= parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight)
        return elementWidth
    }

    get charWidth() {
        let firstSpan = this.parentNode.querySelector("span")
        let firstSpanWidth = firstSpan.getBoundingClientRect().width
        let textWidth = firstSpan.textContent.length
        return firstSpanWidth / textWidth
    }

    get approxWidthInChars() {
        return Math.floor(this.widthPx / this.charWidth) - 5
    }

    async _loadScript(url, extraData={}, {
        asyncMode=false
    }={}) {
        if (!asyncMode) {
            this.setLoading(url)
        }

        // make a new iframe to load the script in
        // to prevent the script from accessing the global scope
        // instead, it will access the iframe's global scope
        // in which i place the terminal object
        
        // this way, command scripts each have their own scope
        // and cannot access each other's variables
        // which is good because it prevents command scripts
        // from interfering with each other (name conflicts, etc.)

        let iframe = await new Promise(resolve => {
            let iframeElement = document.createElement("iframe")
            iframeElement.addEventListener("load", () => resolve(iframeElement))
            iframeElement.style.display = "none"
            document.body.appendChild(iframeElement)
        })

        // add variables to iframe namespace
        let iframeDocument = iframe.contentDocument || iframe.contentWindow.document
        iframe.contentWindow.terminal = this
        for (let key in extraData)
            iframe.contentWindow[key] = extraData[key]
        for (let key in UtilityFunctions)
            iframe.contentWindow[key] = UtilityFunctions[key]
        iframe.contentWindow["sleep"] = this.sleep
        iframe.contentWindow["audioContext"] = this.audioContext
        iframe.contentWindow["loadIndex"] = loadIndex

        await new Promise(resolve => {    
            let script = document.createElement("script")
            script.addEventListener("load", resolve)
            script.src = `${this.baseUrl}${url}?${loadIndex}`
            iframeDocument.body.appendChild(script)
        })

        this.log(`Loaded Script: ${url}`)

        if (!asyncMode) {
            this.unsetLoading()
        }

        return iframe.contentWindow
    }

    async loadCommand(name, {force=false}={}) {
        if (this.commandCache[name] && !force)
            return this.commandCache[name]
        let commandWindow = await this._loadScript(`js/commands/${name}.js`)
        this.commandCache[name].windowScope = commandWindow
        for (let terminalInstance of Object.values(ALL_TERMINALS)) {
            terminalInstance.commandCache[name] = this.commandCache[name]
        }
        return this.commandCache[name]
    }

    async getCommand(name) {
        if (!this.commandExists(name))
            throw new Error(`Command not found: ${name}`)
        if (!this.commandCache[name]) {
            return await this.loadCommand(name)
        } else {
            return this.commandCache[name]
        }
    }

    async finishCommand({force=false}={}) {
        if (this.outputChannel === OutputChannel.CACHE_AND_USER) {
            this.outputChannel = OutputChannel.USER
        }

        if ((!this.expectingFinishCommand && !force) || this.currInputElement)
            return
        this.expectingFinishCommand = false
        
        if (this.lastPrintedChar !== "\n")
            this.print("\n")
        this.print("\n")

        this._interruptCallbackQueue = []
        this._interruptSignal = false
        this.tempCommandInputHistory = []

        this.fileSystem.save()
        this.updatePath()

        this.standardInputPrompt()
    }

    getCurrDate() {
        return new Date().toLocaleDateString().replace(/\//g, "-")
    }

    getCurrTime() {
        return new Date().toLocaleTimeString()
    }

    addToLogBuffer(msg, type, time, date, template) {
        this.logBuffer.push({msg, type, time, date, template})
    }

    cleanLogBuffer() {
        while (this.logBuffer.length > 0) {
            let logData = this.logBuffer.shift()
            this.log(logData.msg, logData)
        }
    }

    log(msg, {type="info", time="auto", date="auto", timestamp="auto", template="[TYPE] [TIMESTAMP] MSG"}={}) {
        if (!this.hasInitted) {
            this.addToLogBuffer(msg, type, time, date, template)
            return
        }

        if (time === "auto")
            time = new Date().toLocaleTimeString()
        if (date === "auto")
            date = new Date().toLocaleDateString()
        if (timestamp === "auto")
            timestamp = Date.now() + ""
        let logText = template
            .replace("TIMESTAMP", timestamp)
            .replace("TYPE", type)
            .replace("TIME", time)
            .replace("DATE", date)
            .replace("MSG", msg)


        let lines = terminal.logFile.text.split("\n")
                    .filter(line => line.length > 0)
        while (lines.length > terminal.logFileMaxLines - 1) {
            lines.shift()
        }

        lines.push(logText)
        terminal.logFile.text = lines.join("\n")
    }

    get logFilePath() {
        return "root/" + this.logFileName
    }

    get logFile() {
        if (this.fileExists(this.logFilePath)) {
            return this.getFile(this.logFilePath)
        } else {
            let logFile = new PlainTextFile().setName(this.logFileName)
            this.rootDirectory.addChild(logFile)
            return logFile
        }
    }

    get logFileName() {
        return "latest.log"
    }

    reset() {
        this.data.resetAll()
        localStorage.removeItem("terminal-filesystem")
    }

    makeInputFunc(text) {
        return async () => {
            if (this.expectingFinishCommand) {
                return
            }

            if (this.currInputElement) {
                this.removeCurrInput()
            }

            this.expectingFinishCommand = true
            await this.animatePrint(text, 5)
            this.data.addToHistory(text)
            this.input(text)
        }
    }

    async init({
        runInput=true,
        runStartupCommands=true,
        loadPath=true,
        loadSidePanel=true,
        ignoreMobile=false
    }={}) {
        await this._loadScript(this.commandListURL)
        await this.fileSystem.load()

        if (this.isMobile && !ignoreMobile) {
            await this._loadScript(this.mobileKeyboardURL)
        }

        if (this.isUrlParamSet("404")) {
            let error404 = await this.getCommand("error404")
            error404.run()
        } else {
            if (runStartupCommands) {
                for (let startupCommand of this.data.startupCommands) {
                    await this.input(startupCommand, true)
                }
            }

            if (loadPath) {
                // load path from localstorage
                let filePath = FilePath.from(this.data.path)
                if (this.fileExists(filePath)) {
                    this.fileSystem.currDirectory = this.getFile(filePath)
                } else {
                    this.updatePath()
                }
            }

            if (!ignoreMobile) {
                if (this.isMobile) {
                    this.print("Mobile keyboard active. ")
                    this.printCommand("click to disable", "keyboard off")
                } else if (this.autoIsMobile) {
                    this.print("Mobile keyboard inactive. ")
                    this.printCommand("click to enable", "keyboard on")
                }
            }

            // TODO: make this into terminal.data option
            if (loadSidePanel) {
                this._loadScript(this.sidePanelURL, {}, {asyncMode: true})
            }

            this.expectingFinishCommand = true
            if (runInput) {
                this.finishCommand()
            }
        }

        this.hasInitted = true
        this.cleanLogBuffer()
    }

    async initFrom(otherTerminal) {
        this.commandData = otherTerminal.commandData
        this.fileSystem.loadJSON(otherTerminal.fileSystem.toJSON()) 
        this.commandCache = otherTerminal.commandCache
        this.startTime = otherTerminal.startTime 
        this.hasInitted = true
        this.cleanLogBuffer()
    }

    get autoIsMobile() {
        return /Mobi/i.test(window.navigator.userAgent)
    }

    get isMobile() {
        if (terminal.data.mobile === true)
            return true
        if (terminal.data.mobile === false)
            return false
        return this.autoIsMobile
    }

    async clear(addPrompt=false) {
        let newPromptValue = ""
        if (this.currInputElement)
            newPromptValue = this.currInputElement.value

        this.removeCurrInput()
        this.parentNode.innerHTML = ""

        if (addPrompt) {
            this.standardInputPrompt()
            this.currInputElement.value = newPromptValue
        }
    }

    currFontSizeIndex = 6

    changeTextSize(increment) {
        const options = [3, 5, 7.5, 10, 12.5, 14, 15, 16, 17, 18, 19, 20, 22, 25, 30, 35, 40, 45, 50, 60, 80, 100]
        this.currFontSizeIndex = (this.currFontSizeIndex + increment) % options.length
        while (this.currFontSizeIndex < 0) this.currFontSizeIndex += options.length
        this.parentNode.style.setProperty("--font-size", `${options[this.currFontSizeIndex]}px`)
    }

    enlargeText() {
        this.changeTextSize(1)
    }

    shrinkText() {
        this.changeTextSize(-1)
    }

    _onkeydownShortcut(event) {
        let key = event.key

        let shortcut = this.keyboardShortcuts.find(shortcut => {
            if (shortcut.key.toLowerCase() != key.toLowerCase())
                return false
            if (shortcut.ctrl !== undefined && shortcut.ctrl !== event.ctrlKey)
                return false
            if (shortcut.alt !== undefined && shortcut.alt !== event.altKey)
                return false
            if (shortcut.shift !== undefined && shortcut.shift !== event.shiftKey)
                return false
            return true
        })

        if (shortcut) {
            event.preventDefault()
            shortcut.run(event)
        }
    }

    static makeRandomId(length) {
        let result = ""
        let characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * characters.length))
        }
        return result
    }

    constructor(terminalName="none", {
        parentNode=undefined,
        baseUrl=undefined,
        guiMode=false
    }={}) {
        if (parentNode) {
            this.parentNode = parentNode
        }

        this.guiMode = guiMode
        this.baseUrl = baseUrl || ""

        this.startTime = Date.now()

        this.name = terminalName

        this.sessionId = `${this.getCurrDate()}-${this.getCurrTime()}`
        this.hasInitted = false
        this.logBuffer = []
        this.logFileMaxLines = 100
        
        addEventListener("keydown", this._onkeydownShortcut.bind(this))

        // when the user clicks on the terminal, focus the input element
        this.parentNode.addEventListener("click", () => {
            function getSelectedText() {
                let text = ""
                if (typeof window.getSelection != "undefined") {
                    text = window.getSelection().toString()
                } else if (typeof document.selection != "undefined" && document.selection.type == "Text") {
                    text = document.selection.createRange().text
                }
                return text
            }

            // if the user has selected text, don't focus the input element
            if (this.currInputElement && !getSelectedText())
                this.focusInput()
        })

        // save the keys pressed by the user
        // so that they can be used in the keydown event listener
        // to detect key combinations
        this.pressed = {}

        document.addEventListener("keydown", event => {
            this.pressed[event.key] = true
        })

        document.addEventListener("keyup", event => {
            this.pressed[event.key] = false
        })

        this.body = document.body
        this.document = document
        this.window = window

        this._interruptSignal = false
        this._interruptCallbackQueue = []

        ALL_TERMINALS[terminalName] = this

        if (terminalName === "main") {
            this.log("new terminal initialized", {type: "startup"})
            this.log(`> hostname: ${this.window.location.href}`, {type: "startup"})
            this.log(`> timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`, {type: "startup"})
        }
    }

}

// ------------------- js/load_async.js --------------------
const loadIndex = localStorage.getItem("loadIndex") || 0

let terminal = undefined

async function initalLoadScripts() {
    const loadFile = async (file) => {
        const script = document.createElement("script")
        script.src = `${file}?${loadIndex}`
        document.body.appendChild(script)
        await new Promise(resolve => script.onload = resolve)
    }

    await loadFile("js/terminal.js")

    terminal = new Terminal("main")
    terminal.clear()
    terminal.init()

    // add shortcuts
    terminal.addKeyboardShortcut(new KeyboardShortcut(
        "L", async () => {
            // wait for any pending commands to be interrupted
            // sleep to allow the interrupt to finish and print
            terminal.interrupt()
            await new Promise(resolve => setTimeout(resolve, 100))

            terminal.clear(true)
        },
        {ctrl: true, shift: undefined}
    ))

    terminal.addKeyboardShortcut(new KeyboardShortcut(
        "E", async () => {
            const eggName = "Shortcut Egg"
            terminal.printEasterEgg(eggName)
        },
        {ctrl: true, shift: true, alt: true}
    ))

    terminal.addKeyboardShortcut(new KeyboardShortcut(
        "+", async () => {
            terminal.enlargeText() 
        },
        {ctrl: true, shift: undefined}
    ))

    terminal.addKeyboardShortcut(new KeyboardShortcut(
        "-", async () => {
            terminal.shrinkText()
        },
        {ctrl: true, shift: undefined}
    ))

    // count page visits
    window.addEventListener("load", () => setTimeout(() => fetch("api/count_visit.php"), 0))
}

initalLoadScripts()

document.querySelector("#loading-terminal-container").style.display = "block"

setTimeout(() => {
    if (window.terminal && window.terminal.hasInitted) {
        return
    }

    let loadingContainer = document.querySelector("#loading-terminal-container")

    if (loadingContainer) {
        loadingContainer.style.display = "none"
        document.querySelector("#loading-terminal-failed-container").style.display = "block"
    }

}, 5000)

// ------------------- js/defaultFilesystem.js --------------------
const about_txt_content = `<noel-friedrich>

    \\O_   This is me, Noel Friedrich.
 ,/\\/     I am a student still learning.
   /      I also really love rainy weather.
   \\      And command line interfaces.
   \`      (because i like to feel cool)

</noel-friedrich>`

const contact_txt = `E-Mail: noel.friedrich@outlook.de`

let passwords_json = `{
    "google.com": "FAKE_PASSWORD",
    "github.com": "FAKE_PASSWORD",
    "die-quote.de": "FAKE_PASSWORD",
    "instagram.com": "FAKE_PASSWORD",
    "facebook.com": "FAKE_PASSWORD",
    "steam": "FAKE_PASSWORD"
}`

while (passwords_json.match(/FAKE_PASSWORD/)) {
    passwords_json = passwords_json.replace(/FAKE_PASSWORD/, function() {
        let chars = "zyxwvutsrqponmlkjihgfedcbaABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!?@+-#"
        let tempPw = ""
        let len = Math.random() * 8 + 8
        for (let i = 0; i < len; i++) {
            tempPw += chars[Math.floor(Math.random() * chars.length)]
        }
        return tempPw
    }())
}

terminal.fileSystem.root = new DirectoryFile([
    new PlainTextFile(about_txt_content).setName("about.txt"),
    new DirectoryFile([
        new DirectoryFile([
            new PlainTextFile(passwords_json).setName("passwords.json")
        ]).setName("secret"),
        new PlainTextFile(contact_txt).setName("email.txt"),
    ]).setName("noel"),
    new PlainTextFile("https://github.com/noel-friedrich/").setName("github.url"),
])

// ------------------- js/load-commands.js --------------------
terminal.commandData = {"2048": {"description": "play a game of 2048", "isGame": true}, "4inarow": {"description": "play a game of Connect Four against the computer", "args": {"?d=depth:i:1~100": "The depth of the search tree", "?s=show-debug:b": "Show debug info about board eval"}, "standardVals": {"depth": 4}, "isGame": true}, "alias": {"description": "create a new alias for a given function", "args": {"?alias:s": "name of the new alias", "?*command:s": "name of the command to be aliased", "?s=show:b": "show all aliases", "?r=remove:s": "remove a given alias"}}, "ant-opt": {"description": "interactive solution to the travelling salesman problem using ant colony optimization", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "apc-sim": {"description": "play an animation relating to an apc problem", "args": {"problem:e:can-x-see-q": "problem to animate", "?f=fullscreen:b": "open in fullscreen"}}, "asteroids": {"description": "simulate a bunch of balls jumping around", "args": {"?f=fullscreen:b": "start in fullscreen mode", "?c=chaos:b": "start with chaos mode enabled"}, "isGame": true}, "avoida": {"description": "play a game of avoida", "isGame": true}, "background": {"description": "change the background color of the terminal", "args": ["color"]}, "base64": {"description": "encode/decode a message using base64", "args": {"*message": "the message to encode/decode", "?d=decode:b": "decode the message instead of encoding it", "?c=copy:b": "copy the result to the clipboard"}}, "bc": {"description": "start a bc (basic calculator) session"}, "bezier": {"description": "play with bezier curves"}, "bin": {"description": "convert a number to another base", "args": {"n": "number to convert", "?t=to-base:i:2~36": "base to convert to", "?f=from-base:i:2~36": "base to convert from"}, "standardVals": {"t": 2, "f": 10}}, "binomcdf": {"description": "calculate the binomial cumulative distribution function", "args": {"n:n:1~1000": "the number of trials", "p:n:0~1": "the probability of success", "lower:n:0~1000": "the lower bound", "upper:n:0~1000": "the upper bound"}}, "binompdf": {"description": "calculate binomial distribution value", "args": {"n:n:0~100": "the number of trials", "p:n:0~1": "the probability of success", "k:n:0~100": "the number of successes"}}, "blocks": {"description": "3d raycasting test", "args": {"?fov:i:1~720": "Field of view in degrees", "?res=resolution:i:1~1000": "Resolution (width) in Pixels", "?x=roomX:i:5~100": "Room size in x direction", "?y=roomY:i:5~100": "Room size in y direction", "?z=roomZ:i:5~100": "Room size in z direction", "?v=viewDistance:i:1~9999": "View distance in blocks"}, "defaultValues": {"fov": 90, "resolution": 90, "roomX": 30, "roomY": 10, "roomZ": 10, "viewDistance": 13}}, "brainfuck": {"description": "parse given brainfuck code", "args": ["*code"]}, "cal": {"description": "print a calendar", "args": {"?month": "the month to print", "?year": "the year to print"}}, "cardoid": {"description": "start a cardoid generator", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "cat": {"description": "print file content", "args": {"file:f": "file to display the content of"}}, "cd": {"helpVisible": true, "args": {"directory:f": "the directory relative to your current path"}, "description": "change current directory"}, "ceasar": {"description": "shift the letters of a text", "args": {"text": "the text to shift", "?s=shift:i:-26~26": "the shift value"}, "standardVals": {"shift": 1}}, "changes": {"description": "see latest changes to the terminal", "args": {"?b=branch:s": "git branch to view changes of", "?l=limit:i:1~9999999": "number of changes to show"}, "defaultValues": {"branch": "main", "limit": 10}, "isSecret": true}, "cheese": {"description": "take a foto with your webcam"}, "chess": {"description": "play a game of chess against the computer", "isGame": true}, "clear": {"description": "clear the terminal"}, "clock": {"description": "display a clock", "args": {"?m=millis:b": "display milliseconds"}}, "cmatrix": {"description": "show the matrix", "args": {"?nf=not-fullscreen:b": "make the window fullscreen"}}, "cmdnotfound": {"description": "display that a command was not found", "rawArgMode": true, "isSecret": true}, "code": {"description": "show the source code of a command", "args": {"?c=command:c": "the command to show the source code of", "?s=string:s": "print a highlighted string"}}, "collatz": {"description": "Calculate the Collatz Sequence (3x+1) for a given Number", "args": {"n:bn": "the starting number of the sequence", "?v=visualize:b": "visualize the numbers as a graph", "?l=log-scale:b": "use a logarithmic scale to graph the numbers"}}, "color-test": {"description": "test the color capabilities of the terminal", "args": {"?size:i:1~999": "the size of the test image"}, "defaultValues": {"size": 60}}, "compliment": {"description": "get info about yourself"}, "config": {"description": "manage the terminal configuration", "args": {"?e=edit:e:foreground|background|font|color1|color2|storage|history": "edit a given property"}}, "construct": {"description": "animate the construction of a given number (using ruler and compass only)", "args": {"number:s": "the number to construct (form: 'sqrt(20)+3')", "?f=fullscreen:b": "enable fullscreen mode", "?fps:i:1~99999": "fps of animation"}, "defaultValues": {"fps": 30}, "isSecret": true}, "contact": {"description": "Open contact form"}, "copy": {"description": "copy the file content to the clipboard", "rawArgMode": true}, "coville": {"description": "interactive virus simulation (in german)", "isSecret": true, "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "cowsay": {"description": "let the cow say something", "args": ["*message"]}, "cowthink": {"description": "let the cow say something", "args": ["*thought"]}, "cp": {"description": "copy a file", "args": {"file:f": "file to copy", "?d=directory:f": "directory to copy to", "?n=name:s": "new filename"}, "defaultValues": {"directory": "."}}, "crossp": {"description": "calculate the cross product of 2 3d vectors", "args": {"x1:n": "the x component of the first vector", "y1:n": "the y component of the first vector", "z1:n": "the z component of the first vector", "x2:n": "the x component of the second vector", "y2:n": "the y component of the second vector", "z2:n": "the z component of the second vector"}}, "curl": {"description": "download a file from the internet", "args": {"url:s": "the url to download the file from"}, "disableEqualsArgNotation": true}, "cw": {"description": "get the calendar week of a date", "args": {"?date": "the date to get the calendar week of"}, "standardVals": {"date": null}}, "debug": {"description": "activate the debug mode to enable untested new features", "isSecret": true}, "donut": {"description": "display a spinning donut"}, "download": {"description": "download a file", "args": {"file:f": "the file to download"}}, "draw": {"description": "start simple drawing app"}, "du": {"description": "display storage of current directory", "args": {"?folder:f": "folder to display storage of"}}, "easter-eggs": {"description": "open easter egg hunt", "args": {"?reset:b": "reset easter egg hunt"}}, "echo": {"description": "print a line of text", "rawArgMode": true}, "echonum": {"description": "echo a given number", "args": {"number:n": "number to echo"}, "isSecret": true}, "edit": {"description": "edit a file", "args": {"file:f": "file to edit"}}, "enigma": {"description": "Simulate an Enigma machine", "args": {"?c=config:b": "Enables config mode", "?t=translate:b": "Enables translation mode", "?r=reset:b": "Resets the machine", "?s=show:b": "Shows the current settings"}}, "error404": {"description": "Display a 404 error", "rawArgMode": true}, "eval": {"description": "evaluate javascript code", "rawArgMode": true}, "exit": {"description": "exit the terminal"}, "f-optimize": {"args": {"?*names": "names to optimize", "?s=seconds:i": "how long to optimize for (seconds)"}, "defaultValues": {"seconds": 99999999}, "description": "finds a good nonce value for the friendship score generator"}, "f": {"description": "calculate friendship score with a friend", "args": {"*name": "name of friend"}}, "factor": {"description": "print the prime factors of a number", "args": {"?n:bn": "number to factorize"}, "standardVals": {"n": null}}, "fakechat": {"description": "fake a whatsapp chat conversation", "args": {"?f=fast:b": "skip typing animations [fast mode]", "?o=offset:n:-100~100": "offset the chat by a procentage of the screen height", "?s=scale:n:0.1~5": "scale the chat by a factor", "?x=width:n:100~10000": "set the width of the screen in pixels", "?y=height:n:100~10000": "set the height of the screen in pixels"}, "standardVals": {"o": 0, "s": 1, "x": 720, "y": 1560}}, "fibo": {"description": "Prints the Fibonacci sequence", "args": {"?n:i:1~100": "The number of elements to print", "?p=phi:b": "calculate the golden ratio using the last two elements"}, "defaultValues": {"n": 10}}, "fizzbuzz": {"description": "print the fizzbuzz sequence", "args": {"?max:n:1~100000": "the maximum number to print"}, "standardVals": {"max": 15}}, "flaci-to-turing": {"description": "Converts a flaci.com JSON File of a turing machine to a turing machine file", "args": {"file": "file to convert", "?s=save:b": "save the converted file"}, "isSecret": true}, "flappy": {"description": "play a game of flappy turtlo", "args": {"?f=fullscreen:b": "fullscreen", "?s=silent:b": "silent mode"}, "isGame": true}, "font": {"description": "change the font of the terminal", "args": ["*font"]}, "foreground": {"description": "change the foreground color of the terminal", "args": {"color": "the color to change the foreground to"}}, "fraction": {"description": "find a fraction from a decimal number", "args": {"n=number:n": "number (decimal)", "?d=max-denominator:i:1~999999999": "maximum denominator"}, "defaultValues": {"d": 1000}}, "freq": {"description": "play a frequency for an amount of time", "args": {"f=frequency:n:0~30000": "the frequency to play", "?t=time:n:0~9999": "time in seconds to play frequency"}, "defaultValues": {"time": 0.5}}, "games": {"description": "shows the game menu"}, "get": {"description": "get a value from the server", "args": {"key": "the key to get the value of"}, "disableEqualsArgNotation": true}, "greed": {"description": "play a game of greed", "isGame": true, "args": {"?b": "play the bigger version"}}, "grep": {"description": "search for a pattern in a file", "args": {"pattern": "the pattern to search for", "file": "the file to search in", "?r=recurse:b": "search recursively", "?i=ignore-case:b": "ignore case", "?v=invert-match:b": "invert match", "?x=match-whole-lines:b": "match whole lines"}}, "gui": {"description": "open the GUI page for a given command", "args": {"command:c": "a terminal command"}}, "hangman": {"description": "play a game of hangman", "isGame": true}, "head": {"description": "display the first lines of a file", "args": ["file", "?l:i:1~1000"], "standardVals": {"l": 10}}, "helloworld": {"description": "display the hello-world text", "rawArgMode": true}, "help": {"description": "shows this help menu"}, "hi": {"description": "say hello to the terminal"}, "highscore-admin": {"description": "Highscore Admin Management", "isSecret": true, "args": {"?l=list:b": "List all unconfirmed highscores", "?t=tinder:b": "Play Tinder Swiping with highscores", "?d=delete:b": "Delete password from local storage"}}, "highscore-remove": {"description": "Remove a highscore", "isSecret": true, "args": {"game": "the game to remove the highscore from", "?n": "only show highscores with this name", "?l:n:1~10000": "limit the number of highscores to show", "?uid": "the uid of the highscore to remove"}, "standardVals": {"n": null, "l": Infinity}}, "highscores": {"description": "Show global highscores for a game", "args": {"game:s": "the game to show the highscores for", "?n:s": "only show highscores with this name", "?l:i:1~10000": "limit the number of highscores to show", "?show-all:b": "show all highscores, not just the top ones"}, "standardVals": {"n": null, "l": 10}}, "history": {"description": "print the command history", "args": {"?l=limit:n:1~100000": "the maximum number of commands to print", "?show-full:b": "show the full command instead of the shortened version"}, "standardVals": {"l": 1000}}, "hr-draw": {"description": "turn drawings into bitmaps", "args": {"?x=width:i:1~100": "width (pixels)", "?y=height:i:1~100": "height (pixels)"}, "defaultValues": {"width": 5, "height": 5}, "isSecret": true}, "hr": {"description": "create a hr code", "args": {"message:s": "the message to encode", "?f=fontmode:s": "the font mode to use", "?fill:b": "fill empty spaces with random data"}, "defaultValues": {"fontmode": "5x5"}}, "href": {"description": "open a link in another tab", "args": {"?u=url:s": "url to open", "?f=file:s": "file to open"}}, "hyp-lines": {"description": "spawn a simulation of the hyperbolic disk and half-plane model", "args": {"?w=width:i:22~100": "width of each screen in characters", "?h=height:i:10~100": "height of each screen in characters"}, "defaultValues": {"width": 50, "height": 40}}, "image-crop": {"description": "start image cropper program"}, "img2ascii": {"description": "Convert an image to ASCII art", "args": {"?w=width:i:1~500": "the width of the output image in characters"}, "defaultValues": {"width": 60}}, "img2pdf": {"description": "convert image files to pdf", "args": {"?f=filename:s": "filename for the pdf", "?p=padding:i:0~50": "padding of pdf (in px)", "?r=rotate:b": "rotate the images to maximise space"}, "defaultValues": {"filename": null, "padding": 5}}, "imgwarp": {"description": "warp an image using a geometric step-distance function", "args": {"f=function:s": "step distance function"}, "isSecret": true}, "isprime": {"description": "Check if a number is prime", "args": {"n:i": "The number to check", "?f=find-next:b": "if n is not prime, find the next one"}}, "joke": {"description": "tell a joke"}, "kaprekar": {"description": "display the kaprekar steps of a number", "args": {"n:n:1~999999999": "the number to display the kaprekar steps of"}}, "keyboard": {"description": "Toggle mobile mode", "args": {"?m=mode:s": "status | on | off | auto"}, "defaultValues": {"m": "status"}}, "kill": {"description": "kill a process", "args": {"process": "the process to kill"}}, "labyrinth": {"description": "play a game of labyrinth", "isGame": true, "args": {"?fps:n:1~60": "the frames per second of the game"}, "standardVals": {"fps": 30}}, "letters": {"description": "prints the given text in ascii art", "args": {"*text": "the text to print"}, "example": "letters hello world"}, "live-quiz": {"description": "a simple quiz game that uses your camera as input for your answer", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "live-rocket": {"description": "a simple avoid game that you steer using camera input", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "logistic-map": {"description": "draw the logistic map", "args": {"?min:n:-2~4": "minimum R value", "?max:n:-2~4": "maximum R value", "?w:n:10~200": "width of display", "?h:n:5~100": "height of display"}, "standardVals": {"min": 0, "max": 4, "w": 80, "h": 20}}, "longjump": {"description": "Play a game of longjump", "isGame": true, "args": {"?f=fullscreen:b": "Play in fullscreen"}}, "lorem": {"description": "generate lorem ipsum text", "args": {"?l=length:i": "number of words to generate", "?c=copy:b": "copy to clipboard"}, "defaultValues": {"l": 100}}, "ls": {"helpVisible": true, "description": "list all files of current directory", "args": {"?folder:f": "folder to list", "?r=recursive:b": "list recursively"}, "standardVals": {"folder": ""}}, "lscmds": {"description": "list all available commands", "helpVisible": true, "args": {"?m:b": "format output as markdown table"}}, "lscpu": {"description": "get some helpful info about your cpu"}, "lunar-lander": {"description": "play a classic game of moon-lander", "args": {"?particles:n:1~1000": "number of particles to generate", "?f=fullscreen:b": "enable fullscreen application"}, "standardVals": {"particles": 10}, "isGame": true}, "man": {"description": "show the manual page for a command", "args": {"command:c": "the command to show the manual page for"}, "helpVisible": true}, "mandelbrot": {"description": "draws the mandelbrot set", "args": {"?x:i:10~1000": "width of the plot", "?y:i:10~1000": "height of the plot"}}, "matdet": {"description": "find the determinant of a matrix", "args": {"?A:sm": "square matrix"}}, "mateig": {"description": "find the eigenvalues and eigenspaces of a given matrix", "args": {"?A:sm": "square matrix"}, "isSecret": true}, "matinv": {"description": "find the inverse of a matrix", "args": {"?A:sm": "matrix to invert"}}, "matmin": {"description": "find the matrix of minors of a given matrix", "args": {"?A:sm": "matrix to find minors of"}}, "matmul": {"description": "multiply two matrices with each other", "args": {"?A:m": "matrix A", "?B:m": "matrix B"}}, "matred": {"description": "reduce a given matrix to reduced row echelon form", "args": {"?A:m": "matrix to reduce"}}, "matvisualize": {"description": "visualize a given 2x2 matrix transformation", "args": {"?m=matrix:sm": "2x2 matrix to left-multiply by", "?x:n": "x coordinate of center", "?y:n": "y coordinate of center", "?z=zoom:n:0.01~99999": "zoom level"}, "defaultValues": {"x": 0, "y": 0, "zoom": 5}}, "mill2player": {"description": "play a game of mill with a friend locally", "isGame": true}, "minesweeper": {"description": "play a game of minesweeper", "args": {"?x=width:i:5~100": "width of the board", "?y=height:i:5~100": "height of the board", "?b=bombs:i:10~90": "percentage of bombs"}, "defaultValues": {"width": 10, "height": 10, "bombs": 20}, "isGame": true}, "minigolf": {"description": "play a game of minigolf", "args": {"?l=level:i": "open a specific level", "?e=edit:b": "open map editor", "?f=file:s": "open a specific file", "?fullscreen:b": "activate fullscreen mode"}, "defaultValues": {"level": 1}, "isGame": true}, "mkdir": {"description": "create a new directory", "args": {"name:s": "name for your shiny new directory"}}, "morse": {"description": "translate latin to morse or morse to latin", "args": {"*text": "text to translate"}}, "mv": {"description": "move a file", "args": {"file:f": "file to move", "d=directory:f": "directory to move to", "?n=name:s": "new filename"}}, "name-gen": {"description": "start a name generator", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "name": {"description": "set a default name for the highscore system to use", "args": {"method": "set | get | reset", "?newname": "the new name"}}, "ncr": {"description": "calculate binomial distribution value", "args": {"n:n:0~100": "the number of trials", "k:n:0~100": "the number of successes"}}, "neural-car": {"description": "start a neural car simulation", "args": {"?cars:i:1~9999": "number of cars to simulate", "?edit:b": "activate the wall editor"}, "defaultValues": {"cars": 100}}, "neural-rocket": {"description": "trains neural networks to fly rockets", "args": {"?population:i:10~99999": "number of rockets in the population"}, "defaultValues": {"population": 100}, "isSecret": true}, "np": {"description": "start a noelpy interpreter for calculations", "isSecret": false}, "nsolve": {"description": "solve an equation using the newton-raphson method", "args": {"*e=equation:s": "the equation to solve", "?s=startn:n": "Starting number", "?i=iterations:i:1~999999": "number of iterations to perform", "?l=list:b": "list all intermediate values"}, "defaultValues": {"startn": 0.71, "iterations": 1000}}, "number-guess": {"description": "guess a random number", "isGame": true}, "old-edit": {"description": "edit a file of the current directory (old version of editor)", "args": {"?file:f": "the file to open"}, "isSecret": true}, "panik": {"description": "[german command] m\u00e4\u00dfige hilfe bei einer panikattacke", "isSecret": true}, "particle": {"description": "start a particle simulation", "args": {"?n:i:1000~10000000": "number of particles"}, "standardVals": {"n": 100000}, "isSecret": true}, "pascal": {"description": "print a pascal triangle", "args": {"?depth:n:1~100": "the depth of the triangle", "?f:b": "only show the final row"}, "standardVals": {"depth": 10}}, "password": {"description": "Generate a random password", "args": {"?l=length:i:1~9999": "The length of the password", "?c=chars:s": "The characters to use in the password", "?norepeat:b": "If present, the password will not repeat characters", "?nocopy:b": "Do not copy the password to the clipboard", "?d=diverse:b": "Use at least one special character, number, and uppercase letter"}, "standardVals": {"l": 20, "c": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@%&!?.,;:[]{}()_-+=*"}}, "pendulum": {"description": "start a pendulum wave simulation", "args": {"?n:i:1~10000": "number of pendulums", "?o:n:0~1": "offset of pendulums", "?f=fullscreen:b": "start in fullscreen mode"}, "standardVals": {"n": 20, "o": 0.025}}, "perilious-path": {"description": "play perilous path", "isGame": true, "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "physics": {"description": "start a physics simulation", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "pi-blocks": {"description": "simulate the bouncy blocks from 3b1b", "args": {"f=factor:i": "the factor of the two blocks", "?s=speed:n:0~10": "the speed factor"}, "defaultValues": {"speed": 1}}, "pi": {"description": "calculate pi to the n-th digit", "args": {"?n:i": "the number of digits", "?w=unwrap:b": "don't split the digits into lines.", "?c=copy:b": "copy the digits to the clipboard", "?y=yes:b": "ignore any computation warnings"}, "standardVals": {"n": 100}}, "piano": {"description": "play a piano with your keyboard"}, "plane": {"description": "play the plane game", "args": {"?f=fullscreen:b": "open in fullscreen mode"}, "isGame": true}, "plot": {"description": "plot a mathematical function within bounds", "args": {"equation": "the equation to plot", "?xmin:n:-1000~1000": "the minimum x value", "?xmax:n:-1000~1000": "the maximum x value", "?ymin:n:-1000~1000": "the minimum y value", "?ymax:n:-1000~1000": "the maximum y value", "?playtime:i:0~10000": "the time to play the sound for in milliseconds"}, "standardVals": {"xmin": -3, "xmax": 3.1, "ymin": -3, "ymax": 3.1, "playtime": 2500}}, "plotter": {"description": "plot mathematical functions", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "polyrythm": {"description": "creates a polyrythm", "args": {"*numbers": "numbers (e.g. \"3 4 5\")", "?t=time:n:10~99999": "time in miliseconds for full rotation"}, "defaultValues": {"time": 4000}}, "pong": {"description": "play a game of pong against the computer", "isGame": true}, "primes": {"description": "generate mersenne primes"}, "pull": {"description": "pull a file from the server", "args": {"file": "file to pull"}}, "push": {"description": "push a file to the server", "args": {"file:f": "file to push"}}, "pv": {"description": "print a message with a typing animation", "args": ["*message"]}, "pwd": {"description": "print the current working directory"}, "python": {"description": "run a script or open a python shell", "args": {"?f=file:f": "the script to run", "?c=code:s": "the code to run"}, "disableEqualsArgNotation": true}, "qr": {"description": "generate a qr code", "args": {"*text": "the text to encode"}}, "rate": {"description": "rate a programming language", "args": ["language"]}, "raycasting": {"description": "play with raycasting", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "reboot": {"description": "reboot the website"}, "reload": {"description": "Reloads the terminal"}, "rename": {"description": "rename a file or folder", "args": {"file:f": "the file or folder to rename", "name:s": "the new name of the file or folder"}}, "reset": {"description": "reset the terminal", "args": {"?n=now:b": "reset now"}}, "reverse": {"description": "reverse a message", "args": {"*message": "the message to reverse", "?c": "copy the reversed message to the clipboard"}}, "rm": {"description": "remove a file", "args": {"file:f": "file to remove"}}, "rndm": {"description": "generate a random number based on the current time", "args": {"?min:n:0~100000": "minimum value (inclusive)", "?max:n:0~100000": "maximum value (inclusive)", "?t=time:b": "use a time based random number generator", "?f=float:b": "generate a float instead of an integer"}, "standardVals": {"min": 1, "max": 100}}, "say": {"author": "Colin Chadwick", "description": "Say something", "args": {"*text:s": "The text to say", "?pitch:n:0~2": "The pitch of the voice", "?language:s": "The language of the voice"}, "defaultValues": {"pitch": 1, "language": "en-US"}}, "sc": {"description": "manage the startup commands", "args": {"?mode": "'add', 'remove', 'reset' or 'list'", "?command": "the command to add or remove (or index)"}, "defaultValues": {"mode": "list"}}, "scarpet": {"description": "draws the Sierpinski carpet using the chaos game", "args": {"?s=speed:i:1~99999": "the speed of dots placed. The higher the faster.", "?size:i:10~1000": "size of output canvas in characters"}, "defaultValues": {"speed": 30, "size": 50}}, "search": {"description": "search something via google.com", "args": {"*query": "the search query", "?b=baseUrl": "the base search-engine url"}, "standardVals": {"b": "https://www.google.com/search?q="}}, "session": {"description": "manage a filesystem session", "args": {"action:e:begin|reset|save|load|end": "<enum>"}}, "set": {"description": "set a value on the server", "args": {"key": "the key to set the value of", "value": "the value to set"}, "disableEqualsArgNotation": true}, "sha256": {"description": "calculate the SHA-256 hash of a message", "args": {"*text:s": "ascii text to calculate hash of"}}, "shi": {"description": "calculate your SHI (stability height index)", "args": {"s=shoe-size:n:1~99999": "shoe size (european)", "l=height:n:1~999999": "body height in centimeters"}}, "shoot": {"description": "Play a game of Shoot against another player locally", "isGame": true, "args": {"?l=lives:i:1~100": "The number of lives each player has", "?s=shoot-delay:i:0~1000": "The number of frames between each shot"}, "defaultValues": {"l": 3, "s": 20}}, "shutdown": {"description": "shutdown the terminal"}, "simulate": {"description": "Run a simulation. Doesn't work well on phones", "args": {"s=simulation:e:2-masses-1-spring|3-masses-3-springs|planets-gravity|1d-3-masses-2-springs|2-body-problem|3-body-problem|4-body-problem|5-body-problem|6-body-problem|7-body-problem|8-body-problem|circle-gravity": "simulation to run", "?f=fullscreen:b": "run application in fullscreen", "?g=gravity:n:0~99999999": "initial gravity constant in gravity based simulations", "?s=skip-ticks:i": "ticks to simulate before rendering", "?h=start-being-halted:b": "simulation will start being stopped"}}, "sl": {"description": "Steam Locomotive", "args": {"?f=F:b": "Make it fly"}}, "sleep": {"description": "sleep for a number of seconds", "args": ["seconds:n:0~1000000"]}, "slime": {"description": "Start a slime simulation"}, "snake": {"description": "play a game of snake", "args": {"?s:n:1~10": "speed level of snake moving"}, "standardVals": {"s": 2}, "isGame": true}, "sodoku": {"description": "Solve or generate a sodoku puzzle", "args": {"?mode:e:play|solve": "the mode to run in (play, solve)", "?fen:s": "a FEN string to load", "?give-fen:b": "output the FEN string for the inputted puzzle"}, "isGame": true}, "solve": {"description": "solve a mathematical equation for x", "args": {"*equation": "the equation to solve", "?i:n:1~5": "the number of iteration-steps to perform", "?m:n:1~100000": "the maximum number of total iterations to perform", "?l:n": "the lower bound of the search interval", "?u:n": "the upper bound of the search interval"}, "standardVals": {"i": 4, "m": 100000, "l": -100, "u": 100}, "disableEqualsArgNotation": true}, "sorting": {"description": "display a sorting algorithm", "args": {"?algorithm": "the algorithm to display", "?n:i:10~1000": "the number of elements to sort", "?speed:n:0~100": "the speed of the sorting algorithm", "?s:b": "silent mode (deactivate sound)"}, "standardVals": {"algorithm": null, "n": 20, "speed": 1}}, "sounds": {"description": "make sounds", "args": {"*text:s": "text to speak", "?i=interval:i:1~999999": "interval in ms between letters", "?r=random:b": "make random", "?l=length:i:1~99999": "length of random notes", "?a=alphabet:s": "alphabet of random letters"}, "defaultValues": {"text": "", "interval": 500, "length": 10, "alphabet": " abcdefghijklmnopqrstuvwxyz.,\n"}}, "spion": {"description": "Spiel Spiel Manager", "args": {"?a=add:b": "add a new place", "?l=list:s": "list a given places roles"}, "isSecret": true}, "stacker": {"description": "play a stacker game", "isGame": true}, "stat": {"description": "show a statistic of a given data set", "args": {"?*nums:s": "the numbers to show the statistic of", "?f=function:s": "the function to plot", "?min:n": "the minimum value of the function", "?max:n": "the maximum value of the function", "?width:n:1~9999": "the width of the canvas", "?height:n:1~9999": "the height of the canvas", "?x=x-name:s": "the name of the x axis", "?y=y-name:s": "the name of the y axis", "?p=padding:n:0~9999": "the padding of the canvas", "?color=foreground:s": "the color of plot", "?axis-color:s": "the color of the axis", "?a=animateMs": "animate the plot", "?background": "the background color of the canvas", "?l=length:i:2~99999": "the length of a data set", "?linewidth:n:1~999": "the width of the line in pixels", "?nopoints:b": "disable the points being displayed"}, "defaultValues": {"nums": null, "width": 640, "height": 400, "x": null, "y": null, "min": -10, "max": 10, "padding": 20, "axis-color": null, "color": null, "animateMs": 500, "background": null, "length": 100, "linewidth": 2}}, "style": {"description": "change the style of the terminal", "args": ["?preset"], "standardVals": {"preset": null}}, "sudo": {"description": "try to use sudo", "args": ["**"]}, "terminal": {"description": "a terminal inside a terminal", "args": {"?f=fullscreen:b": "Open in fullscreen mode"}}, "terml": {"description": "run a .terml file", "args": {"file": "the file to run"}}, "tetris": {"description": "play a classic game of tetris", "isGame": true}, "tictactoe": {"description": "play a game of tic tac toe against the computer.", "args": {"?d=difficulty": "play against an unbeatable computer."}, "standardVals": {"d": "impossible"}, "isGame": true}, "time": {"description": "Shows the current time.", "args": {"?no-hours:b": "Hide hours.", "?no-minutes:b": "Hide minutes.", "?no-seconds:b": "Hide seconds.", "?m=show-milli:b": "Show milliseconds.", "?f=size:n:0.1~99": "Font size in em.", "?s=start:b": "Start a stopwatch."}, "defaultValues": {"size": 3}}, "timer": {"description": "set a timer", "rawArgMode": true}, "todo": {"description": "show and manage a todo list", "args": {"n=name:s": "name of the the todo list", "?u=uncompleted-only:b": "only show the uncompleted todos", "?a=add-item:b": "add an item to the todo list", "?r=rm-item:b": "remove an item from the todo list", "?e=edit-item:b": "edit an item of the todo list", "?rm-completed:b": "remove all completed todos from the todo list"}}, "touch": {"description": "create a file in the current directory", "args": {"filename:s": "the name of the file"}}, "turing": {"description": "run a turing machine file", "args": {"file:f": "file to run", "?t=startTape:s": "starting tape content", "?s=sleep:i:0~10000": "sleep time between steps (in ms)", "?d=startingState:s": "starting state", "?m=maxSteps:i:0~9999999999": "maximum number of steps to run", "?p=turboTapeSize:i:0~9999999999": "size of turing machine tape", "?turbo:b": "run as fast as possible"}, "standardVals": {"startTape": "", "sleep": 100, "startingState": "0", "maxSteps": 100000, "turboTapeSize": 10000}}, "turtlo": {"description": "spawn turtlo", "args": {"?size:i:1~3": "size of turtlo", "?silent:b": "don't print anything"}, "defaultValues": {"size": 1}}, "type-test": {"description": "test your typing speed", "isGame": true}, "uname": {"description": "print the operating system name"}, "unit": {"description": "convert numbers between units", "args": {"v=value:n": "numeric value of unit", "s=start-unit:s": "starting unit", "r=result-unit:s": "resulting unit", "?l=list-units:b": "list all known units"}}, "upload": {"description": "upload a file from your computer", "args": {"?f=filename:s": "name of your shiny new uploaded file"}}, "vigenere": {"description": "encrypt/decrypt a message using the vigenere cipher", "args": {"message": "the message to encrypt/decrypt", "key": "the key to use", "?d=decrypt:b": "decrypt the message instead of encrypting it", "?c=copy:b": "copy the result to the clipboard"}}, "visits": {"description": "Shows the number of page visits"}, "voronoi": {"description": "create voronoi diagrams interactively", "args": {"?n=num-points:i:0~100": "number of random initial points", "?r=random-move:b": "make points wander randomly", "?f=fullscreen:b": "enable fullscreen mode"}, "defaultValues": {"n": 8}}, "w": {"description": "print the current time elapsed"}, "water": {"description": "compute solutions to the longest water problem", "isSecret": true}, "watti": {"description": "manage the walk to trinity database", "isSecret": true, "args": {"action:e:list|add": "<enum>"}}, "wave": {"description": "play with a wave"}, "wc": {"description": "display word and line count of file", "args": {"?f=file:f": "file to open", "?s": "string to count instead of file"}}, "weather": {"description": "Get the current weather", "author": "Colin Chadwick"}, "whatday": {"description": "get the weekday of a date", "args": ["DD.MM.YYYY"]}, "whatis": {"description": "display a short description of a command", "args": ["command"]}, "whoami": {"description": "get client info"}, "wurzle-admin": {"description": "manage wurzles (recmaths.ch/wurzle)", "args": {"action:e:show|set|delete": "<enum>", "?d=date:s": "date to set or delete", "?t=term:s": "term to set", "?a=author:s": "author of wurzle", "?password:s": "admin password required to see stats"}, "defaultValues": {"author": "noel"}, "isSecret": true}, "wurzle-stats": {"description": "show usage stats about wurzle (recmaths.ch/wurzle)", "args": {"?d=date:s": "date to see the stats of", "?password": "admin password required to see stats"}, "isSecret": true}, "yes": {"description": "print a message repeatedly", "args": {"?message": "the message to print", "?s:b": "slow mode"}, "standardVals": {"message": "y"}}, "zip": {"description": "zip a file"}}

// ------------------- js/commands/2048.js --------------------
terminal.addCommand("2048", async function(args) {
    await terminal.modules.import("game", window)

    let cells = [
       [0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0],
       [0, 0, 0, 0]
   ]

   function addRandomCell(tries=0) {
       let x = Math.floor(Math.random() * 4)
       let y = Math.floor(Math.random() * 4)
       if (cells[y][x] == 0) {
           cells[y][x] = 2
       } else if (tries < 1000) {
           // probability of missing in 1000 tries is ~ 9 * 10^(-29)
           // and thus negligible
           addRandomCell(tries + 1)
       } else {
           gameRunning = false
       }
   }

   addRandomCell()
   addRandomCell()

   const cellColors = {
       2: "#6198f3",
       4: "lightgreen",
       8: "yellow",
       16: "orange",
       32: "red",
       64: "purple",
       128: "#f18585",
       256: "cyan",
       512: "lime",
       1024: "magenta",
       2048: "teal"
   }

   let elements = []
   function makeElements() {
       terminal.printLine("  +--------+--------+--------+--------+")
       for (let y = 0; y < 4; y++) {
           terminal.printLine("  |        |        |        |        |")

           let line = []
           for (let x = 0; x < 4; x++) {
               terminal.print("  |  ")
               line.push(terminal.print("    ", undefined, {forceElement: true}))
           }
           elements.push(line)

           terminal.printLine("  |")
           terminal.printLine("  |        |        |        |        |")
           terminal.printLine("  +--------+--------+--------+--------+")
       }
   }
   makeElements()

   function draw() {
       for (let y = 0; y < 4; y++) {
           for (let x = 0; x < 4; x++) {
               let cell = cells[y][x]
               if (cell == 0) {
                   elements[y][x].textContent = "    "
               } else {
                   let text = stringPad(cell, 4)
                   elements[y][x].textContent = text
               }
               elements[y][x].style.color = cellColors[cell] || "white"
           }
       }
       scoreElement.textContent = score
   }

   function cellsCopy() {
       let copy = []
       for (let y = 0; y < 4; y++) {
           let line = []
           for (let x = 0; x < 4; x++) {
               line.push(cells[y][x])
           }
           copy.push(line)
       }
       return copy
    }

    let score = 0

    function shift(d, tempCells) {
        let movedCount = 0
        let countScore = tempCells == undefined
        tempCells ??= cells
        for (let i = 0; i < 4; i++) {
            for (let x = 0; x < 4; x++) {
                for (let y = 0; y < 4; y++) {
                    let newX = x + d[0]
                    let newY = y + d[1]
                    if (Math.max(newX, newY) > 3 || Math.min(newX, newY) < 0)
                        continue
                    if (tempCells[newY][newX] == 0) {
                        tempCells[newY][newX] = tempCells[y][x]
                        tempCells[y][x] = 0
                        movedCount++
                    }
                    if (tempCells[newY][newX] == tempCells[y][x]) {
                        tempCells[newY][newX] *= 2
                        tempCells[y][x] = 0
                        movedCount++
                        if (countScore)
                            score += tempCells[newY][newX]
                    }
                }
            }
        }
        return movedCount
    }

    function checkPossible() {
        let movedCount = 0
        movedCount += shift([1, 0], cellsCopy())
        movedCount += shift([-1, 0], cellsCopy())
        movedCount += shift([0, 1], cellsCopy())
        movedCount += shift([0, -1], cellsCopy())
        return movedCount > 0
    }

    function checkWin() {
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                if (cells[y][x] == 2048) {
                    return true
                }
            }
        }
        return false
    }

    let gameRunning = true

    function keydown(event) {

        if (event.repeat) return
        if (gameRunning == false) return
        let combinedCount = 0
        if (event.key == "ArrowUp") {
            combinedCount += shift([0, -1])
            event.preventDefault()
        } else if (event.key == "ArrowDown") {
            combinedCount += shift([0, 1])
            event.preventDefault()
        } else if (event.key == "ArrowLeft") {
            combinedCount += shift([-1, 0])
            event.preventDefault()
        } else if (event.key == "ArrowRight") {
            combinedCount += shift([1, 0])
            event.preventDefault()
        } else if (event.key == "c" && event.ctrlKey) {
            gameRunning = false
            removeEventListener("keydown", listener)
            return
        }
        if (combinedCount > 0) {
            addRandomCell()
        }
        draw()
    }

    let listener = addEventListener("keydown", keydown)

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout(
            terminal.mobileKeyboard.Layout.ARROWS
        )
        terminal.mobileKeyboard.oninput = keydown
    }

    terminal.scroll()
    terminal.printLine("  Use the arrow keys to move the tiles.")
    terminal.print("  Your Score: ")
    let scoreElement = terminal.print("0", Color.COLOR_2)
    terminal.addLineBreak()

    while (gameRunning) {
        await sleep(100)
        if (!checkPossible()) {
            gameRunning = false
        }
    }

    removeEventListener("keydown", listener)

    if (checkWin() == false)
        terminal.printLine(`  You lost!`, Color.COLOR_1)
    else
        terminal.printLine(`  You won!`, Color.COLOR_1)

    await HighscoreApi.registerProcess("2048")
    await HighscoreApi.uploadScore(score)
}, {
   description: "play a game of 2048",
   isGame: true
})

// ------------------- js/commands/4inarow.js --------------------
terminal.addCommand("4inarow", async function(args) {
    await terminal.modules.import("game", window)

    const N = " ", X = "X", O = "O"
    let field = Array.from(Array(6)).map(() => Array(7).fill(N))
    let printedElements = []

    let DEPTH = args.depth

    function printDeletable(text, color, backgroundColor) {
        const ele = terminal.print(text, color, {forceElement: true, background: backgroundColor})
        printedElements.push(ele)
        return ele
    }

    function clearPrinted() {
        for (const element of printedElements) {
            element.remove()
        }
        printedElements = []
    }

    function printField(f=field) {
        const betweenRow = "+---+---+---+---+---+---+---+"

        printDeletable("+-1-+-2-+-3-+-4-+-5-+-6-+-7-+\n")
        for (let row of f) {
            printDeletable("| ")
            for (let item of row) {
                switch(item) {
                    case X: printDeletable(X, Color.rgb(255, 255, 0)); break;
                    case O: printDeletable(O, Color.rgb(100, 100, 255)); break;
                    case N: printDeletable(" ")
                }
                printDeletable(" | ")
            }
            printDeletable("\n" + betweenRow + "\n")
        }
    }

    function putIntoField(n, val, f=field) {
        for (let i = 5; i >= 0; i--) {
            if (f[i][n] == N) {
                f[i][n] = val
                return true
            }
        }
        return false
    }

    function popUpper(n, f=field) {
        for (let i = 0; i < 6; i++) {
            if (f[i][n] != N) {
                f[i][n] = N
                return true
            }
        }
        return false
    }

    function rowFree(n, f=field) {
        for (let i = 0; i < 6; i++)
            if (f[i][n] == N) return true
        return false
    }

    function makeFieldMove(oldField, n, val) {
        let newField = JSON.parse(JSON.stringify(oldField))
        putIntoField(n, val, newField)
        return newField
    }

    async function getUserMove() {
        input = await terminal.promptNum("Your move [1-7]: ", {min: 1, max: 7}) - 1
        if (!rowFree(input)) {
            terminal.printLine("Field is not free.")
            return getUserMove()
        } else {
            return input
        }
    }

    function getWinner(f=field) {
        for (let player of [X, O]) {

            for (let i = 0; i < 7; i++) {
                let count = 0
                for (let j = 0; j < 6; j++) {
                    if (f[j][i] == player) count++
                    else count = 0

                    if (count == 4)
                        return player
                }
            }

            for (let i = 0; i < 6; i++) {
                let count = 0
                for (let j = 0; j < 7; j++) {
                    if (f[i][j] == player) count++
                    else count = 0

                    if (count == 4)
                        return player
                }
            }

            for (let i = -2; i < 4; i++) {
                let j = i
                let count = 0
                for (let k = 0; k < 6; k++) {
                    if (j < 0 || j > 6) {
                        j++
                        continue
                    }

                    if (f[k][j] == player) count++
                    else count = 0

                    if (count == 4)
                        return player
                    j++
                }
            }

            for (let i = 8; i >= 3; i--) {
                let j = i
                let count = 0
                for (let k = 0; k < 6; k++) {
                    if (j < 0 || j > 6) {
                        j++
                        continue
                    }

                    if (f[k][j] == player) count++
                    else count = 0

                    if (count == 4)
                        return player
                    j--
                }
            }

        }

        return null
    }

    function isDraw(f=field) {
        for (let i = 0; i < 7; i++) { 
            for (let j = 0; j < 6; j++) {
                if (f[j][i] == N) return false
            }
        }
        return true
    }
    
    const possibleWins = [
        // HORIZONTAL
        [[0, 0], [0, 1], [0, 2], [0, 3]],
        [[0, 1], [0, 2], [0, 3], [0, 4]],
        [[0, 2], [0, 3], [0, 4], [0, 5]],
        [[0, 3], [0, 4], [0, 5], [0, 6]],
        [[1, 0], [1, 1], [1, 2], [1, 3]],
        [[1, 1], [1, 2], [1, 3], [1, 4]],
        [[1, 2], [1, 3], [1, 4], [1, 5]],
        [[1, 3], [1, 4], [1, 5], [1, 6]],
        [[2, 0], [2, 1], [2, 2], [2, 3]],
        [[2, 1], [2, 2], [2, 3], [2, 4]],
        [[2, 2], [2, 3], [2, 4], [2, 5]],
        [[2, 3], [2, 4], [2, 5], [2, 6]],
        [[3, 0], [3, 1], [3, 2], [3, 3]],
        [[3, 1], [3, 2], [3, 3], [3, 4]],
        [[3, 2], [3, 3], [3, 4], [3, 5]],
        [[3, 3], [3, 4], [3, 5], [3, 6]],
        [[4, 0], [4, 1], [4, 2], [4, 3]],
        [[4, 1], [4, 2], [4, 3], [4, 4]],
        [[4, 2], [4, 3], [4, 4], [4, 5]],
        [[4, 3], [4, 4], [4, 5], [4, 6]],
        [[5, 0], [5, 1], [5, 2], [5, 3]],
        [[5, 1], [5, 2], [5, 3], [5, 4]],
        [[5, 2], [5, 3], [5, 4], [5, 5]],
        [[5, 3], [5, 4], [5, 5], [5, 6]],

        // VERTICAL
        [[0, 0], [1, 0], [2, 0], [3, 0]],
        [[1, 0], [2, 0], [3, 0], [4, 0]],
        [[2, 0], [3, 0], [4, 0], [5, 0]],
        [[0, 1], [1, 1], [2, 1], [3, 1]],
        [[1, 1], [2, 1], [3, 1], [4, 1]],
        [[2, 1], [3, 1], [4, 1], [5, 1]],
        [[0, 2], [1, 2], [2, 2], [3, 2]],
        [[1, 2], [2, 2], [3, 2], [4, 2]],
        [[2, 2], [3, 2], [4, 2], [5, 2]],
        [[0, 3], [1, 3], [2, 3], [3, 3]],
        [[1, 3], [2, 3], [3, 3], [4, 3]],
        [[2, 3], [3, 3], [4, 3], [5, 3]],
        [[0, 4], [1, 4], [2, 4], [3, 4]],
        [[1, 4], [2, 4], [3, 4], [4, 4]],
        [[2, 4], [3, 4], [4, 4], [5, 4]],
        [[0, 5], [1, 5], [2, 5], [3, 5]],
        [[1, 5], [2, 5], [3, 5], [4, 5]],
        [[2, 5], [3, 5], [4, 5], [5, 5]],
        [[0, 6], [1, 6], [2, 6], [3, 6]],
        [[1, 6], [2, 6], [3, 6], [4, 6]],
        [[2, 6], [3, 6], [4, 6], [5, 6]],

        // DIAGONAL
        [[2, 0], [3, 1], [4, 2], [5, 3]],
        [[1, 0], [2, 1], [3, 2], [4, 3]],
        [[0, 0], [1, 1], [2, 2], [3, 3]],
        [[2, 1], [3, 2], [4, 3], [5, 4]],
        [[1, 1], [2, 2], [3, 3], [4, 4]],
        [[0, 1], [1, 2], [2, 3], [3, 4]],
        [[2, 2], [3, 3], [4, 4], [5, 5]],
        [[1, 2], [2, 3], [3, 4], [4, 5]],
        [[0, 2], [1, 3], [2, 4], [3, 5]],
        [[2, 3], [3, 4], [4, 5], [5, 6]],
        [[1, 3], [2, 4], [3, 5], [4, 6]],
        [[0, 3], [1, 4], [2, 5], [3, 6]],

        [[2, 3], [3, 2], [4, 1], [5, 0]],
        [[1, 3], [2, 2], [3, 1], [4, 0]],
        [[0, 3], [1, 2], [2, 1], [3, 0]],
        [[2, 4], [3, 3], [4, 2], [5, 1]],
        [[1, 4], [2, 3], [3, 2], [4, 1]],
        [[0, 4], [1, 3], [2, 2], [3, 1]],
        [[2, 5], [3, 4], [4, 3], [5, 2]],
        [[1, 5], [2, 4], [3, 3], [4, 2]],
        [[0, 5], [1, 4], [2, 3], [3, 2]],
        [[2, 6], [3, 5], [4, 4], [5, 3]],
        [[1, 6], [2, 5], [3, 4], [4, 3]],
        [[0, 6], [1, 5], [2, 4], [3, 3]],
    ]

    function evaluateField(f=field) {
        let score = 0

        for (let player of [X, O]) {
            let factor = (player == X) ? 1 : -1
            for (let possibleWin of possibleWins) {
                let count = 0
                for (let pos of possibleWin) {
                    if (f[pos[0]][pos[1]] == player) {
                        count++
                    }
                }
                if (count == 4 && player == X) {
                    score += 1000000
                } else if (count == 4 && player == O) {
                    score -= 1000100
                } else if (count == 3) {
                    score += 10 * factor
                } else if (count == 2) {
                    score += 0.1 * factor
                }
            }
        }

        return score
    }

    class Board {

        constructor(field) {
            this.field = field
            this.movingColor = O
            this.lastMoves = []
            this.prevMoveOrder = [3, 4, 2, 5, 0, 6, 1]
        }

        get lastMove() {
            return this.lastMoves[this.lastMoves.length - 1]
        }

        swapColor() {
            this.movingColor = (this.movingColor == X) ? O : X
        }

        makeMove(move) {
            putIntoField(move, this.movingColor, this.field)
            this.swapColor()
            this.lastMoves.push(move)
        }

        unmakeMove(move) {
            popUpper(move, this.field)
            this.swapColor()
            this.lastMoves.pop()
        }

        evaluate() {
            let evaluation = evaluateField(this.field)
            if (this.movingColor == O) evaluation *= -1
            return evaluation
        }

        getBestMove(depth, alpha=-Infinity, beta=Infinity) {
            totalEvaluations++
            let evaluation = this.evaluate()
            if (depth == 0 || Math.abs(evaluation) > 10000) {
                return {
                    move: null,
                    score: evaluation
                }
            }

            let moves = this.prevMoveOrder.filter(m => rowFree(m, this.field))
            let moveEval = Array.from(Array(7), () => -10000000)
            let bestMove = null
            for (let move of moves) {
                this.makeMove(move)
                let score = -this.getBestMove(depth - 1, -beta, -alpha).score
                moveEval[move] = score
                this.unmakeMove(move)
                if (score >= beta) {
                    return {
                        move: null,
                        score: beta
                    }
                }
                if (score > alpha) {
                    alpha = score
                    bestMove = move
                }
            }

            if (DEPTH == depth) {
                this.prevMoveOrder.sort(function(a, b) {
                    return moveEval[a] - moveEval[b]
                })
            }

            return {
                move: bestMove,
                score: alpha
            }
        }

    }

    let totalEvaluations = 0

    while (!isDraw() && !getWinner()) {
        clearPrinted()

        printField()
        let userMove = await getUserMove()
        putIntoField(userMove, X)
        if (isDraw() || getWinner())
            break

        totalEvaluations = 0
        let evaluation = new Board(field).getBestMove(DEPTH)
        let computerMove = evaluation.move
        let moveScore = ~~evaluation.score

        if (args.s) {
            terminal.printLine(`(depth=${DEPTH}, eval=${moveScore})`)
        }

        if (totalEvaluations < 1000) {
            DEPTH += 4
        } else if (totalEvaluations < 10000) {
            DEPTH++
        }

        if (computerMove == null) {
            terminal.printLine("The computer resigns. You win!")
            terminal.printEasterEgg("4inarow-Master-Egg")
            return
        }

        putIntoField(computerMove, O)
    }

    clearPrinted()
    let winner = getWinner()
    printField()
    if (winner) {
        terminal.printLine(`The winner is ${winner}`)
        if (winner == X)
            terminal.printEasterEgg("4inarow-Master-Egg")
    } else {
        terminal.printLine("It's a draw!")
    }
}, {
    description: "play a game of Connect Four against the computer",
    args: {
        "?d=depth:i:1~100": "The depth of the search tree",
        "?s=show-debug:b": "Show debug info about board eval"
    },
    standardVals: {
        depth: 4
    },
    isGame: true
})

// ------------------- js/commands/alias.js --------------------
terminal.addCommand("alias", function(args) {
    let actionCount = 0

    if (args.remove) {
        if (Object.keys(terminal.data.aliases).includes(args.remove)) {
            terminal.data.removeAlias(args.remove)
            terminal.printSuccess(`Removed alias "${args.remove}"`)
            actionCount++
        } else {
            throw new Error(`Alias "${args.remove}" not found`)
        }
    }

    if (args.show) {
        let longestAliasLength = Object.keys(terminal.data.aliases).reduce((p, c) => c.length > p ? c.length : p, 0)
        for (let [alias, command] of Object.entries(terminal.data.aliases)) {
            terminal.print(alias.padEnd(longestAliasLength + 2), Color.COLOR_1)
            terminal.printLine(command)
        }
        actionCount++
    }

    if (args.alias && args.command) {
        const alias = args.alias, command = args.command

        if (terminal.functions.map(f => f.name.toLowerCase()).includes(alias.toLowerCase())) {
            throw new Error("Command/Alias already exists!")
        }
        if (!String(alias).match(/^[a-zA-Z][-\_0-9a-zA-Z]*$/) || alias.length > 20) {
            throw new Error("Invalid alias!")
        }

        addAlias(alias, command)
        actionCount++

    } else if (args.alias || args.command) {
        terminal.print("Example: ")
        terminal.printCommand("alias hello hi")
        throw new Error("Must both provide alias and new command")
    }

    if (actionCount == 0) {
        TerminalParser.parseArgs(["--help"], this)
    }
}, {
    description: "create a new alias for a given function",
    args: {
        "?alias:s": "name of the new alias",
        "?*command:s": "name of the command to be aliased",
        "?s=show:b": "show all aliases",
        "?r=remove:s": "remove a given alias"
    }
})



// ------------------- js/commands/ant-opt.js --------------------
terminal.addCommand("ant-opt", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../path-finder/",
        name: "Interactive Ant Colony Optimization",
        fullscreen: args.fullscreen
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "interactive solution to the travelling salesman problem using ant colony optimization",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/apc-sim.js --------------------
terminal.addCommand("apc-sim", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    const nicerProblemName = args.problem.replaceAll("-", " ")
    const terminalWindow = terminal.modules.window.make({
        name: `APC Animation (${nicerProblemName})`, fullscreen: args.f})

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const canvasSize = () => new Vector2d(canvas.width, canvas.height)
    const backgroundColor = "white"

    let uniqueIdCount = 0
    function makeUniqueId() {
        return uniqueIdCount++
    }

    function randomPosition() {
        return Vector2d.fromFunc(Math.random).sub(UnitVector2d.scale(0.5)).scale(2)
    }

    function easeInOut(t) {
        if ((t /= 1 / 2) < 1) return 1 / 2 * t * t
        return -1 / 2 * ((--t) * (t - 2) - 1)
    }

    function clipPosToScreenPos(clipPos) {
        return clipPos.add(UnitVector2d).mul(canvasSize().scale(0.5))
    }

    function screenPosToClipPos(screenPos) {
        return screenPos.div(canvasSize()).scale(2).sub(UnitVector2d)
    }

    class ApcScene {

        constructor() {
            this.objects = []
            this.animationObjects = new Map()
            this.animationObjectId = 0
        }

        add(object) {
            this.objects.push(object)
            return this
        }

        remove(object) {
            this.objects = this.objects.filter(o => o.id !== object.id)
            return this
        }

        animateAdd(object, ms=500) {
            if (object.type == "line") {
                this.animateAddLine(object, ms)
            } else if (object.type == "point") {
                this.animateAddPoint(object, ms)
            }
            return this
        }

        _makeAnimation(obj, changeFunc, ms) {
            const originalObj = obj.copy()
            const startTime = Date.now()
            const objectId = this.animationObjectId++

            changeFunc(obj, originalObj, 0)

            const update = () => {
                const progress = (Date.now() - startTime) / ms
                if (progress >= 1) {
                    if (this.animationObjects.has(objectId)) {
                        this.animationObjects.delete(objectId)
                        this.add(originalObj)
                    }
                } else {
                    changeFunc(obj, originalObj, progress)
                }
            }

            this.animationObjects.set(objectId, {
                object: obj, update
            })
        }

        animateAddPoint(point, ms) {
            this._makeAnimation(
                point, 
                (point, ogPoint, t) => {
                    point.radius = ogPoint.radius * t
                }, ms)
        }

        animateAddLine(line, ms) {
            this._makeAnimation(
                line, 
                (line, ogLine, t) => {
                    line.p2 = ogLine.p1.lerp(ogLine.p2, t)
                }, ms)
        }

        render() {
            context.fillStyle = backgroundColor
            context.fillRect(0, 0, canvas.width, canvas.height)
            for (const object of this.objects) {
                object.draw()
            }
            for (const animationObject of this.animationObjects.values()) {
                animationObject.update()
                animationObject.object.draw()
            }
        }

    }

    class ApcPoint {

        constructor(pos, {color="black", radius=5, style="normal", name=null, id=null}={}) {
            this.id = id ?? makeUniqueId()
            this.type = "point"
            this.pos = pos
            this.color = color
            this.radius = radius
            this.style = style
            this.name = name
        }

        copy() {
            return new ApcPoint(
                this.pos.copy(),
                {color: this.color, radius: this.radius, style: this.style, name: this.name, id: this.id}
            )
        }

        draw() {
            const screenPos = clipPosToScreenPos(this.pos)

            context.fillStyle = this.color
            context.strokeStyle = this.color
            if (this.style == "normal") {
                context.beginPath()
                context.arc(screenPos.x, screenPos.y, this.radius, 0, Math.PI * 2)
                context.fill()
            } else if (this.style == "box") {
                context.fillRect(screenPos.x - this.radius,
                    screenPos.y - this.radius,
                    this.radius * 2, this.radius * 2)
            } else if (this.style.toLowerCase() == "x") {
                context.beginPath()
                context.lineWidth = 1
                
                context.moveTo(screenPos.x - this.radius, screenPos.y - this.radius)
                context.lineTo(screenPos.x + this.radius, screenPos.y + this.radius)
                context.moveTo(screenPos.x - this.radius, screenPos.y + this.radius)
                context.lineTo(screenPos.x + this.radius, screenPos.y - this.radius)

                context.stroke()
            }

            if (this.name !== null) {
                const textMetric = context.measureText(this.name)
                const textHeight = textMetric.fontBoundingBoxAscent + textMetric.fontBoundingBoxDescent
            
                context.fillStyle = backgroundColor
                context.fillRect(
                    screenPos.x + this.radius * 2,
                    screenPos.y,
                    textMetric.width, textHeight
                )

                context.textBaseline = "top"
                context.fillStyle = this.color
                context.fillText(this.name,
                    screenPos.x + this.radius * 2,
                    screenPos.y)
            }
        }

    }

    class ApcLine {

        constructor(p1, p2, {color="black", width=1, style="normal", id=null}={}) {
            this.id = id ?? makeUniqueId()
            this.type = "line"
            this.p1 = (p1 instanceof ApcPoint) ? p1.pos.copy() : p1
            this.p2 = (p2 instanceof ApcPoint) ? p2.pos.copy() : p2
            this.color = color
            this.width = width
            this.style = style
        }

        static xyxy(x1, y1, x2, y2) {
            return new ApcLine(
                new Vector2d(x1, y1),
                new Vector2d(x2, y2)
            )
        }

        distance(point) {
            return distancePointLineSegment(point, this.p1, this.p2)
        }

        containsPoint(point) {
            return this.distance(point) < 0.001
        }

        calcIntersection(otherLine) {
            return calcLineIntersection(this.p1, this.p2, otherLine.p1, otherLine.p2)
        }

        copy() {
            return new ApcLine(
                this.p1.copy(), this.p2.copy(),
                {color: this.color, width: this.width, style: this.style, id: this.id}
            )
        }

        draw() {
            context.beginPath()
            const s1 = clipPosToScreenPos(this.p1)
            const s2 = clipPosToScreenPos(this.p2)

            context.moveTo(s1.x, s1.y)
            context.lineTo(s2.x, s2.y)

            if (this.style == "normal") {
                context.setLineDash([])
            } else if (this.style == "dashed") {
                context.setLineDash([10, 10])
            }

            context.strokeStyle = this.color
            context.lineWidth = this.width
            context.stroke()
        }

    }

    const scene = new ApcScene()

    let running = true

    terminal.onInterrupt(() => {
        running = false
        terminalWindow.close()
    })

    function renderLoop() {
        scene.render()

        if (running) {
            window.requestAnimationFrame(renderLoop)
        }
    }

    terminal.window.scene = scene

    const windowBorderLines = [
        new ApcLine(new Vector2d(-1, -1), new Vector2d(-1, 1)),
        new ApcLine(new Vector2d(-1, 1), new Vector2d(1, 1)),
        new ApcLine(new Vector2d(1, 1), new Vector2d(1, -1)),
        new ApcLine(new Vector2d(1, -1), new Vector2d(-1, -1)),
    ]

    renderLoop()

    const apcProblems = {
        "can-x-see-q": async () => {

            // CAN X SEE Q PROBLEM

            const X = new ApcPoint(ZeroVector2d, {style: "x"})
            scene.animateAdd(X, 1000)

            await sleep(1000)

            const allEndpoints = []
            const allLineSegments = []
            const allConnecting = []

            for (let i = 0; i < 5; i++) {
                let pos1 = null
                let pos2 = null

                while (
                    pos1 === null || pos1.distance(pos2) > 1 || pos1.distance(pos2) < 0.2
                    || Math.abs(pos1.sub(X.pos).normalized.dot(pos2.sub(X.pos).normalized)) > 0.2
                    || Math.max(pos1.abs().max, pos2.abs().max) > 0.8
                    || distancePointLineSegment(X.pos, pos1, pos2) < 0.2
                    || Math.min(...allEndpoints.map(([p1, p2]) => distancePointLineSegment(pos1, p1, p2))) < 0.1
                    || Math.min(...allEndpoints.map(([p1, p2]) => distancePointLineSegment(pos2, p1, p2))) < 0.1
                    || allEndpoints.some(([p1, p2]) => calcLineIntersection(p1, p2, pos1, pos2))
                ) {
                    pos1 = randomPosition()
                    pos2 = randomPosition()
                }

                const p1 = new ApcPoint(pos1, {radius: 4})
                const p2 = new ApcPoint(pos2, {radius: 4})

                const lineSegment = new ApcLine(p1, p2)

                scene.animateAdd(p1).animateAdd(p2).animateAdd(lineSegment)
                allEndpoints.push([pos1, pos2])
                allLineSegments.push(lineSegment)
            }
        
            await sleep(1000)

            for (const endPoint of allEndpoints.flat()) {
                const connectingLine = new ApcLine(X, endPoint, {style: "dashed", color: "blue"})
                scene.animateAdd(connectingLine)

                await sleep(1000)

                let foundIntersection = null
                for (let otherLine of allLineSegments) {
                    // skip if it's the same line
                    if (otherLine.containsPoint(endPoint)) {
                        continue
                    }

                    const intersection = connectingLine.calcIntersection(otherLine)
                    if (intersection !== null) {
                        foundIntersection = intersection
                        break
                    }
                }

                scene.remove(connectingLine)

                if (foundIntersection) {
                    const intersectionPoint = new ApcPoint(foundIntersection, {style: "x", color: "red", radius: 10})
                    scene.animateAdd(intersectionPoint)
                    setTimeout(() => {
                        scene.remove(intersectionPoint)
                    }, 1000)
                } else {
                    let closestIntersection = null
                    let closestIntersectionDistance = Infinity

                    const delta = connectingLine.p2.sub(connectingLine.p1)
                    connectingLine.p2 = connectingLine.p1.add(delta.normalized.scale(3))
                    
                    for (const otherLine of allLineSegments.concat(windowBorderLines)) {
                        if (otherLine.containsPoint(endPoint)) {
                            continue
                        }
    
                        const intersection = connectingLine.calcIntersection(otherLine)
                        if (intersection !== null && intersection.distance(endPoint) < closestIntersectionDistance) {
                            closestIntersectionDistance = intersection.distance(endPoint)
                            closestIntersection = intersection
                        }
                    }

                    if (closestIntersection !== null) {
                        connectingLine.p2 = closestIntersection
                        connectingLine.style = "normal"
                        connectingLine.color = "rgba(0, 0, 255, 0.5)"
                        allConnecting.push(connectingLine)

                        const intersectionPoint = new ApcPoint(closestIntersection, {color: "rgba(0, 0, 255, 0.5)", radius: 3})
                        scene.animateAdd(connectingLine).animateAdd(intersectionPoint)
                        await sleep(1000)
                    }
                }
            }

            await sleep(1500)

            const Q = new ApcPoint(randomPosition(), {color: "red", name: "q"})
            scene.animateAdd(Q)
            await sleep(1000)

            await sleep(100000)
        }
    }

    await apcProblems[args.problem]()

    terminalWindow.close()
}, {
    description: "play an animation relating to an apc problem",
    args: {
        "problem:e:can-x-see-q": "problem to animate",
        "?f=fullscreen:b": "open in fullscreen"
    }
})

// ------------------- js/commands/asteroids.js --------------------
terminal.addCommand("asteroids", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({
        name: "Asteroids", fullscreen: args.fullscreen
    })

    const maxNumParticles = 1000

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const canvasSize = () => new Vector2d(canvas.width, canvas.height)

    let gameRunning = true

    terminal.onInterrupt(() => {
        gameRunning = false
        terminalWindow.close()
    })

    function randomPolygon() {
        let corners = Math.floor(Math.random() * 10) + 5
        let points = []
        for (let i = 0; i < corners; i++) {
            let angle = i / corners * Math.PI * 2
            let length = Math.random() * 0.5 + 0.5
            points.push(new Vector2d(0, -length).rotate(angle))
        }
        return points
    }

    function drawTextLines(lines) {
        context.fillStyle = "white"
        context.font = "20px monospace"
        context.textAlign = "left"
        context.textBaseline = "top"
        for (let i = 0; i < lines.length; i++) {
            context.fillText(lines[i], 10, 10 + i * 20)
        }
    }

    class Ship {

        constructor() {
            this.pos = canvasSize().scale(0.5)
            this.vel = new Vector2d(0, 0)
            this.rotation = 0 // radians
            this.thrust = 0 // 0 to 1
            this.size = 20
            this.alive = true
            this.score = 0
        }

        copy() {
            const ship = new Ship()
            ship.pos = this.pos.copy()
            ship.vel = this.vel.copy()
            ship.rotation = this.rotation
            ship.thrust = this.thrust
            ship.size = this.size
            ship.alive = this.alive
            ship.score = this.score
            return ship
        }

        copyAndMove(dx, dy) {
            const ship = this.copy()
            ship.pos.iadd(new Vector2d(dx, dy))
            return ship
        }

        die() {
            if (!this.alive) return
            this.alive = false
            spawnExplosion(this.pos)

            setTimeout(() => {
                if (!gameRunning) return
                gameRunning = false
            }, 3000)
        }

        get maxSpeed() {
            return canvasSize().length * 0.01
        }

        get acceleration() {
            return canvasSize().length * 0.00008
        }

        get rotationSpeed() {
            return Math.PI * 0.03
        }

        get thrustVector() {
            return new Vector2d(0, -this.thrust).rotate(this.rotation).scale(this.acceleration)
        }

        get bulletDirection() {
            return new Vector2d(0, -1).rotate(this.rotation).scale(this.acceleration * 100)
        }

        update() {
            if (!this.alive) return
            this.vel.iadd(this.thrustVector)
            this.vel.iscale(0.995)
            this.pos.iadd(this.vel)
            if (this.vel.length > this.maxSpeed)
                this.vel.iscale(this.maxSpeed / this.vel.length)

            if (this.pos.x < 0) this.pos.x += canvas.width
            if (this.pos.x > canvas.width) this.pos.x -= canvas.width
            if (this.pos.y < 0) this.pos.y += canvas.height
            if (this.pos.y > canvas.height) this.pos.y -= canvas.height

            for (let asteroid of asteroids) {
                if (this.pos.distance(asteroid.pos) < asteroid.size + this.size) {
                    this.die()
                }
            }
        }

        drawThrust() {
            context.strokeStyle = "red"
            context.lineWidth = 2

            context.beginPath()
            context.moveTo(-this.size,  this.size * 0.6)
            context.lineTo(-this.size - this.thrust * this.size,  0)
            context.lineTo(-this.size, -this.size * 0.6)
            context.closePath()
            context.stroke()
        }
 
        spawnParticle() {
            if (!this.alive) return
            let particle = new Particle()
            particle.pos = this.pos.copy()
            particle.vel = this.bulletDirection.copy()
            particle.vel.iadd(this.vel)
            particles.unshift(particle)
        }

        draw() {
            if (!this.alive) return

            context.strokeStyle = "white"
            context.lineWidth = 2

            context.beginPath()
            context.save()
            context.translate(this.pos.x, this.pos.y)
            context.rotate(this.rotation - Math.PI / 2)

            context.moveTo( this.size,  0)
            context.lineTo(-this.size,  this.size * 0.8)
            context.lineTo(-this.size, -this.size * 0.8)
            context.lineTo( this.size,  0)
            context.closePath()
            context.stroke()

            if (this.thrust > 0) {
                this.drawThrust()
            }

            context.restore()
        }

    }

    function spawnExplosion(position, num=200) {
        let numParticles = Math.floor(Math.random() * num / 2) + Math.floor(num)
        for (let i = 0; i < numParticles; i++) {
            let particle = new ExplosionParticle(position.copy())
            explosionParticles.unshift(particle)
        }
    }

    class Asteroid {

        randomPosition() {
            const randomPos = () => new Vector2d(
                Math.random() * canvas.width,
                Math.random() * canvas.height
            )

            let pos = randomPos()
            while (pos.distance(ship.pos) < canvasSize().length / 4) {
                pos = randomPos()
            }   

            return pos
        }

        constructor(level=3) {
            this.level = level
            this.pos = this.randomPosition()
            this.rotation = Math.random() * Math.PI * 2
            this.vel = Vector2d.random().scale(Math.random() * 1 + 0.5)
            this.size = (level * 15) + Math.random() * 3
            this.shape = randomPolygon()
            this.alive = true
        }

        die() {
            if (!this.alive) return

            ship.score++
            this.alive = false
            spawnExplosion(this.pos, this.level * 10)

            if (this.level > 1) {
                let children = Math.floor(Math.random() * 2) + 1
                for (let i = 0; i < children; i++) {
                    let asteroid = new Asteroid(this.level - 1)
                    asteroid.pos = this.pos.copy().add(Vector2d.random().scale(this.size))
                    asteroids.push(asteroid)
                }
            }
        }

        inHitBox(pos) {
            let distance = this.pos.distance(pos)
            return distance < this.size
        }

        draw() {
            context.strokeStyle = "white"
            context.lineWidth = 2

            context.beginPath()
            context.save()
            context.translate(this.pos.x, this.pos.y)
            context.rotate(this.rotation)

            for (let i = 0; i < this.shape.length; i++) {
                let p = this.shape[i]
                context.lineTo(p.x * this.size, p.y * this.size)
            }

            context.closePath()
            context.stroke()

            context.restore()
        }

        update() {
            this.pos.iadd(this.vel)

            if (this.pos.x < -this.size) this.pos.x += canvas.width + this.size * 2
            if (this.pos.x > canvas.width + this.size) this.pos.x -= canvas.width + this.size * 2
            if (this.pos.y < -this.size) this.pos.y += canvas.height + this.size * 2
            if (this.pos.y > canvas.height + this.size) this.pos.y -= canvas.height + this.size * 2
        }

    }

    class ExplosionParticle {

        constructor(pos) {
            this.pos = pos.copy()
            this.vel = Vector2d.random().scale(Math.random() * 10 + 5)
            this.size = Math.random() * 5 + 3
            this.alive = true
        }

        update() {
            this.pos.iadd(this.vel)
            this.alive = this.pos.x > 0 && this.pos.x < canvas.width &&
                         this.pos.y > 0 && this.pos.y < canvas.height
        }

        draw() {
            context.fillStyle = "rgba(255, 128, 128, 0.9)"
            context.fillRect(this.pos.x, this.pos.y, this.size, this.size)
        }

    }

    class Particle {

        constructor() {
            this.size = 3
            this.pos = new Vector2d(0, 0)
            this.vel = new Vector2d(0, 0)
            this.alive = true
            this.tickCount = 0
            this.maxTickCount = 1000
        }

        isOffScreen() {
            return this.pos.x < 0 || this.pos.x > canvas.width ||
                   this.pos.y < 0 || this.pos.y > canvas.height
        }

        die() {
            this.alive = false
        }

        update() {
            this.pos.iadd(this.vel)
            this.tickCount++

            if (this.tickCount > this.maxTickCount)
                this.die()

            if (args.chaos) {
                if (this.pos.x < 0)
                    this.pos.x = canvas.width
                if (this.pos.x > canvas.width)
                    this.pos.x = 0
                if (this.pos.y < 0)
                    this.pos.y = canvas.height
                if (this.pos.y > canvas.height)
                    this.pos.y = 0
            } else {
                this.alive = !this.isOffScreen()
            }

            for (let asteroid of asteroids) {
                if (asteroid.inHitBox(this.pos)) {
                    asteroid.die()
                    this.die()
                }
            }
        }

        draw() {
            context.fillStyle = "white"
            context.fillRect(this.pos.x, this.pos.y, this.size, this.size)
        }

    }

    function drawBackground() {
        context.fillStyle = "black"
        context.fillRect(0, 0, canvas.width, canvas.height)
    }

    const keysDown = new Set()
    const validKeys = new Set(["ArrowLeft", "ArrowRight", "ArrowUp", " "])

    addEventListener("keydown", event => {
        if (!gameRunning) return
        if (!event.repeat) keysDown.add(event.key)
        if (validKeys.has(event.key)) event.preventDefault()
    })
    addEventListener("keyup", event => keysDown.delete(event.key))

    function handleUserInput() {
        if (keysDown.has("ArrowLeft")) {
            ship.rotation -= ship.rotationSpeed
        }

        if (keysDown.has("ArrowRight")) {
            ship.rotation += ship.rotationSpeed
        }

        if (keysDown.has("ArrowUp")) {
            ship.thrust = Math.min(1, ship.thrust + 0.1)
        } else {
            ship.thrust = 0
        }

        if (keysDown.has(" ")) {
            ship.spawnParticle()
            if (!args.chaos)
                keysDown.delete(" ")
        }
    }

    function reset() {
        ship = new Ship()
        particles = []
        explosionParticles = []
        asteroids = []
        minL3Asteroids = 8
        gameRunning = true
    }

    let ship = new Ship()
    let particles = []
    let explosionParticles = []
    let asteroids = []
    let minL3Asteroids = 8

    function loop() {
        drawBackground()
        ship.update()

        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const movedShip = ship.copyAndMove(
                    i * canvas.width,
                    j * canvas.height
                )
                movedShip.draw()
            }
        }

        for (let particle of particles) {
            particle.update()
            particle.draw()
        }

        for (let particle of explosionParticles) {
            particle.update()
            particle.draw()
        }

        let l3AsteroidCount = 0
        for (let asteroid of asteroids) {
            asteroid.update()
            asteroid.draw()
            if (asteroid.level == 3) l3AsteroidCount++
        }

        particles = particles.filter(particle => particle.alive)
        explosionParticles = explosionParticles.filter((particle, i) => {
            if (i > maxNumParticles) return false
            if (particle.alive) return true
            return false
        })
        asteroids = asteroids.filter(asteroid => asteroid.alive)

        if (l3AsteroidCount < minL3Asteroids) {
            asteroids.push(new Asteroid())
            if (Math.random() < 0.05) {
                minL3Asteroids++
            }
        }

        drawTextLines([
            `Score: ${ship.score}`,
        ])

        handleUserInput()

        if (gameRunning)
            terminal.window.requestAnimationFrame(loop)
    }

    while (true) {
        loop()
        while (gameRunning) {
            await terminal.sleep(100)
        }

        let chosenOptionIndex = await CanvasDrawer.promptOptions(context, {
            options: [
                "Play again",
                `Upload Score (${ship.score})`,
                "Exit"
            ]
        })
    
        if (chosenOptionIndex == 0) {
            reset()
        } else if (chosenOptionIndex == 1) {
            terminalWindow.close()
            if (!args.chaos) {
                await HighscoreApi.registerProcess("asteroids", {ask: false})
                await HighscoreApi.uploadScore(ship.score)
            } else {
                terminal.printError("Cannot upload score in chaos mode")
            }
            return
        } else {
            terminalWindow.close()
            return
        }
    }

}, {
    description: "simulate a bunch of balls jumping around",
    args: {
        "?f=fullscreen:b": "start in fullscreen mode",
        "?c=chaos:b": "start with chaos mode enabled",
    },
    isGame: true
})

// ------------------- js/commands/avoida.js --------------------
terminal.addCommand("avoida", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({
        name: "Avoida Game", fullscreen: true, removeBar: true
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT
    const xResolution = 200
    const objectScaleFactor = 1
    let displayAngle = 0.1

    canvas.style.userSelect = "none"
    canvas.style.webkitUserSelect = "none"
    canvas.style.mozUserSelect = "none"

    function makeTileMap({
        width=21,
        length=300,
        transitionHeight=15,
        copyFrom=null,
        copyOverlapHeight=10
    }={}) {
        let tileMap = Array.from({length}, 
            () => Array.from({length: width}, () => Math.random() < 0.2 ? true : false))
        
        const middleX = Math.floor(width / 2)
        let currX = middleX
        for (let i = 0; i < tileMap.length; i++) {
            tileMap[i][currX] = false
            if (currX < tileMap[0].length - 1) {
                tileMap[i][currX + 1] = false
            }

            let middleDirection = (middleX - currX) > 0 ? 1 : -1
            if (Math.random() < 0.8) {
                currX += middleDirection
            } else {
                currX -= middleDirection
            }

            currX = Math.min(tileMap[0].length - 1, Math.max(0, currX))
        }

        let offsetHeight = copyFrom == null ? 0 : copyOverlapHeight
        for (let i = offsetHeight; (i < transitionHeight + offsetHeight) && i < length; i++) {
            for (let j = 0; j < width; j++) {
                tileMap[i][j] = false
            }

            tileMap[i][Math.max(middleX - 2, 0)] = true
            tileMap[i][Math.min(middleX + 2, width - 1)] = true
        }

        for (let i = 0; i < offsetHeight; i++) {
            for (let j = 0; j < width; j++) {
                tileMap[i][j] = copyFrom[copyFrom.length - offsetHeight - 1 + i][j]
            }
        }

        return tileMap
    }

    let bitmap = makeTileMap({height: 1000})

    class Player {
        constructor() {
            this.pos = new Vector2d(bitmap[0].length / 2, 0)
            this.originalAngle = Math.PI / 2
            this.angle = this.originalAngle
            this.sideMovement = 0
            this.fov = Math.PI / 1.5
            this.viewDistance = 10
            this.speed = 1
            this.hearts = 5
        }

        move(distance) {
            this.pos.y += distance * this.speed
            this.pos.x += this.sideMovement * this.speed

            let x = Math.floor(this.pos.x)
            let y = Math.floor(this.pos.y)
            let row = bitmap[y]
            if (row) {
                let value = row[x]
                if (value === true) {
                    bitmap[y][x] = false
                    this.hearts--
                }
            }

            this.pos.x = Math.max(0, Math.min(bitmap[0].length - 1, this.pos.x))

            let distanceToEnd = bitmap.length - this.pos.y
            if (distanceToEnd < 11) {
                bitmap = makeTileMap({copyFrom: bitmap})
                this.pos.y = 0
            }

            this.speed += 0.001
        }

        get score() {
            return Math.floor(this.speed * 71) - 71
        }

        resetPos() {
            this.pos = new Vector2d(bitmap[0].length / 2, 0)
        }
    }

    let player = new Player()

    function drawHeart(startX, startY, size=10) {
        context.fillStyle = "red"
        context.fillRect(startX, startY, size, size)
    }

    function drawScore(score, textSize) {
        context.font = `${textSize}px monospace`
        context.fillText(score.toString(), 10, textSize)
    }

    function render() {
        player.fov = (canvas.width / canvas.height) * (Math.PI / 3.5)

        function raycast(start, angle, {
            maxDistance = 10,
            precision = 0.01
        }={}) {
            const delta = Vector2d.fromAngle(angle).scale(precision)
            let currPos = start.copy()
            while (currPos.distance(start) < maxDistance) {
                currPos.iadd(delta)
                const row = bitmap[Math.floor(currPos.y)]
                if (row === undefined) {
                    return Infinity
                }
                const value = row[Math.floor(currPos.x)]
                if (value) {
                    return currPos.distance(start)
                } else if (value === undefined) {
                    return Infinity
                }
            }
            return Infinity
        }

        context.clearRect(0, 0, canvas.width, canvas.height)
        context.fillStyle = "white"

        const yResolution = Math.round((canvas.height / canvas.width) * xResolution)
        const startAngle = player.angle - player.fov / 2
        let heights = []
        for (let x = 0; x < xResolution; x++) {
            let angle = startAngle + player.fov * (x / (xResolution - 1))
            let result = raycast(player.pos, angle, {maxDistance: player.viewDistance})
            let height = Math.min(yResolution - 1, Math.round(yResolution / (result * objectScaleFactor)))
            heights.push(height)
        }

        const xStep = canvas.width / xResolution
        const yStep = canvas.height / yResolution

        context.save()
        context.translate(canvas.width / 2, canvas.height / 2)
        context.rotate(displayAngle)

        for (let x = 0; x < xResolution; x++) {
            const height = heights[x]
            let offset = Math.round((yResolution - height) / 2)
            const lum = Math.round(height / yResolution * 255)
            context.fillStyle = `rgb(${lum}, ${lum}, ${lum})`
            context.fillRect(xStep * x - canvas.width / 2, yStep * offset - canvas.height / 2, xStep + 1, height * yStep)
        }

        context.restore()

        let heartSize = Math.min(canvas.width, canvas.height) / 10
        for (let i = 0; i < player.hearts; i++) {
            drawHeart(canvas.width - ((i + 1) * heartSize * 1.2), heartSize * 0.2, heartSize)
        }

        drawScore(player.score, heartSize)
    }

    let gameRunning = true
    
    let keyDown = {
        "UP": false,
        "DOWN": false,
        "LEFT": false,
        "RIGHT": false
    }

    function parseKeyCode(keycode, up) {
        if (keycode == "ArrowUp" || keycode == "w") {
            keyDown.UP = !up
            return true
        } else if (keycode == "ArrowDown" || keycode == "s") {
            keyDown.DOWN = !up
            return true
        } else if (keycode == "ArrowLeft" || keycode == "a") {
            keyDown.LEFT = !up
            return true
        } else if (keycode == "ArrowRight" || keycode == "d") {
            keyDown.RIGHT = !up
            return true
        }
    }

    let upListener = addEventListener("keyup", function(event) {
        if (!gameRunning) return

        if (parseKeyCode(event.key, true)) event.preventDefault()
    })

    let downListener = addEventListener("keydown", function(event) {
        if (!gameRunning) return

        if (event.key == "c" && event.ctrlKey) {
            gameRunning = false
            removeEventListener("keydown", downListener)
            removeEventListener("keyup", upListener)
        }

        if (parseKeyCode(event.key, false)) event.preventDefault()
    })

    function updateTouchX(pageX) {
        let rect = canvas.getBoundingClientRect()
        let x = (pageX - rect.left) / canvas.clientWidth
        if (x > 0.6) {
            keyDown.RIGHT = true
            keyDown.LEFT = false
        } else if (x < 0.4) {
            keyDown.LEFT = true
            keyDown.RIGHT = false
        } else {
            keyDown.LEFT = false
            keyDown.RIGHT = false
        }
    }

    addEventListener("touchstart", event => {
        updateTouchX(event.touches[0].pageX)
    })

    addEventListener("touchmove", event => {
        updateTouchX(event.touches[0].pageX)
    })

    addEventListener("touchend", event => {
        keyDown.LEFT = false
        keyDown.RIGHT = false
    })

    canvas.addEventListener("contextmenu", event => {
        event.preventDefault()
    })

    function processInput() {
        if (keyDown.LEFT) {
            player.sideMovement += 0.03
        } else if (keyDown.RIGHT) {
            player.sideMovement -= 0.03
        } else {
            player.sideMovement -= player.sideMovement * 0.5
        }

        player.sideMovement = Math.min(player.sideMovement, 0.1)
        player.sideMovement = Math.max(player.sideMovement, -0.1)

        player.desiredAngle = player.originalAngle - player.sideMovement * 3
        player.angle += (player.desiredAngle - player.angle) * 0.1
        displayAngle = player.sideMovement * 1
    }

    terminal.onInterrupt(() => {
        gameRunning = false
        terminalWindow.close()
    })

    while (gameRunning) {
        player.move(0.2)
        render()
        processInput()

        if (player.hearts <= 0) {
            gameRunning = false
        }

        await sleep(40)
    }

    await sleep(1000)

    terminalWindow.close()
    terminal.printLine("Your score: " + player.score)

    await HighscoreApi.registerProcess("avoida")
    await HighscoreApi.uploadScore(player.score)
}, {
    description: "play a game of avoida",
    isGame: true,
})

// ------------------- js/commands/background.js --------------------
const OG_BACKGROUND_COLOR = Color.rgb(3, 3, 6)

terminal.addCommand("background", function(args) {
    if (args.color.toLowerCase() == "reset") {
        terminal.data.background = OG_BACKGROUND_COLOR
        return
    }
    let color = parseColor(args.color)
    let distance = terminal.data.foreground.distanceTo(color)
    if (distance >= 80) {
        terminal.data.background = color
    } else {
        throw new Error("The background color is too close to the foreground color")
    }
}, {
    description: "change the background color of the terminal",
    args: ["color"]
})


// ------------------- js/commands/base64.js --------------------
terminal.addCommand("base64", async function(args) {
    let msg = args.message
    let output = ""
    if (args.d) {
        output = atob(msg)
    } else {
        output = btoa(msg)
    }
    terminal.printLine(output)

    if (args.c)
        await terminal.copy(output, {printMessage: true})
}, {
    description: "encode/decode a message using base64",
    args: {
        "*message": "the message to encode/decode",
        "?d=decode:b": "decode the message instead of encoding it",
        "?c=copy:b": "copy the result to the clipboard"
    },
})

// ------------------- js/commands/bc.js --------------------
terminal.addCommand("bc", async function() {
    await terminal.modules.load("mathenv", terminal)
    while (true) {
        let text = await terminal.prompt()
        let [result, error] = terminal.modules.mathenv.eval(text)
        if (error) {
            terminal.print("> ")
            terminal.printLine(error)
        } else if (result !== null) {
            terminal.print("> ")
            terminal.printLine(result)
        }
    }
}, {
    description: "start a bc (basic calculator) session"
})



// ------------------- js/commands/bezier.js --------------------
terminal.addCommand("bezier", async function() {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../bezier/",
        name: "Bezier Playground"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "play with bezier curves"
})

// ------------------- js/commands/bin.js --------------------
terminal.addCommand("bin", async function(args) {
    let result = parseInt(args.n, args.f).toString(args.t)
    terminal.printLine(result)
}, {
    description: "convert a number to another base",
    args: {
        "n": "number to convert",
        "?t=to-base:i:2~36": "base to convert to",
        "?f=from-base:i:2~36": "base to convert from"
    },
    standardVals: {
        t: 2,
        f: 10
    }
})

// ------------------- js/commands/binomcdf.js --------------------
terminal.addCommand("binomcdf", async function(args) {
    const binomcdf = (await terminal.modules.load("binom", terminal)).binomcdf
    let n = ~~args.n
    let lower = ~~args.lower
    let upper = ~~args.upper
    terminal.printLine(binomcdf(n, args.p, lower, upper))
}, {
    description: "calculate the binomial cumulative distribution function",
    args: {
        "n:n:1~1000": "the number of trials",
        "p:n:0~1": "the probability of success",
        "lower:n:0~1000": "the lower bound",
        "upper:n:0~1000": "the upper bound"
    }
})



// ------------------- js/commands/binompdf.js --------------------
terminal.addCommand("binompdf", async function(args) {
    const binompdf = (await terminal.modules.load("binom", terminal)).binompdf
    let n = ~~args.n
    let k = ~~args.k
    if (k > n) {
        throw new Error("k must be smaller than n")
    }
    terminal.printLine(binompdf(n, args.p, k))
}, {
    description: "calculate binomial distribution value",
    args: {
        "n:n:0~100": "the number of trials",
        "p:n:0~1": "the probability of success",
        "k:n:0~100": "the number of successes"
    }
})



// ------------------- js/commands/blocks.js --------------------
terminal.addCommand("blocks", async function(args) {
	await terminal.modules.import("game", window)
	
	function initField(size, {defaultVal=0}={}) {
		let field = []
		for (let x = 0; x < size.x; x++) {
			let row0 = []
			for (let y = 0; y < size.y; y++) {
				let row1 = []
				for (let z = 0; z < size.z; z++) {
					row1.push(defaultVal)
				}
				row0.push(row1)
			}
			field.push(row0)
		}
		return field
	}
	
	const fieldSize = new Vector3d(args.roomX, args.roomY, args.roomZ)
	const field = initField(fieldSize)
    const maxFieldDistance = fieldSize.length

    function colorFromVals(raycastResult, distance) {
        let hue = raycastResult * 360
        let lightness = 80 - distance / cameraViewDistance * 80
        let saturation = lightness
        return Color.fromHSL(hue / 360, saturation / 100, lightness / 100)
    }
	
	function isOutOfBounds(pos) {
		if (
			(pos.x < 0)
			|| (pos.y < 0)
			|| (pos.z < 0)
			|| (pos.x + 1 > fieldSize.x)
			|| (pos.y + 1 > fieldSize.y)
			|| (pos.z + 1 > fieldSize.z)
		) return true
		return false
	}
	
	function buildCube(pos, size, {f=field, val=1}={}) {
		for (let x = 0; x < size.x; x++) {
			for (let y = 0; y < size.y; y++) {
				for (let z = 0; z < size.z; z++) {
					field[x+pos.x][y+pos.y][z+pos.z] = val
				}
			}
		}
	}

    function buildRandomWalls({f=field, val=p=>1}={}) {
        for (let x = 0; x < fieldSize.x; x++) {
            for (let y = 0; y < fieldSize.y; y++) {
                for (let z = 0; z < fieldSize.z; z++) {
                    if (
                           x == 0 || x == fieldSize.x - 1
                        || y == 0 || y == fieldSize.y - 1
                        || z == 0 || z == fieldSize.z - 1
                    ) {
                        f[x][y][z] = val(new Vector3d(x, y, z))
                    }
                }
            }
        }
    }

    buildRandomWalls({val: pos => {
        return Math.random()
    }})

	const resolution = new Vector2d(args.resolution, Math.floor(args.resolution * (9 / 16)))
	
	let cameraPos = new Vector3d(4.14, 3.73, 4.12)
	let fovXDeg = args.fov / 180 * Math.PI
	let fovYDeg = fovXDeg * (resolution.y / resolution.x)
    
    let leftMostAngle = -fovXDeg / 2
    let rightMostAngle = fovXDeg / 2
    let topMostAngle = -fovYDeg / 2
    let bottomMostAngle = fovYDeg / 2

    let cameraDir = new Vector3d(0.95, 0.28, 0.09).normalized
    let cameraSpeed = 0.1

    const cameraViewDistance = args.viewDistance
	
	function initDisplay(size, {defaultVal=" "}={}) {
        let canvas = document.createElement("canvas")
        let context = canvas.getContext("2d")
        canvas.style.width = terminal.charWidth * 80 + "px"
        let heightPx = Math.floor(terminal.charWidth * 80 * (size.y / size.x))
        canvas.style.height = heightPx + "px"
        terminal.parentNode.appendChild(canvas)
        canvas.width = size.x
        canvas.height = size.y
        canvas.style.imageRendering = "pixelated"
        context.fillStyle = "white"
        context.fillRect(0, 0, canvas.width, canvas.height)
        terminal.addLineBreak()
        return [context.getImageData(0, 0, size.x, size.y), context, canvas]
	}

	const [canvasPixelData, context2d, canvas] = initDisplay(resolution)
	
    function raycast(pos, dir, {stepScalar=0.1, maxDist=maxFieldDistance, f=field}={}) {
        const originalPos = pos.copy()
        let normalisedDir = dir
        let usingNormalisedDir = true
        let floored = pos.floor()
        let coveredDistance = 0
        while (!isOutOfBounds(floored)) {
            floored = pos.floor()
            let block = f[floored.x][floored.y][floored.z]
            if (block != 0) {
                if (usingNormalisedDir) {
                    pos = pos.sub(normalisedDir)
                    coveredDistance -= 1
                    usingNormalisedDir = false
                } else {
                    let distance = pos.distanceTo(originalPos)
                    return [block, distance]
                }
            }
            if (coveredDistance > maxDist)
                return [0, maxDist]
            if (usingNormalisedDir) {
                pos = pos.add(normalisedDir)
                coveredDistance += 1
            } else {
                pos = pos.add(normalisedDir.mul(stepScalar))
                coveredDistance += stepScalar
            }
        }
        return [0, Infinity]
    }

    function init2dArray(size, {defaultVal=0}={}) {
        let arr = []
        for (let y = 0; y < size.y; y++) {
            let row = []
            for (let x = 0; x < size.x; x++) {
                row.push(defaultVal)
            }
            arr.push(row)
        }
        return arr
    }

    function render() {
        let displayColors = init2dArray(resolution, {defaultVal: Color.BLACK})
        function renderData() {
            for (let y = 0; y < resolution.y; y++) {
                for (let x = 0; x < resolution.x; x++) {
                    let color = displayColors[y][x]
                    let index = (y * resolution.x + x) * 4
                    canvasPixelData.data[index] = color.r
                    canvasPixelData.data[index + 1] = color.g
                    canvasPixelData.data[index + 2] = color.b
                    canvasPixelData.data[index + 3] = 255
                }
            }
            context2d.putImageData(canvasPixelData, 0, 0)
        }

        let projectionPlaneTopLeft = cameraPos.add(cameraDir.rotateRight(leftMostAngle).rotateUp(topMostAngle))

        let leftRef = cameraDir.add(cameraDir.rotateRight(leftMostAngle))
        let rightRef = cameraDir.add(cameraDir.rotateRight(rightMostAngle))

        let topRef = cameraDir.add(cameraDir.rotateUp(topMostAngle))
        let bottomRef = cameraDir.add(cameraDir.rotateUp(bottomMostAngle))

        let xDiff = rightRef.sub(leftRef)
        let yDiff = bottomRef.sub(topRef)

        terminal.window.xDiff = xDiff.length
        terminal.window.yDiff = yDiff.length
        
        for (let y = 0; y < resolution.y; y++) {
            for (let x = 0; x < resolution.x; x++) {
                let xRatio = x / resolution.x
                let yRatio = y / resolution.y

                let projectionPlaneDestination = projectionPlaneTopLeft.add(
                    xDiff.mul(xRatio)).add(yDiff.mul(yRatio))
                let rayDir = projectionPlaneDestination.sub(cameraPos).normalized

                let [raycastResult, distance] = raycast(cameraPos, rayDir, {maxDist: cameraViewDistance})
                let color = colorFromVals(raycastResult, distance)
                displayColors[y][x] = color
            }
        }

        renderData()
    }

    function checkBlockCollison({f=field}={}) {
        let floored = cameraPos.floor()
        if (isOutOfBounds(floored)) return false
        return f[floored.x][floored.y][floored.z] != 0
    }

    let gameRunning = true

    function endGame() {
        gameRunning = false
        canvas.remove()
    }

    terminal.onInterrupt(endGame)

    let rotateSpeed = Math.PI / 128

    const movement = {
        FORWARD: () => cameraPos = cameraPos.add(cameraDir.mul(cameraSpeed)),
        BACKWARD: () => cameraPos = cameraPos.sub(cameraDir.mul(cameraSpeed)),
        LEFT: () => cameraPos = cameraPos.add(cameraDir.cross(new Vector3d(0, 0, 1)).mul(cameraSpeed)),
        RIGHT: () => cameraPos = cameraPos.sub(cameraDir.cross(new Vector3d(0, 0, 1)).mul(cameraSpeed)),
        UP: () => cameraPos = cameraPos.sub(new Vector3d(0, 0, 1).mul(cameraSpeed)),
        DOWN: () => cameraPos = cameraPos.add(new Vector3d(0, 0, 1).mul(cameraSpeed)),
        TURN_UP: () => cameraDir = cameraDir.rotateUp(-rotateSpeed),
        TURN_DOWN: () => cameraDir = cameraDir.rotateUp(rotateSpeed),
        TURN_LEFT: () => cameraDir = cameraDir.rotateZ(-rotateSpeed),
        TURN_RIGHT: () => cameraDir = cameraDir.rotateZ(rotateSpeed),
    }

    const antiKeyMappings = {
        FORWARD: "BACKWARD",
        BACKWARD: "FORWARD",
        LEFT: "RIGHT",
        RIGHT: "LEFT",
        UP: "DOWN",
        DOWN: "UP",
        TURN_LEFT: "TURN_RIGHT",
        TURN_RIGHT: "TURN_LEFT",
        TURN_UP: "TURN_DOWN",
        TURN_DOWN: "TURN_UP"
    }

    let keyDown = {
        FORWARD: false,
        BACKWARD: false,
        LEFT: false,
        RIGHT: false,
        UP: false,
        DOWN: false,
        TURN_LEFT: false,
        TURN_RIGHT: false,
        TURN_UP: false,
        TURN_DOWN: false
    }

    const keyMappings = {
        w: "FORWARD",
        s: "BACKWARD",
        a: "LEFT",
        d: "RIGHT",
        ArrowUp: "TURN_UP",
        ArrowDown: "TURN_DOWN",
        ArrowLeft: "TURN_LEFT",
        ArrowRight: "TURN_RIGHT",
        " ": "UP",
        Shift: "DOWN"
    }

    let upListener = addEventListener("keyup", function(event) {
        if (!gameRunning) return

        let keyCode = event.key
        if (keyCode in keyMappings) {
            keyDown[keyMappings[keyCode]] = false
            event.preventDefault()
        }
    })

    let downListener = addEventListener("keydown", function(event) {
        if (gameRunning && event.repeat) event.preventDefault()
        if (!gameRunning || event.repeat) return

        let keyCode = event.key
        if (keyCode in keyMappings) {
            let keyMapping = keyMappings[keyCode]
            keyDown[keyMapping] = true
            if (keyMapping in antiKeyMappings) {
                keyDown[antiKeyMappings[keyMapping]] = false
            }
            event.preventDefault()
        }
    })

    function processInput() {
        let prevPos = cameraPos.copy()

        for (let key in keyDown) {
            if (keyDown[key]) {
                movement[key]()
            }
        }

        if (checkBlockCollison()) {
            cameraPos = prevPos
        }
    }

    terminal.printLine("Use WASD to move, arrow keys to rotate, shift and space to move up and down")

    terminal.scroll()

    function loop() {
        processInput()
        render()

        terminal.window.requestAnimationFrame(loop)
    }

    loop()

    while (gameRunning) {
        await sleep(100)
    }

}, {
	description: "3d raycasting test",
    args: {
        "?fov:i:1~720": "Field of view in degrees",
        "?res=resolution:i:1~1000": "Resolution (width) in Pixels",
        "?x=roomX:i:5~100": "Room size in x direction",
        "?y=roomY:i:5~100": "Room size in y direction",
        "?z=roomZ:i:5~100": "Room size in z direction",
        "?v=viewDistance:i:1~9999": "View distance in blocks"
    },
    defaultValues: {
        fov: 90,
        resolution: 90,
        roomX: 30,
        roomY: 10,
        roomZ: 10,
        viewDistance: 13
    }
})

// ------------------- js/commands/brainfuck.js --------------------
terminal.addCommand("brainfuck", function(args) {
    const codeLib = {
        "test": "++++[>++++<-]>[>++++<-]",
        "helloworld": "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.",
    }

    class BrainFuckInterpreter {

        constructor(outFunc, inFunc) {
            this.outFunc = outFunc
            this.inFunc = inFunc
            this.instructionLimit = 1000000
        }

        interpret(code) {
            let memory = [0]
            let currPtr = 0
            let instructionCount = 0
            const val = () => memory[currPtr]
            let bracketsStack = Array()
            const syntaxFuncs = {
                "+": function() {
                    memory[currPtr]++
                    if (val() > 127)
                        memory[currPtr] = -128
                },
                "-": function() {
                    memory[currPtr]--
                    if (val() < -128)
                        memory[currPtr] = 127
                },
                ".": function() {
                    let char = String.fromCharCode(val())
                    if (char == "\n") {
                        terminal.addLineBreak()
                        return
                    }
                    this.outFunc(String.fromCharCode(val()))
                }.bind(this),
                ">": function() {
                    currPtr++
                    if (memory.length - 1 < currPtr) memory.push(0)
                },
                "<": () => currPtr = Math.max(0, currPtr - 1),
                "[": function(i, setI, jumpToLoopEnd) {
                    if (val() == 0) {
                        jumpToLoopEnd()
                    } else {
                        bracketsStack.push(i)
                    }
                },
                "]": function(i, setI) {
                    if (val() == 0) {
                        bracketsStack.pop()
                    } else {
                        setI(bracketsStack[bracketsStack.length - 1])
                    }
                }
            }
            
            for (let i = 0; i < code.length; i++) {
                let char = code[i]
                if (!Object.keys(syntaxFuncs).includes(char))
                    continue
                syntaxFuncs[char](i, newI => i = newI, function() {
                    let c = 1
                    while (c > 0 && i < code.length) {
                        if (code[i] == "[")
                            c++
                        if (code[i] == "]")
                            c--
                        i++
                    }
                })
                instructionCount++
                if (instructionCount > this.instructionLimit) {
                    this.outFunc(`Reached instruction-limit of ${this.instructionLimit}! Aborting...`)
                    break
                }
            }

            return memory
        }

    }

    let outputtedSomething = false

    let interpreter = new BrainFuckInterpreter(
        function(msg) {
            terminal.print(msg, Color.rgb(38, 255, 38))
            outputtedSomething = true
        }
    )

    let code = args.code
    if (Object.keys(codeLib).includes(code.toLowerCase())) {
        code = codeLib[code.toLowerCase()]
    }

    terminal.printLine("")
    let memoryResult = interpreter.interpret(code)

    function printMemory(memory) {
        let indexWidth = String(memory.length - 1).length
        let valueWidth = Math.max(String(Math.min(...memory)).length, String(Math.max(...memory)).length)
        let lineSep = `+-${stringMul("-", indexWidth)}-+-${stringMul("-", valueWidth)}-+`
        terminal.printLine(lineSep)
        for (let i = 0; i < memory.length; i++) {
            let indexStr = stringPad(String(i), indexWidth)
            let valueStr = stringPad(String(memory[i]), valueWidth)
            terminal.print("| ")
            terminal.print(indexStr, Color.COLOR_1)
            terminal.print(" | ")
            terminal.print(valueStr, Color.WHITE)
            terminal.printLine(" |")
            terminal.printLine(lineSep)
        }
    }

    if (outputtedSomething) {
        terminal.printLine("")
        terminal.printLine("")
    } else {
        terminal.printLine("Memory:")
    }
    printMemory(memoryResult)
}, {
    description: "parse given brainfuck code",
    args: ["*code"]
})

// ------------------- js/commands/cal.js --------------------
terminal.addCommand("cal", async function(args) {
    const today = new Date()

    const monthNames = [
        "January", "February", "March", "April", "May",
        "June", "July", "August", "September",
        "October", "November", "December"
    ]

    class PrintInstruction {

        constructor(text, color, backgroundColor) {
            this.text = text
            this.color = color
            this.backgroundColor = backgroundColor
        }
    
    }

    let tempPrintInstructions = []

    const monthsPerRow = 3
    const monthSideSpacing = 4

    function addPrint(text, color, backgroundColor) {
        tempPrintInstructions.push(new PrintInstruction(text, color, backgroundColor))
    }

    function executePrintInstructions(printInstructions) {
        for (let instruction of printInstructions) {
            if (instruction === undefined)
                continue
            terminal.print(instruction.text, instruction.color, {background: instruction.backgroundColor})
        }
    }

    function restructureInstructions(instructions) {
        let lines = []
        let tempLine = []
        for (let instruction of instructions) {
            if (instruction.text == "\n") {
                lines.push(tempLine)
                tempLine = []
            } else {
                tempLine.push(instruction)
            }
        }
        if (tempLine.length > 0)
            lines.push(tempLine)
        return lines
    }

    function combineMonthInstructions(monthInstructions) {
        let combinedInstructions = []
        if (monthInstructions.length !== 12)
            throw new Error("Invalid month instructions")

        for (let startMonth = 0; startMonth < 12; startMonth += monthsPerRow) {
            for (let lineIndex = 0; lineIndex < monthInstructions[0].length; lineIndex++) {
                for (let monthIndex = startMonth; monthIndex < startMonth + monthsPerRow; monthIndex++) {
                    combinedInstructions = combinedInstructions.concat(monthInstructions[monthIndex][lineIndex])
                    combinedInstructions.push(new PrintInstruction(" ".repeat(monthSideSpacing)))
                }
                combinedInstructions.push(new PrintInstruction("\n"))
            }
        }
        return combinedInstructions
    }

    Date.prototype.getRealDay = function() {
        return this.getDay() == 0 ? 6 : this.getDay() - 1
    }

    function printMonth(monthIndex, year) {
        tempPrintInstructions = []
        let tableData = Array.from(Array(6)).map(() => Array(7).fill("  "))
        let tableHeader = "Mo Tu We Th Fr Sa Su"
        let date = new Date()
        date.setFullYear(year, monthIndex, 1)
        let month = monthNames[date.getMonth()]
        let dayOfMonth = (new Date()).getDate()

        function printTable() {
            let headerText = `${month} ${stringPad(year, 4, "0")}`
            headerText = stringPadMiddle(headerText, tableHeader.length)
            addPrint(headerText, Color.COLOR_1)
            addPrint("\n")
            addPrint(tableHeader)
            addPrint("\n")
            for (let y = 0; y < 6; y++) {
                for (let x = 0; x < 7; x++) {
                    if (dayOfMonth == parseInt(tableData[y][x]) &&
                        today.getMonth() == monthIndex &&
                        today.getFullYear() == year) {
                        addPrint(tableData[y][x], Color.BLACK, Color.WHITE)
                    } else {
                        addPrint(tableData[y][x])
                    }
                    if (x < 7 - 1)
                        addPrint(" ")
                }
                addPrint("\n")
            }

            if (monthIndex < 12 - 1) {
                addPrint("\n")
            }
        }

        let weekIndex = 0
        for (let i = 1;; i++) {
            date.setDate(i)
            if (date.getMonth() != monthNames.indexOf(month)) {
                break
            }
            if (date.getRealDay() == 0) {
                weekIndex++
            }
            tableData[weekIndex][date.getRealDay()] = stringPad(String(i), 2)
        }

        printTable()
            
        return tempPrintInstructions
    }

    let chosenYear = null
    let chosenMonth = null

    argument_loop:
    for (let argument of Object.values(args).filter(i => i != undefined)) {
        for (let month of monthNames) {
            if (month.toLowerCase().startsWith(argument.toLowerCase())) {
                chosenMonth = monthNames.indexOf(month)
                continue argument_loop
            }
        }
        if (/^[0-9]{1,4}$/.test(argument)) {
            chosenYear = parseInt(argument)
        } else if (/^[0-9]{1,2}\.[0-9]{1,4}$/.test(argument)) {
            let [month, year] = argument.split(".")
            chosenMonth = parseInt(month) - 1
            chosenYear = parseInt(year)
        } else if (/^[0-9]{1,4}\.[0-9]{1,2}$/.test(argument)) {
            let [year, month] = argument.split(".")
            chosenMonth = parseInt(month) - 1
            chosenYear = parseInt(year)
        } else {
            throw new Error(`Invalid Month/Year "${argument}"`)
        }
    }

    if (chosenYear < 0) throw new Error("Cannot look past the year 0 - sorry")
    if (chosenYear > 9999) throw new Error("Cannot look past the year 9999 - sorry")
    if (chosenMonth > 11 || chosenMonth < 0)
        throw new Error("That month doesn't exist in this world.")

    if (chosenYear == null && chosenMonth == null) {
        chosenYear = today.getFullYear()
        chosenMonth = today.getMonth()
    }

    if (chosenMonth != null && chosenYear == null) {
        chosenYear = today.getFullYear()
    }

    if (chosenMonth == null) {
        let monthInstructions = []
        for (let month = 0; month < 12; month++) {
            let printInstructions = printMonth(month, chosenYear)
            let structuredInstructions = restructureInstructions(printInstructions)
            monthInstructions.push(structuredInstructions)
        }
        let combinedInstructions = combineMonthInstructions(monthInstructions)
        executePrintInstructions(combinedInstructions)
    } else {
        executePrintInstructions(printMonth(chosenMonth, chosenYear))
    }

}, {
    description: "print a calendar",
    args: {
        "?month": "the month to print",
        "?year": "the year to print"
    }
})



// ------------------- js/commands/cardoid.js --------------------
terminal.addCommand("cardoid", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../cardoid/",
        name: "Cardoid Generator",
        fullscreen: args.fullscreen
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "start a cardoid generator",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/cat.js --------------------
terminal.addCommand("cat", async function(args) {
    const specialCases = {
        "turtlo": "no, turtlo isn't a cat"
    }

    if (args.file in specialCases) {
        terminal.printLine(specialCases[args.file])
        return
    }

    let file = terminal.getFile(args.file)

    if (file.isDirectory) {
        throw new Error("Cannot read directory data")
    }

    if (args.file.name == "passwords.json") {
        let favoriteUrl = "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
        setTimeout(() => terminal.href(favoriteUrl), 1000)
    }

    if (!file.content)
        throw new Error("File is empty")

    if (file.type == FileType.DATA_URL) {
        terminal.printLine()
        terminal.printImg(file.content)
        terminal.printLine()
        return
    }

    const isUrl = str => {
        try {
            new URL(str)
            return true
        } catch {
            return false  
        }
    }

    if (isUrl(file.content)) {
        terminal.printLink(file.content)
    } else {
        terminal.printLine(file.content)
    }
}, {
    description: "print file content",
    args: {
        "file:f": "file to display the content of"
    }
})

// ------------------- js/commands/cd.js --------------------
terminal.addCommand("cd", function(args) {
    let targetDir = terminal.getFile(args.directory, FileType.DIRECTORY)
    terminal.fileSystem.currDirectory = targetDir
    terminal.updatePath()
}, {
    helpVisible: true,
    args: {
        "directory:f": "the directory relative to your current path"
    },
    description: "change current directory",
})

// ------------------- js/commands/ceasar.js --------------------
terminal.addCommand("ceasar", function(args) {
    let text = args.text
    let shiftVal = args.shift
    let alphabet = "abcdefghijklmnopqrstuvwxyz"
    function betterMod(n, m) {
        while (n < 0) n += m
        return n % m
    }
    for (let char of text.toLowerCase()) {
        let index = alphabet.indexOf(char)
        if (index == -1) {
            terminal.print(char)
            continue
        }
        let newChar = alphabet[betterMod((index + shiftVal), alphabet.length)]
        terminal.print(newChar)
    }
    terminal.printLine()
}, {
    description: "shift the letters of a text",
    args: {
        "text": "the text to shift",
        "?s=shift:i:-26~26": "the shift value"
    },
    standardVals: {
        shift: 1
    }
})



// ------------------- js/commands/changes.js --------------------
terminal.addCommand("changes", async function(args) {
    async function get(url) {
        return new Promise(async (resolve, reject) => {
            const result = await fetch(url)
            const json = await result.json()

            if (json.message.startsWith("API rate limit exceeded")) {
                reject(new Error("Github API rate limit exceeded"))
            }

            resolve(json)
        })
    }

    const branchesApiUrl = `https://api.github.com/repos/noel-friedrich/terminal/branches`
    const branches = await get(branchesApiUrl)

    const branch = branches.find(b => b.name == args.branch)
    if (!branch) {
        throw new Error(`Branch "${args.branch}" not found`)
    }

    terminal.printLine(`Showing changes to branch "${args.branch}"`, Color.COLOR_1)

    let nextCommitUrl = branch.commit.url
    for (let i = 0; i < args.limit && nextCommitUrl; i++) {
        const commitData = await get(nextCommitUrl)
        const stats = commitData.stats
        const date = new Date(commitData.commit.committer.date)
        const dateString = (
            date.getDate().toString().padStart(2, "0")
            + "." + (date.getMonth() + 1).toString().padStart(2, "0")
            + "." + (date.getFullYear()).toString()
        )
        terminal.print(`[${dateString}, +${stats.additions}, -${stats.deletions}] `)
        terminal.printLine(commitData.commit.message)
        nextCommitUrl = commitData.parents[0].url
    }
}, {
    description: "see latest changes to the terminal",
    args: {
        "?b=branch:s": "git branch to view changes of",
        "?l=limit:i:1~9999999": "number of changes to show"
    },
    defaultValues: {
        branch: "main",
        limit: 10
    },
    isSecret: true,
})

// ------------------- js/commands/cheese.js --------------------
terminal.addCommand("cheese", async function(args) {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
        throw new Error("Device does not support MediaDevices API")

    let stream = await navigator.mediaDevices.getUserMedia({video: true})
    let canvas = document.createElement("canvas")

    let context = canvas.getContext("2d")
    let video = document.createElement("video")
    video.srcObject = stream
    video.play()

    terminal.parentNode.appendChild(canvas)
    canvas.style.display = "none"

    await sleep(1000)

    canvas.width = video.videoWidth
    canvas.height = video.videoHeight

    if (Math.max(canvas.width, canvas.height) == 0) {
        throw new Error("Invalid image source")
    }

    context.fillRect(0, 0, canvas.width, canvas.height)
    context.drawImage(video, 0, 0, canvas.width, canvas.height)
    stream.getTracks().forEach(track => track.stop())

    let imgSource = canvas.toDataURL("image/png")

    terminal.printImg(imgSource, "cheese")
    terminal.addLineBreak()

}, {
    description: "take a foto with your webcam",
})



// ------------------- js/commands/chess.js --------------------
const PieceType = {
    ROOK: 'R',
    KNIGHT: 'N',
    BISHOP: 'B',
    QUEEN: 'Q',
    KING: 'K',
    PAWN: 'P',
    NONE: ' '
}

const ColorType = {
    WHITE: 'w',
    BLACK: 'b',
    NONE: '-'
}

const CastlingType = {
    KINGSIDE: 'K',
    QUEENSIDE: 'Q',
    NONE: '-'
}

const centerHeatmap = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 1, 2, 2, 1, 0, 0],
    [0, 0, 1, 2, 2, 1, 0, 0],
    [0, 0, 1, 1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
]

function oppositeColor(color) {
    if (color === ColorType.WHITE) {
        return ColorType.BLACK;
    } else if (color === ColorType.BLACK) {
        return ColorType.WHITE;
    } else {
        return ColorType.NONE;
    }
}

class Position {

    constructor(x, y) {
        this.x = x
        this.y = y
    }

    addX(x) {
        return new Position(this.x + x, this.y)
    }

    addY(y) {
        return new Position(this.x, this.y + y)
    }

    add(x, y) {
        return new Position(this.x + x, this.y + y)
    }

    addPos(pos) {
        return new Position(this.x + pos.x, this.y + pos.y)
    }

    toString() {
        const numbers = "87654321".split("")
        const letters = "abcdefgh".split("")
        return letters[this.x] + numbers[this.y]
    }

    equals(pos) {
        return this.x === pos.x && this.y === pos.y
    }

    diff(pos) {
        return Math.abs(this.x - pos.x) + Math.abs(this.y - pos.y)
    }

    copy() {
        return new Position(this.x, this.y)
    }

    static fromString(str) {
        const numbers = "87654321".split("")
        const letters = "abcdefgh".split("")
        return new Position(letters.indexOf(str[0]), numbers.indexOf(str[1]))
    }

}

class Move {
    
    constructor() {
        this.start = new Position(0, 0)
        this.end = new Position(0, 0)
        this.castling = null
        this.promotion = null
        this.enPassant = null
        this.activeEnPassant = null
        this.capture = false
    }

    setCastling(castling) {
        if (castling === undefined)
            console.error("castling is undefined")
        this.castling = castling
        return this
    }

    setPromotion(promotion) {
        this.promotion = promotion
        return this
    }

    setEnPassant(enPassant) {
        this.enPassant = enPassant
        return this 
    }

    setActiveEnPassant(activeEnPassant) {
        this.activeEnPassant = activeEnPassant
        return this
    }

    setStart(pos) {
        this.start.x = pos.x
        this.start.y = pos.y
        return this
    }

    setEnd(pos) {
        this.end.x = pos.x
        this.end.y = pos.y
        return this
    }

    static fromString(str) {
        let newMove = new Move()
        let positions = str.split("-").map(p => p.trim()) 
        newMove.start = Position.fromString(positions[0])  
        newMove.end = Position.fromString(positions[1])
        return newMove     
    }

    toString() {
        return `${this.start.toString()}_${this.end.toString()}`
    }

    equals(move) {
        return this.start.equals(move.start) && this.end.equals(move.end)
    }

}

class Piece {
        
    constructor(color, type) {
        this.color = color
        this.type = type
    }

    get value() {
        switch(this.type) {
            case PieceType.ROOK: return 5
            case PieceType.KNIGHT: return 3
            case PieceType.BISHOP: return 3
            case PieceType.QUEEN: return 9
            case PieceType.KING: return 100
            case PieceType.PAWN: return 1
            default: return 0
        }
    }

    toString() {
        if (this.color == ColorType.WHITE) {
            return this.type.toUpperCase()
        } else {
            return this.type.toLowerCase()
        }
    }

    get oppositeColor() {
        return oppositeColor(this.color)
    }

    getMoves() {
        return Array()
    }

}

class Pawn extends Piece {
    
    constructor(color) {
        super(color, PieceType.PAWN)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        let forward = (this.color == ColorType.WHITE) ? -1 : 1
        let startRank = (this.color == ColorType.WHITE) ? 6 : 1
        let endRank = (this.color == ColorType.WHITE) ? 0 : 7
        
        if (board.isFree(pos.addY(forward))) {
            allMoves.push(new Move().setStart(pos).setEnd(pos.addY(forward))
                .setPromotion((pos.y + forward == endRank) ? PieceType.QUEEN : null))
            if (pos.y == startRank && board.isFree(pos.addY(forward * 2))) {
                allMoves.push(new Move().setStart(pos).setEnd(pos.addY(forward * 2)).
                    setEnPassant(pos.addY(forward)))
            }
        }
        let frontLeft = pos.add(-1, forward)
        let frontLeftPiece = board.get(frontLeft)
        let frontRight = pos.add(1, forward)
        let frontRightPiece = board.get(frontRight)
        if (frontLeftPiece && ((frontLeftPiece.color == this.oppositeColor) || (board.enPassant && frontLeft.equals(board.enPassant)))) {
            allMoves.push(new Move().setStart(pos).setEnd(frontLeft)
            .setPromotion((pos.y + forward == endRank) ? PieceType.QUEEN : null))
            if (board.enPassant && frontLeft.equals(board.enPassant)) {
                allMoves[allMoves.length - 1].setActiveEnPassant(frontLeft)
            }
        }
        if (frontRightPiece && ((frontRightPiece.color == this.oppositeColor) || (board.enPassant && frontRight.equals(board.enPassant)))) {
            allMoves.push(new Move().setStart(pos).setEnd(frontRight)
            .setPromotion((pos.y + forward == endRank) ? PieceType.QUEEN : null))
            if (board.enPassant && frontRight.equals(board.enPassant)) {
                allMoves[allMoves.length - 1].setActiveEnPassant(frontRight)
            }
        }
        return allMoves
    }

}

class Rook extends Piece {

    constructor(color) {
        super(color, PieceType.ROOK)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        const directionVectors = [
            new Position(0, 1),
            new Position(0, -1),
            new Position(1, 0),
            new Position(-1, 0)
        ]
        for (let i = 0; i < directionVectors.length; i++) {
            let direction = directionVectors[i]
            let currentPos = pos.addPos(direction)
            while (board.isFree(currentPos)) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
                currentPos = currentPos.addPos(direction)
            }
            let currPiece = board.get(currentPos)
            if (currPiece && currPiece.color == this.oppositeColor) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
            }
        }
        return allMoves
    }

}

class Bishop extends Piece {
    
    constructor(color) {
        super(color, PieceType.BISHOP)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        const directionVectors = [
            new Position( 1, 1),
            new Position( 1,-1),
            new Position(-1, 1),
            new Position(-1,-1)
        ]
        for (let i = 0; i < directionVectors.length; i++) {
            let direction = directionVectors[i]
            let currentPos = pos.addPos(direction)
            while (board.isFree(currentPos)) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
                currentPos = currentPos.addPos(direction)
            }
            let currPiece = board.get(currentPos)
            if (currPiece && currPiece.color == this.oppositeColor) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
            }
        }
        return allMoves
    }

}

class Queen extends Piece {
    
    constructor(color) {
        super(color, PieceType.QUEEN)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        const directionVectors = [
            new Position( 1, 1),
            new Position( 1,-1),
            new Position(-1, 1),
            new Position(-1,-1),
            new Position( 0, 1),
            new Position( 0,-1),
            new Position( 1, 0),
            new Position(-1, 0)
        ]
        for (let i = 0; i < directionVectors.length; i++) {
            let direction = directionVectors[i]
            let currentPos = pos.addPos(direction)
            while (board.isFree(currentPos)) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
                currentPos = currentPos.addPos(direction)
            }
            let currPiece = board.get(currentPos)
            if (currPiece && currPiece.color == this.oppositeColor) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
            }
        }
        return allMoves
    }

}

class Knight extends Piece {

    constructor(color) {
        super(color, PieceType.KNIGHT)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        const directionVectors = [
            new Position( 1, 2),
            new Position( 2, 1),
            new Position(-1, 2),
            new Position(-2, 1),
            new Position( 1,-2),
            new Position( 2,-1),
            new Position(-1,-2),
            new Position(-2,-1)
        ]
        for (let i = 0; i < directionVectors.length; i++) {
            let direction = directionVectors[i]
            let currentPos = pos.addPos(direction)
            if (board.isFree(currentPos)) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
            } else {
                let currPiece = board.get(currentPos)
                if (currPiece && currPiece.color == this.oppositeColor) {
                    allMoves.push(new Move().setStart(pos).setEnd(currentPos))
                }
            }
        }
        return allMoves
    }

}

class King extends Piece {

    constructor(color) {
        super(color, PieceType.KING)
    }

    getMoves(board, pos) {
        let allMoves = Array()
        const directionVectors = [
            new Position( 1, 1),
            new Position( 1,-1),
            new Position(-1, 1),
            new Position(-1,-1),
            new Position( 0, 1),
            new Position( 0,-1),
            new Position( 1, 0),
            new Position(-1, 0)
        ]
        for (let i = 0; i < directionVectors.length; i++) {
            let direction = directionVectors[i]
            let currentPos = pos.addPos(direction)
            if (board.isFree(currentPos)) {
                allMoves.push(new Move().setStart(pos).setEnd(currentPos))
            } else {
                let currPiece = board.get(currentPos)
                if (currPiece && currPiece.color == this.oppositeColor) {
                    allMoves.push(new Move().setStart(pos).setEnd(currentPos))
                }
            }
        }
        if (board.castling[this.color][CastlingType.KINGSIDE]) {
            if (board.isFree(new Position(pos.x + 2, pos.y))) {
                if (board.isFree(new Position(pos.x + 1, pos.y))) {
                    allMoves.push(new Move()
                                        .setStart(pos)
                                        .setEnd(new Position(pos.x + 2, pos.y))
                                        .setCastling(CastlingType.KINGSIDE))
                }
            }
        }
        if (board.castling[this.color][CastlingType.QUEENSIDE]) {
            if (board.isFree(new Position(pos.x - 3, pos.y))) {
                if (board.isFree(new Position(pos.x - 2, pos.y))) {
                    if (board.isFree(new Position(pos.x - 1, pos.y))) {
                        allMoves.push(new Move()
                                            .setStart(pos)
                                            .setEnd(new Position(pos.x - 2, pos.y))
                                            .setCastling(CastlingType.QUEENSIDE))
                    }
                }
            }
        }
        return allMoves
    }

}

class ChessBoard {

    constructor(fenStr) {
        this.board = new Array(8)
        for (let i = 0; i < 8; i++) {
            this.board[i] = new Array(8)
            for (let j = 0; j < 8; j++) {
                this.board[i][j] = new Piece(ColorType.NONE, PieceType.NONE)
            }
        }

        this.castling = {
            [ColorType.WHITE]: {
                [CastlingType.KINGSIDE]: true,
                [CastlingType.QUEENSIDE]: true
            },
            [ColorType.BLACK]: {
                [CastlingType.KINGSIDE]: true,
                [CastlingType.QUEENSIDE]: true
            }
        }
        this.enPassant = null
        this.halfMoveClock = 0
        this.fullMoveClock = 1
        this.fen = fenStr
        this.computerColor = ColorType.BLACK
        this.LEGALMOVES = Object()
        this.PSEUDOLEGALMOVES = Object()
        this.whiteToMove = true
        this.parseFen(fenStr)
    }

    get playerColor() {
        return oppositeColor(this.computerColor)
    }

    isFree(pos) {
        let piece = this.get(pos)
        if (!piece) {
            return null
        }
        return piece.color == ColorType.NONE
    }

    get(pos) {
        if (pos.x < 0 || pos.x > 7 || pos.y < 0 || pos.y > 7) {
            return null
        }
        return this.board[pos.y][pos.x]
    }

    set(pos, piece) {
        this.board[pos.y][pos.x] = piece
    }

    getPsuedoLegalMoves(color) {
        if (this.PSEUDOLEGALMOVES[this.toFen() + color]) {
            return this.PSEUDOLEGALMOVES[this.toFen() + color]
        }
        let allMoves = Array()
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                let piece = this.board[i][j]
                if (piece.color == color) {
                    let moves = piece.getMoves(this, new Position(j, i))
                    allMoves = allMoves.concat(moves)
                }
            }
        }
        this.PSEUDOLEGALMOVES[this.toFen() + color] = allMoves
        return allMoves
    }

    makeMove(move) {
        this.whiteToMove = !this.whiteToMove
        let moveInfo = {
            startPiece: this.get(move.start),
            endPiece: this.get(move.end),
            extraMove: null,
            extraMoveStart: null,
            extraMoveEnd: null,
            prevEnPassant: (this.enPassant) ? this.enPassant.copy() : null,
            removedPiece: null,
            removedPiecepos: null,
            prevCastling: {
                [ColorType.WHITE]: {
                    [CastlingType.KINGSIDE]: this.castling[ColorType.WHITE][CastlingType.KINGSIDE],
                    [CastlingType.QUEENSIDE]: this.castling[ColorType.WHITE][CastlingType.QUEENSIDE]
                },
                [ColorType.BLACK]: {
                    [CastlingType.KINGSIDE]: this.castling[ColorType.BLACK][CastlingType.KINGSIDE],
                    [CastlingType.QUEENSIDE]: this.castling[ColorType.BLACK][CastlingType.QUEENSIDE]
                }
            }
        }
        let piece = this.get(move.start)
        this.set(move.start, new Piece(ColorType.NONE, PieceType.NONE))
        this.set(move.end, piece)

        if (move.castling) {
            if (move.castling == CastlingType.KINGSIDE) {
                moveInfo.extraMove = new Move().setStart(move.end.addX(1)).setEnd(move.end.addX(-1))
                moveInfo.extraMoveStart = this.get(move.end.addX(1))
                moveInfo.extraMoveEnd = this.get(move.end.addX(-1))
                this.set(move.end.addX(-1), this.get(move.end.addX(1)))
                this.set(move.end.addX(1), new Piece(ColorType.NONE, PieceType.NONE))
            } else if (move.castling == CastlingType.QUEENSIDE) {
                moveInfo.extraMove = new Move().setStart(move.end.addX(-2)).setEnd(move.end.addX(1))
                moveInfo.extraMoveStart = this.get(move.end.addX(-2))
                moveInfo.extraMoveEnd = this.get(move.end.addX(1))
                this.set(move.end.addX(1), this.get(move.end.addX(-2)))
                this.set(move.end.addX(-2), new Piece(ColorType.NONE, PieceType.NONE))
            }
        }

        if (move.promotion) {
            this.set(move.end, new Queen(piece.color))
        }

        if (move.activeEnPassant) {
            let forward = (piece.color == ColorType.WHITE) ? 1 : -1
            moveInfo.removedPiece = this.get(move.end.addY(forward))
            this.set(move.end.addY(forward), new Piece(ColorType.NONE, PieceType.NONE))
            moveInfo.removedPiecepos = move.end.addY(forward)
        }

        if (this.enPassant) {
            this.enPassant = null
        }

        if (move.enPassant) {
            this.enPassant = move.enPassant
        }

        if (piece.type == PieceType.KING) {
            this.castling[piece.color][CastlingType.KINGSIDE] = false
            this.castling[piece.color][CastlingType.QUEENSIDE] = false
        }

        if (piece.type == PieceType.ROOK) {
            if (move.start.x == 0) {
                this.castling[piece.color][CastlingType.QUEENSIDE] = false
            } else if (move.start.x == 7) {
                this.castling[piece.color][CastlingType.KINGSIDE] = false
            }
        }

        return moveInfo
    }

    unmakeMove(move, moveInfo) {
        this.whiteToMove = !this.whiteToMove
        this.set(move.start, moveInfo.startPiece)
        this.set(move.end, moveInfo.endPiece)

        this.castling = moveInfo.prevCastling
        this.enPassant = moveInfo.prevEnPassant

        if (move.castling) {
            this.set(moveInfo.extraMove.start, moveInfo.extraMoveStart)
            this.set(moveInfo.extraMove.end, moveInfo.extraMoveEnd)
        }

        if (move.activeEnPassant) {
            this.set(moveInfo.removedPiecepos, moveInfo.removedPiece)
        }
    }

    isCheck(chosenColor=null) {
        let color = (chosenColor) ? chosenColor : (this.whiteToMove ? ColorType.BLACK : ColorType.WHITE)
        let moves = this.getPsuedoLegalMoves(oppositeColor(color))
        for (let i = 0; i < moves.length; i++) {
            let endPos = this.get(moves[i].end)
            if (endPos.color == color && endPos.type == PieceType.KING) {
                return true
            }
        }
        return false
    }

    generateMoves(color) {
        if (this.LEGALMOVES[this.toFen() + color]) {
            return this.LEGALMOVES[this.toFen() + color]
        }
        let allMoves = Array()
        for (let move of this.getPsuedoLegalMoves(color)) {
            let moveInfo = this.makeMove(move)
            if (!this.isCheck()) {
                allMoves.push(move)
            }
            this.unmakeMove(move, moveInfo)
        }
        this.LEGALMOVES[this.toFen() + color] = allMoves
        return allMoves
    }

    parseFen(fenStr) {
        function pieceFromChar(char) {
            switch (char) {
                case 'P': return new Pawn(ColorType.WHITE)
                case 'N': return new Knight(ColorType.WHITE)
                case 'B': return new Bishop(ColorType.WHITE)
                case 'R': return new Rook(ColorType.WHITE)
                case 'Q': return new Queen(ColorType.WHITE)
                case 'K': return new King(ColorType.WHITE)
                case 'p': return new Pawn(ColorType.BLACK)
                case 'n': return new Knight(ColorType.BLACK)
                case 'b': return new Bishop(ColorType.BLACK)
                case 'r': return new Rook(ColorType.BLACK)
                case 'q': return new Queen(ColorType.BLACK)
                case 'k': return new King(ColorType.BLACK)
                default: return new Piece(ColorType.NONE, PieceType.NONE)
            }
        }
        let split = fenStr.split(' ')
        let fenPieces = {
            piecePos: split[0],
            color: split[1],
            castle: split[2],
            enPassant: split[3],
            halfMoveClock: split[4],
            fullMoveClock: split[5]
        }

        let currPos = new Position(0, 0)
        for (let char of fenPieces.piecePos) {
            let piece = pieceFromChar(char)
            if (piece.color == ColorType.NONE && String(char).match(/[1-8]/)) {
                currPos.x += parseInt(char)
            } else if (piece.color == ColorType.NONE && char == '/') {
                currPos.x = 0
                currPos.y++
            } else {
                this.set(currPos, piece)
                currPos.x++
            }
        }

        this.whiteToMove = fenPieces.color == "w"
        this.castling = {
            [ColorType.WHITE]: {
                [CastlingType.KINGSIDE]: (fenPieces.castle.indexOf('K') != -1),
                [CastlingType.QUEENSIDE]: (fenPieces.castle.indexOf('Q') != -1)
            },
            [ColorType.BLACK]: {
                [CastlingType.KINGSIDE]: (fenPieces.castle.indexOf('k') != -1),
                [CastlingType.QUEENSIDE]: (fenPieces.castle.indexOf('q') != -1)
            }
        }
        if (fenPieces.enPassant != "-")
            this.enPassant = Position.fromString(fenPieces.enPassant)
        this.halfMoveClock = parseInt(fenPieces.halfMoveClock)
        this.fullMoveClock = parseInt(fenPieces.fullMoveClock)
    }

    toNiceString() {
        let alphabet = "87654321"
        let lineString = "  +---+---+---+---+---+---+---+---+\n"
        for (let i = 0; i < 8; i++) {
            lineString += alphabet[i] + " | "
            for (let j = 0; j < 8; j++) {
                lineString += this.board[i][j].toString() + " | "
            }
            if (i != 7) {
                lineString += "\n  +---+---+---+---+---+---+---+---+\n"
            } else {
                lineString += "\n  +---+---+---+---+---+---+---+---+\n"
            }
        }
        lineString += "    a   b   c   d   e   f   g   h \n"
        return lineString
    }

    purePieceEvaluation() {
        let whiteScore = 0
        let blackScore = 0
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                let piece = this.board[i][j]
                if (piece.color == ColorType.WHITE) {
                    whiteScore += piece.value
                } else if (piece.color == ColorType.BLACK) {
                    blackScore += piece.value
                }
            }
        }
        return (whiteScore - blackScore) * (this.whiteToMove ? 1 : -1)
    }

    castlingEvaluation() {
        let whiteScore = 0
        if (this.castling[ColorType.WHITE][CastlingType.KINGSIDE]) {
            whiteScore += 1
        }
        if (this.castling[ColorType.WHITE][CastlingType.QUEENSIDE]) {
            whiteScore += 1
        }
        if (this.castling[ColorType.BLACK][CastlingType.KINGSIDE]) {
            whiteScore -= 1
        }
        if (this.castling[ColorType.BLACK][CastlingType.QUEENSIDE]) {
            whiteScore -= 1
        }
        return whiteScore * (this.whiteToMove ? 1 : -1)
    }

    enPassantEvaluation() {
        let whiteScore = 0
        if (this.enPassant) {
            whiteScore += 1
        }
        return whiteScore * (this.whiteToMove ? 1 : -1)
    }

    centerControlEvaluation() {
        let whiteScore = 0
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                let piece = this.board[i][j]
                if (piece.color == ColorType.WHITE) {
                    whiteScore += centerHeatmap[i][j]
                }
            }
        }
        return whiteScore * (this.whiteToMove ? 1 : -1)
    }

    getKingPosition(color) {
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                let piece = this.board[i][j]
                if (piece.color == color && piece.type == PieceType.KING) {
                    return new Position(j, i)
                }
            }
        }
        return null
    }

    evaluate() {
        let evaluation = this.purePieceEvaluation() * 100
        evaluation += this.castlingEvaluation() * 10 // max 20
        evaluation +=  this.enPassantEvaluation() * 10 // max 10
        evaluation += this.centerControlEvaluation() * 10 // max 20
        return evaluation
    }

    get movingColor() {
        return this.whiteToMove ? ColorType.WHITE : ColorType.BLACK
    }

    calcMove(depth, alpha=-Infinity) {
        if (depth == 0) {
            return {
                score: this.evaluate(),
                move: null
            }
        }

        let moves = this.generateMoves(this.movingColor)
        let bestMove = null
        if (moves.length == 0) {
            if (this.isCheck()) {
                return {
                    score: -Infinity,
                    move: null
                }
            }
            return {
                score: 0,
                move: null
            }
        }
        for (let move of moves) {
            let moveInfo = this.makeMove(move)
            let score = -this.calcMove(depth - 1).score
            this.unmakeMove(move, moveInfo)
            if (score > alpha || (score == alpha && bestMove == null)) {
                alpha = score
                bestMove = move
            }
        }
        return {
            move: bestMove,
            score: alpha
        }
    }

    toFen() {
        let tempCount = 0
        let outStr = ""
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                let currPos = new Position(j, i)
                if (this.isFree(currPos)) {
                    tempCount++
                } else {
                    if (tempCount > 0) {
                        outStr += tempCount.toString()
                        tempCount = 0
                    }
                    let piece = this.get(currPos)
                    outStr += piece.toString()
                }
            }
            if (tempCount > 0) {
                outStr += tempCount.toString()
                tempCount = 0
            }
            outStr += "/"
        }
        outStr = outStr.slice(0, -1) + " "
        outStr += this.whiteToMove ? "w " : "b "
        let castleString = ""
        if (this.castling[ColorType.WHITE][CastlingType.KINGSIDE]) {
            castleString += "K"
        }
        if (this.castling[ColorType.WHITE][CastlingType.QUEENSIDE]) {
            castleString += "Q"
        }
        if (this.castling[ColorType.BLACK][CastlingType.KINGSIDE]) {
            castleString += "k"
        }
        if (this.castling[ColorType.BLACK][CastlingType.QUEENSIDE]) {
            castleString += "q"
        }
        if (castleString == "") {
            castleString = "-"
        }
        outStr += `${castleString} `
        if (this.enPassant) {
            outStr += this.enPassant.toString()
        } else {
            outStr += "-"
        }
        outStr += ` ${this.halfMoveClock} ${this.fullMoveClock}`
        return outStr
    }

}

terminal.addCommand("chess", async function() {
    let board = new ChessBoard("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")

    function makeComputerMove() {
        let bestMove = board.calcMove(3)
        if (!bestMove.move) {
            terminal.printLine("Checkmate!")
            return
        }
        board.makeMove(bestMove.move)
    }

    async function printClickableBoard(board, {selectedPosition=null, resolveDelete=false}) {
        const horizontalSeperator = "+---+---+---+---+---+---+---+---+"

        const markSquares = []
        if (selectedPosition) {
            const legalMoves = board.generateMoves(board.playerColor)
            for (const move of legalMoves) {
                if (move.start.equals(selectedPosition)) {
                    markSquares.push(move.end)
                }
            }
        }

        return new Promise(resolve => {
            const elements = []
            elements.push(terminal.printLine(horizontalSeperator, undefined, {forceElement: true}))
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    if (j == 0) {
                        elements.push(terminal.print("|", undefined, {forceElement: true}))
                    }

                    const currPosition = new Position(j, i)

                    const isMarked = markSquares.some(p => currPosition.equals(p))
                    const squareElement = terminal.print(
                        isMarked ? `<${board.board[i][j]}>` : ` ${board.board[i][j]} `,
                        undefined, {forceElement: true}
                    )

                    elements.push(terminal.print("|", undefined, {forceElement: true}))
    
                    if (!resolveDelete) {
                        squareElement.style.cursor = "pointer"
                        squareElement.addEventListener("click", () => {
                            for (const element of elements) {
                                element.remove()
                            }
                            resolve(currPosition)
                        })
                    }

                    elements.push(squareElement)
                }
                elements.push(terminal.printLine(`\n${horizontalSeperator}`, undefined, {forceElement: true}))

                if (resolveDelete) {
                    resolve(() => {
                        for (const element of elements) {
                            element.remove()
                        }
                    })
                }
            }
        })
    }

    async function getPlayerMove(board) {
        let selectedPosition = null
        const legalMoves = board.generateMoves(board.playerColor)

        while (true) {
            let newPosition = await printClickableBoard(board, {selectedPosition})

            if (selectedPosition) {
                const proposedMove = new Move().setStart(selectedPosition).setEnd(newPosition)
                if (legalMoves.some(m => proposedMove.equals(m))) {
                    return proposedMove
                }
            }

            selectedPosition = newPosition
        }
    }

    while (board.generateMoves(board.movingColor).length != 0) {
        const playerMove = await getPlayerMove(board)
        board.makeMove(playerMove)
        const removeBoard = await printClickableBoard(board, {resolveDelete: true})
        await sleep(10)
        makeComputerMove()
        removeBoard()
    }
    
}, {
    description: "play a game of chess against the computer",
    isGame: true
})

// ------------------- js/commands/clear.js --------------------
terminal.addCommand("clear", async function() {
    terminal.clear(true)
}, {
    description: "clear the terminal"
})

// ------------------- js/commands/clock.js --------------------
terminal.addCommand("clock", async function(args) {
    let displayMillis = !!args.m
    let gridSize = {
        x: 20*1.9,
        y: 20
    }
    let grid = Array.from(Array(gridSize.y)).map(() => Array(gridSize.x).fill(" "))
    let containerDiv = null
    function printGrid() {
        const customColors = {
            "x": Color.COLOR_1,
            "#": Color.WHITE,
            "w": Color.ORANGE,
            ".": Color.rgb(50, 50, 50),
            "o": Color.LIGHT_GREEN,
            "s": Color.hex("a4a4c7")
        }
        let prevContainerDiv = containerDiv
        let tempNode = terminal.parentNode
        terminal.parentNode = document.createElement("div")
        containerDiv = terminal.parentNode
        tempNode.appendChild(containerDiv)
        terminal.printLine()
        for (let row of grid) {
            for (let item of row) {
                if (Object.keys(customColors).includes(item)) {
                    terminal.print(item, customColors[item])
                } else {
                    terminal.print(item)
                }
            }
            terminal.printLine()
        }
        if (prevContainerDiv) prevContainerDiv.remove()
        terminal.parentNode = tempNode
    }
    function drawIntoGrid(x, y, v) {
        let gridX = Math.round((x - -1) / (1 - -1) * (gridSize.x - 1))
        let gridY = Math.round((y - -1) / (1 - -1) * (gridSize.y - 1))
        if (gridX < 0 || gridX >= gridSize.x || gridY < 0 || gridY >= gridSize.y) {
            return
        }
        grid[gridSize.y - 1 - gridY][gridX] = v
    }
    function drawCircle(val, radius=1) {
        for (let t = 0; t < Math.PI * 2; t += 0.01) {
            let x = Math.sin(t) * radius
            let y = Math.cos(t) * radius
            drawIntoGrid(x, y, val)
        }
    }
    function drawLine(angle, val, maxVal=1) {
        for (let t = 0; t < maxVal; t += 0.01) {
            let x = Math.sin(angle * Math.PI * 2) * t
            let y = Math.cos(angle * Math.PI * 2) * t
            drawIntoGrid(x, y, val)
        }
    }
    function update() {
        let date = new Date()
        let mins = date.getHours() * 60 + date.getMinutes()
        for (let r = 0; r < 1; r += 0.05) {
            drawCircle(".", r)
        }
        drawCircle("#")
        if (displayMillis)
            drawLine(date.getMilliseconds() / 1000, "s", 0.9)
        drawLine((mins % 720) / 720, "w", 0.75)
        drawLine(date.getMinutes() / 60, "x", 0.9)
        drawLine(date.getSeconds() / 60, "o", 0.9)
        printGrid()
        terminal.scroll("auto")
    }
    while (true) {
        update()
        await sleep(displayMillis ? 40 : 1000)
    }
}, {
    description: "display a clock",
    args: {
        "?m=millis:b": "display milliseconds"
    }
})



// ------------------- js/commands/cmatrix.js --------------------
terminal.addCommand("cmatrix", async function(args) {
    function makeCMatrix(makeWindow) {
        const terminalWindow = makeWindow({name: "CMatrix", fullscreen: !args.nf})
        const CANVAS = terminalWindow.CANVAS
        const CONTEXT = terminalWindow.CONTEXT
    
        let CHARWIDTH = CONTEXT.measureText("A").width * 1.8
    
        function drawChar(x, y, char, color="lime") {
            CONTEXT.fillStyle = "black"
            CONTEXT.clearRect(x - 1, y - 1, CHARWIDTH + 1, 22)
            CONTEXT.fillStyle = color
            CONTEXT.fillText(char, x, y)
        }
    
        function randomChar() {
            const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"'!@#$%^&*()_+-=[]{}|;:<>?,./\\"
            return chars.charAt(Math.floor(Math.random() * chars.length))
        }
    
        let snakePos = []
        let snakeTypes = []
    
        function updateSnakes() {
            for (let i = 0; i < snakePos.length; i++) {
                if (!snakePos[i]) continue
                let c = snakeTypes[i] ? " " : randomChar()
                if (!snakeTypes[i])
                    drawChar(snakePos[i][0], snakePos[i][1] + 25, c, "white")
                drawChar(snakePos[i][0], snakePos[i][1], c)
                snakePos[i][1] += 20
                if (snakePos[i][1] > CANVAS.height) {
                    snakePos.splice(i, 1)
                    snakeTypes.splice(i, 1)
                    i--
                }
            }
        }
    
        function addSnake() {
            let maxX = parseInt(CANVAS.width / CHARWIDTH)
            let x = Math.floor(Math.random() * maxX) * CHARWIDTH
            snakePos.push([x, 0])
            snakeTypes.push(Math.random() < 0.5)
        }
        
        let intervalFunc = setInterval(function() {
            updateSnakes()
            let rndm = Math.random() * 10
            for (let i = 0; i < rndm; i++) {
                addSnake()
            }
        }, 30)
    
        return [terminalWindow, intervalFunc]
    }

    await terminal.modules.load("window", terminal)
    let [terminalWindow, intervalFunc] = makeCMatrix(terminal.modules.window.make)
    let stopped = false
    terminal.onInterrupt(() => {
        clearInterval(intervalFunc)
        terminalWindow.close()
        stopped = true
    })
    while (!stopped)
        await sleep(100)
}, {
    description: "show the matrix",
    args: {
        "?nf=not-fullscreen:b": "make the window fullscreen"
    }
})



// ------------------- js/commands/cmdnotfound.js --------------------
terminal.addCommand("cmdnotfound", async function(commandName, tokens) {
    const commandArgs = tokens[2]

    let commandNames = Object.keys(terminal.commandData)
    let distances = Object.fromEntries(commandNames.map(name => [name, levenshteinDistance(commandName, name)]))
    let bestMatch = commandNames.reduce((a, b) => distances[a] < distances[b] ? a : b)

    terminal.printLine(`command not found: ${commandName}`)

    if (distances[bestMatch] <= 2) {
        terminal.print("did you mean: ")
        terminal.printCommand(`${bestMatch}${commandArgs}`, `${bestMatch}${commandArgs}`)
    }
}, {
    description: "display that a command was not found",
    rawArgMode: true,
    isSecret: true
})

// ------------------- js/commands/code.js --------------------
const jsKeywords = [
    "abstract", "arguments", "await*", "boolean",
    "break", "byte", "case", "catch",
    "class*", "const", "continue",
    "debugger", "default", "delete", "do",
    "double", "else", "enum*", "eval",
    "export*", "extends*", "false", "final",
    "finally", "float", "for", "function",
    "goto", "if", "implements", "import*",
    "in", "instanceof", "int", "interface",
    "let*", "long", "native", "new",
    "null", "package", "private", "protected",
    "public", "return", "short", "static",
    "super*", "switch", "synchronized", "this",
    "throw", "throws", "transient", "true",
    "try", "typeof", "var", "void",
    "volatile", "while", "with", "yield",
    "abstract", "boolean", "byte",
    "double", "final", "float", "goto",
    "int", "long", "native", "short",
    "synchronized", "throws", "transient", "volatile",
    "Array", "Date", "eval", "function",
    "hasOwnProperty", "Infinity", "isFinite", "isNaN",
    "isPrototypeOf", "length", "Math", "NaN",
    "name", "Number", "Object", "prototype",
    "String", "toString", "undefined", "valueOf",
    "let", "yield", "enum", "await",
    "implements", "package", "protected", "static",
    "interface", "private", "public",
    "null", "true", "false",
    "var", "let", "const", "function",
]

const structureTokens = [
    "if", "(", ")", "{", "}",
    "[", "]", "yield", "await", "for", "while",
    "do", "switch", "case", "default", "try",
    "catch", "finally", "class", "extends",
    "implements", "interface", "package",
    "private", "protected", "public", "static",
    "import", "export", "from", "as", "return",
    "break", "continue", "debugger", "delete",
    "in", "instanceof", "new", "typeof", "void",
    "with", "super", "this", "throw", "throws",
    "else", "of"
]

const specialWords = [
    "terminal"
]

const jsSymbols = [
    "{", "}", "(", ")", "[", "]",
    ".", ";", ",", "<", ">", "=",
    "+", "-", "*", "%", "&", "|",
    "^", "!", "~", "?", ":", "/",
    "\\", "&&", "||", "++", "--", "<<",
    ">>", ">>>", "<=", ">=", "==", "!=",
    "===", "!==", "+=", "-=", "*=", "%=",
    "<<=", ">>=", ">>>=", "&=", "^=", "|=",
    "=>", "...",
]

const cat = `                        _
                       | \\
                       | |
                       | |
  |\\                   | |
 /, ~\\                / /
X     \`-.....-------./ /
 ~-.                   |
    \\                 /
    \\  /_     ~~~\\   /
     | /\\ ~~~~~   \\ |
     | | \\        || |
     | |\\ \\       || )
     (_/ (_/      ((_/`

terminal.addCommand("code", async function(args) {
    // https://github.com/noel-friedrich/terminal/issues/6
    if (args.command == "cat") {
        terminal.printEasterEgg("Cat-Egg")
        return terminal.printLine(cat)
    }

    function printJSCode(rawCode) {
        const isLetter = char => /[a-zA-Z]/.test(char)
        const isApostrophe = char => RegExp("['\"`]").test(char)
        const isNumber = text => !isNaN(parseInt(text))
        const isClass = text => isLetter(text[0]) && text[0] == text[0].toUpperCase()

        function tokenize(text) {
            let tokens = []
            let tempToken = ""
            for (let char of text) {
                if (isLetter(char)) {
                    tempToken += char
                } else {
                    if (tempToken != "") {
                        tokens.push(tempToken)
                        tempToken = ""
                    }
                    tokens.push(char)
                }
            }
            if (tempToken != "")
                tokens.push(tempToken)
            return tokens.map(token => [token, Color.WHITE])
        }

        let tokenColors = tokenize(rawCode)

        const commentColor = Color.hex("#F7AEF8")
        const stringColor = Color.hex("#B388EB")
        const keywordColor = Color.hex("#8093F1")
        const numberColor = Color.hex("#72DDF7")
        const symbolColor = Color.hex("#96E6B3")
        const specialColor = Color.hex("#D36060")
        const structureColor = Color.hex("#DBD3AD")
        const classColor = Color.hex("#F6C177")

        let inApostrophe = false
        let inLineComment = false
        let i = 0
        for (let [token, color] of tokenColors) {
            if (isNumber(token))
                color = numberColor
            if (jsKeywords.includes(token))
                color = keywordColor
            if (jsSymbols.includes(token))
                color = symbolColor
            if (specialWords.includes(token))
                color = specialColor
            if (structureTokens.includes(token))
                color = structureColor
            if (isClass(token))
                color = classColor

            let prevToken = (tokenColors[i - 1] ?? ["", Color.WHITE])[0]
            let prevTokenIsBlocker = prevToken == "\\"
            
            if (isApostrophe(token) && !inApostrophe && !prevTokenIsBlocker) {
                inApostrophe = token
                color = stringColor
            } else if (token === inApostrophe && !prevTokenIsBlocker) {
                inApostrophe = false
                color = stringColor
            } else if (inApostrophe) {
                color = stringColor
            }

            let nextToken = (tokenColors[i + 1] ?? ["", Color.WHITE])[0]
            if (token == "/" && nextToken == "/" && !inApostrophe) {
                inLineComment = true
                color = commentColor
            } else if (token == "\n" && inLineComment) {
                inLineComment = false
                color = commentColor
            } else if (inLineComment) {
                color = commentColor
            }

            if (token == "\n") {
                inApostrophe = false
                inLineComment = false
            }

            // consider this an easteregg
            // congrats if you found it

            terminal.print(token, color)
            i++
        }
    }

    if (args.command) {
        let command = await terminal.getCommand(args.command)
        let code = command.callback.toString()
    
        printJSCode(code)
    
        printJSCode(", " + JSON.stringify(command.info, null, 4))
        terminal.addLineBreak()
    
        if (args.command == "code") {
            terminal.printEasterEgg("Codeception-Egg")
        }
    } else if (args.string) {
        printJSCode(args.string)
        terminal.addLineBreak()
    } else {
        throw new Error("Must provide either command or string to print")
    }
}, {
    description: "show the source code of a command",
    args: {
        "?c=command:c": "the command to show the source code of",
        "?s=string:s": "print a highlighted string"
    }
})

// ------------------- js/commands/collatz.js --------------------
terminal.addCommand("collatz", async function(args) {
	function* collatz(n) {	
		while (n != 1) {
			yield n
			if (n % 2n === 0n) {
				n >>= 1n
			} else {
				n = n * 3n + 1n
			}
		}
		yield 1n
	}

	if (args.n < 1n) {
		throw new Error("Number must not be below 1")
	}
	
	if (!args.visualize) {
		let count = 0
		for (const n of collatz(args.n)) {
			terminal.printLine(n)
			count++
		}
		terminal.printLine(`\n(${count} step` + (count == 1 ? "" : "s") + ")")
		return
	}

	await terminal.modules.import("statistics", window)

	const canvas = document.createElement("canvas")
    canvas.width = 640
    canvas.height = 400
    const context = canvas.getContext("2d")
    terminal.parentNode.appendChild(canvas)
    terminal.scroll()

	const numbers = new Dataset([])
	for (const n of collatz(args.n)) {
		if (args["log-scale"]) {
			numbers.addNumber(Math.log(parseInt(n)))
		} else {
			numbers.addNumber(parseInt(n))
		}
		
		numbers.lineplot(context, {
			backgroundColor: terminal.data.background.toString(),
			color: terminal.data.foreground.toString(),
			arrowSize: 5
		}, {
			color: terminal.data.foreground.toString(),
			displayPoints: true
		})
		await sleep(10)
	}
	
	terminal.printLine(`\n${numbers.length} steps to reach 1`)
}, {
	description: "Calculate the Collatz Sequence (3x+1) for a given Number",
	args: {
		"n:bn": "the starting number of the sequence",
		"?v=visualize:b": "visualize the numbers as a graph",
		"?l=log-scale:b": "use a logarithmic scale to graph the numbers"
	},
})

// ------------------- js/commands/color-test.js --------------------
terminal.addCommand("color-test", function(args) {
    let size = {x: args.size*2, y: args.size}
    for (let i = 0; i < size.y; i++) {
        for (let j = 0; j < size.x; j++) {
            let x = (j / size.x - 0.5) * 2
            let y = (i / size.y - 0.5) * 2
            if (x*x + y*y > 1) {
                terminal.print(" ")
            } else {
                let angle = Math.atan2(y, x) / Math.PI * 180
                let hue = Math.round(angle)
                let lightness = Math.round(90 - (x*x + y*y) * 90)
                terminal.print("#", Color.hsl(hue / 360, 1, lightness / 100))
            }
        }
        terminal.printLine()
    }
}, {
    description: "test the color capabilities of the terminal",
    args: {
        "?size:i:1~999": "the size of the test image"
    },
    defaultValues: {
        size: 60
    }
})

// ------------------- js/commands/compliment.js --------------------
terminal.addCommand("compliment", function() {
    function startsWithVowel(word) {
        return (
            word.startsWith("a")
            || word.startsWith("e")
            || word.startsWith("i")
            || word.startsWith("o")
            || word.startsWith("u")
        )
    }

    const adjectives = [
        "cool", "fresh", "awesome", "beautiful",
        "fantastic", "good", "wonderful", "colorful"
    ], nouns = [
        "queen", "goddess", "person", "king",
        "god", "human", "princess", "prince"
    ], sentences = [
        "you are a<n> <adjective> <noun>. happy to have you here!",
        "a<n> <adjective> <noun>. that's what you are!",
        "you, <noun>, are <adjective>!",
        "i'm going to call you <noun>, because you are <adjective>"
    ], choice = l => l[Math.floor(Math.random() * l.length)]

    let sentence = choice(sentences)
    let lastAdjective = choice(adjectives)
    while (/.*<(?:adjective|n|noun)>.*/.test(sentence)) {
        sentence = sentence.replace(/<n>/, startsWithVowel(lastAdjective) ? "n": "")
        sentence = sentence.replace(/<adjective>/, lastAdjective)
        sentence = sentence.replace(/<noun>/, choice(nouns))
        lastAdjective = choice(adjectives)
    }
    terminal.printLine(sentence)
}, {
    description: "get info about yourself"
})



// ------------------- js/commands/config.js --------------------
terminal.addCommand("config", async function(args) {
    const properties = [
        {
            id: "foreground",
            name: "Foreground Color",
            value: () => terminal.data.foreground.string.hex,
            prettyValue: () => terminal.data.foreground.toString(),
            edit: v => terminal.data.foreground = v,
            reset: () => terminal.data.resetProperty("foreground"),
            regex: /^#[0-9a-f]{6}$/,
            unitComment: "in hex"
        },
        {
            id: "background",
            name: "Background Color",
            value: () => terminal.data.background.string.hex,
            prettyValue: () => terminal.data.background.toString(),
            edit: v => terminal.data.background = v,
            reset: () => terminal.data.resetProperty("background"),
            regex: /^#[0-9a-f]{6}$/,
            unitComment: "in hex"
        },
        {
            id: "font",
            name: "Terminal Font",
            info: "Unknown fonts will be replaced by the browser's default font.",
            value: () => terminal.data.font,
            prettyValue: () => terminal.data.font,
            edit: v => terminal.data.font = v,
            reset: () => terminal.data.resetProperty("font"),

        },
        {
            id: "color1",
            name: "Primary Accent Color",
            value: () => terminal.data.accentColor1.string.hex,
            prettyValue: () => terminal.data.accentColor1.toString(),
            edit: v => terminal.data.accentColor1 = v,
            reset: () => terminal.data.resetProperty("accentColor1"),
            regex: /^#[0-9a-f]{6}$/,
            unitComment: "in hex"
        },
        {
            id: "color2",
            name: "Secondary Accent Color",
            value: () => terminal.data.accentColor2.string.hex,
            prettyValue: () => terminal.data.accentColor2.toString(),
            edit: v => terminal.data.accentColor2 = v,
            reset: () => terminal.data.resetProperty("accentColor2"),
            regex: /^#[0-9a-f]{6}$/,
            unitComment: "in hex"
        },
        {
            id: "storage",
            name: "Storage Size",
            warning: "This property cannot be increased indefinitely. Most browsers only\nsupport up to 5 Megabytes of total local storage. Going near this limit may break things!",
            value: () => terminal.data.storageSize,
            prettyValue: () => terminal.fileSystem.filesizeStr(terminal.data.storageSize),
            edit: v => terminal.data.storageSize = v,
            reset: () => terminal.data.resetProperty("storageSize"),
            regex: /^[0-9]+$/,
            unitComment: "in bytes"
        },
        {
            id: "history",
            name: "Max History Length",
            warning: "The history uses up a lot of space. Localstorage space is valuable, don't increase it too much.",
            value: () => terminal.data.maxHistoryLength,
            prettyValue: () => terminal.data.maxHistoryLength + " items",
            edit: v => terminal.data.maxHistoryLength = v,
            reset: () => terminal.data.resetProperty("maxHistoryLength"),
            regex: /^[0-9]+$/,
        },
    ]

    if (args.edit) {
        const property = properties.find(p => p.id == args.edit)
        if (!property) {
            // should never happen, still there just in case
            // ( should never happen as arg is set as enum and the           )
            // ( TerminalParser should make sure to only allow valid options )
            throw new Error(`Unknown Property "${args.edit}"`)
        }

        terminal.print("Property Name: ")
        terminal.printLine(property.name, Color.COLOR_1)

        if (property.prettyValue() != property.value()) {
            terminal.printLine(`Prettified Value: ${property.prettyValue()}`)
            terminal.printLine(`Actual Value: ${property.value()}`)
        } else {
            terminal.printLine(`Value: ${property.value()}`)
        }

        if (property.warning) {
            terminal.print("\nWarning", Color.hex("#ff9800"))
            terminal.printLine(`: ${property.warning}`)
        }
        
        if (property.info) {
            terminal.print("\nInfo", Color.COLOR_1)
            terminal.printLine(`: ${property.info}`)
        }

        terminal.addLineBreak()

        let value = undefined
        terminal.printLine("Type \"<default>\" to set it to the default value")
        while (true) {
            const promptUnit = property.unitComment ? `(${property.unitComment})` : ""
            value = await terminal.prompt(`New Value ${promptUnit}: `)
            if (value == "<default>") {
                property.reset()
                terminal.printSuccess(`Successfully reset the value to it's default (${property.value()}).`)
                return
            }

            if (!property.regex || (property.regex && property.regex.test(value))) {
                break
            } else {
                terminal.printError(`Invalid Value! (RegEx: ${property.regex})`)
            }
        }

        property.edit(value)
        terminal.printSuccess(`Successfully edited ${property.name}`)

    } else {
        terminal.printTable(properties.map(p => [p.id, p.name, p.prettyValue()]), ["id", "name", "value"])
        terminal.print("\nTo edit a property, use ")
        terminal.printLine("config <id>", Color.COLOR_1)
    }
}, {
    description: "manage the terminal configuration",
    args: {
        "?e=edit:e:foreground|background|font|color1|color2|storage|history": "edit a given property",
    }
})

// ------------------- js/commands/construct.js --------------------
terminal.addCommand("construct", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    const terminalWindow = terminal.modules.window.make({
        name: "Number Construction Animation",
        fullscreen: args.fullscreen
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    class ModelCanvas {

        constructor(viewCentre, viewHeight) {
            this.context = context
            this.canvas = canvas

            this.viewCentre = viewCentre
            this.viewHeight = viewHeight
        }

        get width() {
            return this.canvas.width
        }

        get height() {
            return this.canvas.height
        }

        get viewWidth() {
            return this.canvas.width / this.canvas.height * this.viewHeight
        }

        pointToScreenPos(point) {
            const relativePoint = point.sub(this.viewCentre)
            return new Vector2d(
                (relativePoint.x / (this.viewWidth) + 0.5) * this.canvas.width,
                (-relativePoint.y / (this.viewHeight) + 0.5) * this.canvas.height
            )
        }

        screenPosToPoint(screenPos) {
            const x = (screenPos.x / this.canvas.width - 0.5) * this.viewWidth
            const y = -(screenPos.y / this.canvas.height - 0.5) * this.viewHeight
            const relativePoint = new Vector2d(x, y)
            return relativePoint.add(this.viewCentre)
        }

        clear(fillColor) {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
            if (fillColor) {
                this.fill(fillColor)
            }
        }

        drawPoint(point, {atScreenPos=false, radius=5, color="blue",
            label=null, labelSize=13, labelColor=null, labelOffset=null,
            labelBaseline="top", labelAlign="left"
        }={}) {
            labelColor ??= "black"
            
            this.context.beginPath()
            let screenPos = null
            if (atScreenPos) {
                screenPos = point
            } else {
                screenPos = this.pointToScreenPos(point)
            }

            this.context.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2)
            this.context.fillStyle = color
            this.context.fill()

            if (label !== null) {
                this.context.fillStyle = labelColor
                this.context.textAlign = labelAlign
                this.context.textBaseline = labelBaseline
                this.context.font = `${labelSize}px monospace`
                const labelPos = screenPos.addX(radius).addY(radius)
                if (labelOffset !== null) {
                    labelPos.iadd(labelOffset.scale(labelSize))
                }

                this.context.fillText(label, screenPos.x + radius, screenPos.y + radius)
            }
        }

        connectPoints(points, {atScreenPos=false, color=null, width=1}={}) {
            color ??= "black"

            this.context.strokeStyle = color
            this.context.lineWidth = width
            this.context.beginPath()

            for (let i = 0; i < points.length; i++) {
                const screenPos = atScreenPos ? points[i] : this.pointToScreenPos(points[i])
                if (i == 0) {
                    this.context.moveTo(screenPos.x, screenPos.y)
                } else {
                    this.context.lineTo(screenPos.x, screenPos.y)
                }
            }

            this.context.stroke()
        }

        drawAxes({color="black", drawGrid=true, gridColor=null, drawLabels=true, labelColor=null}={}) {
            gridColor ??= color
            labelColor ??= color

            const minXY = this.screenPosToPoint(new Vector2d(0, this.canvas.height))
            const maxXY = this.screenPosToPoint(new Vector2d(this.canvas.width, 0))

            if (drawGrid) {
                for (let x = Math.floor(minXY.x); x <= maxXY.x; x++) {
                    this.connectPoints([
                        new Vector2d(x, minXY.y),
                        new Vector2d(x, maxXY.y)
                    ], {color: gridColor})
                }
                
                for (let y = Math.floor(minXY.y); y <= maxXY.y; y++) {
                    this.connectPoints([
                        new Vector2d(minXY.x, y),
                        new Vector2d(maxXY.x, y)
                    ], {color: gridColor})
                }
            }

            // x axis
            this.connectPoints([
                new Vector2d(Math.floor(minXY.x) - 1, 0),
                new Vector2d(Math.ceil(maxXY.x) + 1, 0)
            ], {color})

            // y axis
            this.connectPoints([
                new Vector2d(0, Math.floor(minXY.y) - 1),
                new Vector2d(0, Math.ceil(maxXY.y) + 1)
            ], {color})

            const pinStyling = {color, radius: 3, labelColor}

            if (!drawLabels) return

            for (let x = Math.floor(minXY.x); x <= Math.ceil(maxXY.x); x++) {
                if (x == 0) continue
                this.drawPoint(new Vector2d(x, 0), {label: x, ...pinStyling})
            }

            for (let y = Math.floor(minXY.y); y <= Math.ceil(maxXY.y); y++) {
                const label = Math.abs(y) > 1 ? `${y}i` : (y < 0 ? "-i" : (y > 0 ? "i" : "0"))
                this.drawPoint(new Vector2d(0, y), {label, ...pinStyling})
            }
        }

        drawCircle(point, radius, {atScreenPos=false, color=null, dashed=false, width=1, startAngle=0, endAngle=Math.PI * 2, clockwise=true}={}) {
            color ??= "black"
            if (!atScreenPos) {
                radius = radius / this.viewHeight * this.canvas.height
            }

            this.context.beginPath()
            const screenPos = atScreenPos ? point : this.pointToScreenPos(point)
            this.context.arc(screenPos.x, screenPos.y, radius, startAngle, endAngle, !clockwise)
            this.context.strokeStyle = color
            if (dashed) {
                this.context.setLineDash([5, 5])
            }
            this.context.lineWidth = width
            this.context.stroke()
            this.context.setLineDash([])
        }
        
        fill(color) {
            this.context.fillStyle = color
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)
        }

    }

    const modelCanvas = new ModelCanvas(new Vector2d(0, 0), 10)

    class DrawnPoint {

        constructor(pos, name, color) {
            this.pos = pos
            this.name = name
            this.color = color
        }

        draw() {
            modelCanvas.drawPoint(this.pos, {
                label: this.name,
                color: this.color
            })
        }

    }

    class DrawnArc {

        constructor(pos, radius, {startAngle=0, endAngle=Math.PI * 2, color=null, clockwise=true}={}) {
            this.pos = pos
            this.radius = radius
            this.startAngle = startAngle
            this.endAngle = endAngle
            this.color = color
            this.clockwise = clockwise
        }

        draw() {
            modelCanvas.drawCircle(this.pos, this.radius, {
                startAngle: this.startAngle,
                endAngle: this.endAngle,
                color: this.color,
                clockwise: this.clockwise
            })
        }

    }

    class DrawnLine {

        constructor(pos1, pos2, {width=null, color=null}={}) {
            this.pos1 = pos1
            this.pos2 = pos2
            this.width = width
            this.color = color
        }

        get xDiff() {
            return this.pos2.x - this.pos1.x
        }
        
        get yDiff() {
            return this.pos2.y - this.pos1.y
        }

        get length() {
            return this.pos1.sub(this.pos2).length
        }

        get midpoint() {
            return this.pos1.lerp(this.pos2, 0.5)
        }

        draw() {
            modelCanvas.connectPoints([this.pos1, this.pos2], {
                color: this.color,
                width: this.width
            })
        }

    }

    class Compass {

        constructor(pos1, pos2, hidden) {
            this.pos1 = pos1
            this.pos2 = pos2
            this.hidden = hidden
        }

        get angle() {
            return this.pos2.sub(this.pos1).angle
        }

        get screenAngle() {
            return this.screenPos2.sub(this.screenPos1).angle
        }

        get midpoint() {
            return this.pos1.lerp(this.pos2, 0.5)
        }

        get screenMidpoint() {
            return this.screenPos1.lerp(this.screenPos2, 0.5)
        }

        get screenPos1() {
            return modelCanvas.pointToScreenPos(this.pos1)
        }
        
        get screenPos2() {
            return modelCanvas.pointToScreenPos(this.pos2)
        }

        draw() {
            if (this.hidden) {
                return
            }

            const size = Math.min(modelCanvas.width, modelCanvas.height) * 0.3

            const tangentDir = Vector2d.fromAngle(this.screenAngle - Math.PI / 2)
            const headPos = this.screenMidpoint.add(tangentDir.scale(size))

            const cirlceRadius = size * 0.13
            const tipPos = this.screenMidpoint.add(tangentDir.scale(size + cirlceRadius))
            const tiptipPos = this.screenMidpoint.add(tangentDir.scale(size + cirlceRadius * 2))

            modelCanvas.drawCircle(headPos, cirlceRadius, {
                atScreenPos: true,
            })

            context.fillStyle = "rgba(0, 0, 0, 0.2)"
            context.fill()

            modelCanvas.connectPoints([
                this.screenPos1, headPos, this.screenPos2
            ], {atScreenPos: true})
            
            modelCanvas.connectPoints([
                tipPos, tiptipPos
            ], {atScreenPos: true})
        }

    }

    class Ruler {

        constructor(pos, direction, hidden) {
            this.pos = pos
            this.direction = direction
            this.hidden = hidden
        }

        get screenPos() {
            return modelCanvas.pointToScreenPos(this.pos)
        }

        draw() {
            if (this.hidden) {
                return
            }

            const width = Math.max(modelCanvas.width, modelCanvas.height)
            const height = Math.min(modelCanvas.width, modelCanvas.height) * 0.2
            const dir = Vector2d.fromAngle(this.direction)
            const tangentDir = Vector2d.fromAngle(this.direction + Math.PI / 2)

            const imperfectOffset = 4
            const pos1 = this.screenPos.sub(dir.scale(width))
            const pos2 = this.screenPos.add(dir.scale(width))
            pos1.iadd(tangentDir.scale(imperfectOffset))
            pos2.iadd(tangentDir.scale(imperfectOffset))
            const pos3 = pos2.add(tangentDir.scale(height))
            const pos4 = pos1.add(tangentDir.scale(height))

            modelCanvas.connectPoints([pos1, pos2, pos3, pos4], {
                atScreenPos: true, color: "#777"
            })

            context.fillStyle = "rgba(0, 0, 0, 0.2)"
            context.fill()
            
            modelCanvas.connectPoints([pos1, pos2], {
                atScreenPos: true, color: "black", width: 2
            })
        }

    }
    
    const origin = new DrawnPoint(new Vector2d(0, 0), "0")
    const unitPoint = new DrawnPoint(new Vector2d(1, 0), "1")
    const drawnObjects = [origin, unitPoint]

    const compass = new Compass(new Vector2d(0, 0), new Vector2d(1, 0), true)
    const ruler = new Ruler(new Vector2d(0, 0), -0.2, true)
    
    function redraw() {
        modelCanvas.clear("white")
        modelCanvas.drawAxes({color: "#333", drawGrid: true, gridColor: "#ccc", drawLabels: false})
        
        compass.draw()
        ruler.draw()

        for (const obj of drawnObjects) {
            obj.draw()
        }
    }
    
    const fps = args.fps
    
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })

    redraw()

    async function drawCircleWithCompass(point, otherPoint, {steps=50, color=null}={}) {
        compass.pos1 = point
        compass.pos2 = otherPoint
        compass.hidden = false
        
        const radius = point.sub(otherPoint).length
        const offsetAngle = point.angleTo(otherPoint)
        const arc = new DrawnArc(point, radius, {clockwise: false, color})
        arc.startAngle = -offsetAngle

        drawnObjects.push(arc)

        for (let i = 1; i < steps; i++) {
            const angle = offsetAngle + Math.PI * 2 * (i / steps)
            const dir = Vector2d.fromAngle(angle).scale(radius)

            compass.pos2 = point.add(dir)
            arc.endAngle = Math.PI * 2 - angle

            redraw()
            await sleep(1000 / fps)
        }

        arc.startAngle = 0
        arc.endAngle = Math.PI * 2
        compass.hidden = true

        redraw()

        return arc
    }

    async function drawLineWithRuler(pos1, pos2, {width=null, color=null, steps=50}={}) {
        ruler.hidden = false
        ruler.pos = pos1
        ruler.direction = -pos1.angleTo(pos2)

        const line = new DrawnLine(pos1, pos1, {color, width})
        drawnObjects.push(line)

        for (let i = 0; i < steps; i++) {
            line.pos2 = pos1.lerp(pos2, i / steps)

            redraw()
            await sleep(1000 / fps)
        }

        line.pos2 = pos2

        ruler.hidden = true
        redraw()
    }

    async function changeZoomTo(viewHeight, viewCentre, {steps=30}={}) {
        const startHeight = modelCanvas.viewHeight
        const startCentre = modelCanvas.viewCentre.copy()
        for (let i = 0; i < steps + 1; i++) {
            const t = i / steps
            modelCanvas.viewHeight = startHeight + (viewHeight - startHeight) * t
            modelCanvas.viewCentre = startCentre.lerp(viewCentre, t)
            redraw()
            await sleep(1000 / fps)
        }
    }

    async function doubleLine(pos1, pos2, numSteps=1) {
        let prevPoint = pos1
        const midpoint = pos1.lerp(pos2, 0.5)
        let point = null
        for (let i = 0; i < numSteps + 1; i++) {
            const n = 2 ** i
            point = new DrawnPoint(pos1.lerp(pos2, n), null, "red")
            
            await changeZoomTo(pos1.sub(point.pos).length * 3, midpoint)
            await drawLineWithRuler(prevPoint, point.pos, {color: "red"})
            
            drawnObjects.push(point)
            redraw()

            if (i + 1 < numSteps + 1) {
                await sleep(300)
                await drawCircleWithCompass(point.pos, pos1, {color: "blue"})
            }

            prevPoint = point.pos
        }

        return point
    }

    async function naturalScaleLine(pos1, pos2, steps) {
        const power2Components = []
        for (let i = Math.floor(Math.log2(steps)); i >= 0; i--) {
            const powerOf2 = 2 ** i
            if (steps >= powerOf2) {
                steps -= powerOf2
                power2Components.push(i)
            }
        }

        const line = new DrawnLine(pos1.copy(), null)

        let lastEndPoint = pos1
        let nextStartPoint = pos2
        const delta = pos2.sub(pos1)
        for (const i of power2Components) {
            lastEndPoint = (await doubleLine(lastEndPoint, nextStartPoint, i)).pos
            nextStartPoint = lastEndPoint.add(delta)

            if (i != power2Components[power2Components.length - 1]) {
                await changeZoomTo(pos1.sub(pos2).length * 3, lastEndPoint)
                await drawCircleWithCompass(lastEndPoint, nextStartPoint, {color: "blue"})
            }
        }

        line.pos2 = lastEndPoint

        await changeZoomTo(Math.max(Math.abs(line.xDiff), Math.abs(line.yDiff)) * 1.5, line.midpoint)

        return line
    }

    const line = await naturalScaleLine(origin.pos, unitPoint.pos, 10)

}, {
    description: "animate the construction of a given number (using ruler and compass only)",
    args: {
        "number:s": "the number to construct (form: 'sqrt(20)+3')",
        "?f=fullscreen:b": "enable fullscreen mode",
        "?fps:i:1~99999": "fps of animation"
    },
    defaultValues: {
        fps: 30
    },
    isSecret: true
})

// ------------------- js/commands/contact.js --------------------
const formContainer = document.createElement("div")
const formWidth = "min(25em, 50vw)"

let formInfo = {}

function addInput({
    type="text",
    name=null,
    errorFunc=null,
    placeholder=null,
}={}) {
    const input = document.createElement("input")
    input.setAttribute("type", type)
    if (placeholder) input.setAttribute("placeholder", placeholder)

    if (name) {
        input.setAttribute("name", name)
        formInfo[name] = {
            errorFunc,
            input,
        }
        input.addEventListener("input", validateForm)
    }

    formContainer.appendChild(input)
    input.style.display = "block"
    input.style.margin = "10px"
    input.style.padding = "10px"
    input.style.border = "1px solid var(--foreground)"
    input.style.borderRadius = "5px"
    input.style.width = formWidth

    return input
}

const nameInput = addInput({
    name: "name",
    placeholder: "Name *",
    errorFunc: (value) => {
        if (!value) return "Please enter a name"
        if (value.length > 100) return "Name is too long"
        return ""
    }
})

const emailInput = addInput({
    type: "email",
    name: "email",
    placeholder: "Email *",
    errorFunc: (value) => {
        if (!value) return "Please enter an email"
        if (value.length > 100) return "Email is too long"
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        if (!emailRegex.test(value)) return "Invalid email format"
        return ""
    }
})

const phoneInput = addInput({
    type: "tel",
    name: "phone",
    placeholder: "Phone",
    errorFunc: (value) => {
        if (!value) return ""
        if (value.length > 100) return "Phone is too long"
        const phoneRegex = /^\+?[0-9\s]+$/
        if (!phoneRegex.test(value)) return "Invalid phone format"
        return ""
    }
})

const messageTextarea = document.createElement("textarea")
messageTextarea.setAttribute("name", "message")
messageTextarea.setAttribute("placeholder", "Message *")
formContainer.appendChild(messageTextarea)

messageTextarea.style.display = "block"
messageTextarea.style.margin = "10px"
messageTextarea.style.padding = "10px"
messageTextarea.style.border = "1px solid var(--foreground)"
messageTextarea.style.borderRadius = "5px"
messageTextarea.style.width = formWidth
messageTextarea.style.height = "10em"
messageTextarea.style.resize = "vertical"
messageTextarea.style.backgroundColor = "var(--background)"
messageTextarea.style.color = "var(--foreground)"

formInfo["message"] = {
    errorFunc: (value) => {
        if (!value) return "Please enter a message"
        if (value.length > 1000) return "Message max length is 1000 characters"
        return ""
    },
    input: messageTextarea
}

messageTextarea.addEventListener("input", validateForm)

const errorOutput = document.createElement("div")
errorOutput.style.color = "#ff5555"
errorOutput.style.margin = "10px"
formContainer.appendChild(errorOutput)

const submitButton = document.createElement("div")
submitButton.textContent = "Send Message"
formContainer.appendChild(submitButton)

submitButton.style.display = "block"
submitButton.style.textAlign = "center"
submitButton.style.margin = "10px"
submitButton.style.padding = "10px"
submitButton.style.border = "1px solid var(--foreground)"
submitButton.style.borderRadius = "5px"
submitButton.style.width = formWidth
submitButton.style.backgroundColor = "var(--background)"
submitButton.style.color = "var(--foreground)"
submitButton.style.cursor = "pointer"

submitButton.addEventListener("mouseenter", () => {
    submitButton.style.backgroundColor = "var(--foreground)"
    submitButton.style.color = "var(--background)"
})

submitButton.addEventListener("mouseleave", () => {
    submitButton.style.backgroundColor = "var(--background)"
    submitButton.style.color = "var(--foreground)"
})

function validateForm() {
    for (let [name, info] of Object.entries(formInfo)) {
        const { errorFunc, input } = info
        if (errorFunc) {
            const error = errorFunc(input.value)
            errorOutput.textContent = error
            if (error) {
                return false
            }
        }
    }
    return true
}

validateForm()

submitButton.addEventListener("click", async () => {
    if (!validateForm()) {
        errorOutput.animate([
            { transform: "translateX(-10px)" },
            { transform: "translateX(10px)" },
            { transform: "translateX(-10px)" },
            { transform: "translateX(10px)" },
            { transform: "translateX(-10px)" },
            { transform: "translateX(10px)" },
            { transform: "translateX(-10px)" },
            { transform: "translateX(10px)" },
            { transform: "translateX(-10px)" },
            { transform: "translateX(0px)" },
        ], {
            duration: 500,
            iterations: 1,
        })
        return
    }

    let submitUrl = terminal.baseUrl + "./api/contact.php"
    let formData = new FormData()
    for (let [name, info] of Object.entries(formInfo)) {
        formData.append(name, info.input.value)
    }
    const response = await fetch(submitUrl, {
        method: "POST",
        body: formData,
    })
    const data = await response.json()
    if (data.ok) {
        formSuccessful = true
    } else {
        errorOutput.textContent = data.error
    }
})

let formSuccessful = false

terminal.addCommand("contact", async function(args) {
    formSuccessful = false
    terminal.parentNode.appendChild(formContainer)

    terminal.scroll()

    setTimeout(() => nameInput.focus(), 300)
    
    while (!formSuccessful) await sleep(1000)

    terminal.printSuccess("Message sent!")
    terminal.printLine("I'll get back to you as soon as possible.")
    formContainer.remove()

    for (let [name, info] of Object.entries(formInfo)) {
        info.input.value = ""
    }
}, {
    description: "Open contact form",
})

// ------------------- js/commands/copy.js --------------------
terminal.addCommand("copy", async function(rawArgs) {
    rawArgs = rawArgs.trim()
    if (terminal.parser.isVariable(rawArgs)) {
        let name = terminal.parser.extractVariableName(rawArgs + "=")
        let value = terminal.getVariableValue(name)
        await terminal.copy(value)
    } else if (terminal.fileExists(rawArgs)) {
        let file = terminal.getFile(rawArgs)
        if (file.isDirectory)
            throw new Error("Cannot copy a folder")
        await terminal.copy(file.content)
        terminal.printLine("Copied File to Clipboard ✓")
    } else {
        await terminal.copy(rawArgs)
        terminal.printLine("Copied to Clipboard ✓")
    }
}, {
    description: "copy the file content to the clipboard",
    rawArgMode: true
})

// ------------------- js/commands/coville.js --------------------
terminal.addCommand("coville", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../coville/",
        name: "Covid in Coville",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "interactive virus simulation (in german)",
    isSecret: true,
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/cowsay.js --------------------
var COW_SAY = ` 
\\   ^__^
 \\  (oo)\\_______
    (__)\       )\\/\\
        ||----w |
        ||     ||
`

terminal.addCommand("cowsay", function(args) {
    const message = args.message
    const bubbleWidth = Math.min(40, message.length)

    function splitIntoLines(text, width=bubbleWidth) {
        let lines = []
        let line = String()
        for (let word of text.split(" ")) {
            if (line.length + word.length > width) {
                lines.push(line)
                line = String()
            }
            line += word + " "
        }
        lines.push(line)
        return lines
    }

    let lines = splitIntoLines(args.message).map(l => l.trim())

    let output = String()

    output += " " + stringMul("-", bubbleWidth + 2) + "\n"
    let i = 0
    for (let line of lines) {
        let leftChar = "|"
        let rightChar = "|"
        i++

        if (lines.length >= 3) {
            if (i == 1) {
                leftChar = "/"
                rightChar = "\\"
            } else if (i == lines.length) {
                leftChar = "\\"
                rightChar = "/"
            }
        } else if (lines.length == 1) {
            leftChar = "<"
            rightChar = ">"
        }

        output += `${leftChar} ${stringPadMiddle(line, bubbleWidth)} ${rightChar}\n`
    }
    output += " " + stringMul("-", bubbleWidth + 2) + "\n"
    output = output.slice(0, -1)
    for (let line of COW_SAY.split("\n")) {
        let amountSpaces = Math.max(4, Math.min(message.length, bubbleWidth - 20) + 4)
        output += " ".repeat(amountSpaces) + line + "\n"
    }
    terminal.printLine(output.slice(0, -3))

    if (/[mM][uU]+[hH]|[mM][oO]+/.test(args.message)) {
        terminal.printEasterEgg("Moo-Egg")
    }
}, {
    description: "let the cow say something",
    args: ["*message"]
})

// ------------------- js/commands/cowthink.js --------------------
var COW_SAY = ` 
o   ^__^
 o  (oo)\\_______
    (__)\       )\\/\\
        ||----w |
        ||     ||
`

terminal.addCommand("cowthink", function(args) {
    const message = args.thought
    const bubbleWidth = Math.min(40, message.length)

    function splitIntoLines(text, width=bubbleWidth) {
        let lines = []
        let line = String()
        for (let word of text.split(" ")) {
            if (line.length + word.length > width) {
                lines.push(line)
                line = String()
            }
            line += word + " "
        }
        lines.push(line)
        return lines
    }

    let lines = splitIntoLines(message).map(l => l.trim())

    let output = String()

    output += " " + stringMul("-", bubbleWidth + 2) + "\n"
    let i = 0
    for (let line of lines) {
        let leftChar = "("
        let rightChar = ")"
        i++

        if (lines.length >= 3) {
            if (i == 1) {
                leftChar = "/"
                rightChar = "\\"
            } else if (i == lines.length) {
                leftChar = "\\"
                rightChar = "/"
            }
        } else if (lines.length == 1) {
            leftChar = "("
            rightChar = ")"
        }

        output += `${leftChar} ${stringPadMiddle(line, bubbleWidth)} ${rightChar}\n`
    }
    output += " " + stringMul("-", bubbleWidth + 2) + "\n"
    output = output.slice(0, -1)
    for (let line of COW_SAY.split("\n")) {
        let amountSpaces = Math.max(4, Math.min(message.length, bubbleWidth - 20) + 4)
        output += " ".repeat(amountSpaces) + line + "\n"
    }
    terminal.printLine(output.slice(0, -3))
}, {
    description: "let the cow say something",
    args: ["*thought"]
})

// ------------------- js/commands/cp.js --------------------
terminal.addCommand("cp", async function(args) {
    let file = terminal.getFile(args.file)
    let directory = terminal.getFile(args.directory, FileType.DIRECTORY)

    let copy = file.copy()
    
    if (args.name) {
        if (!terminal.isValidFileName(args.name)) {
            throw new Error("Invalid Filename")
        } else if (directory.getFile(args.name)) {
            throw new Error("File with that name already exists in directory")
        } else {
            copy.setName(args.name)
        }
    } else if (directory == file.parent || directory.fileExists(file.name)) {
        let nameFromNumber = undefined

        let nameStart = ""
        let nameEnding = ""
        let foundPoint = false
        for (let char of [...copy.name].reverse()) {
            if (!foundPoint && char == ".") {
                foundPoint = true
            } else if (foundPoint) {
                nameStart = char + nameStart
            } else {
                nameEnding = char + nameEnding
            }
        }

        if (!foundPoint) {
            // swap them
            let temp = nameStart
            nameStart = nameEnding
            nameEnding = temp
        }

        let match = nameStart.match(/^(.+?)([0-9]+)$/)
        let dotQ = foundPoint ? "." : ""
        if (match) {
            nameFromNumber = n => `${match[1]}${(BigInt(match[2]) + BigInt(n))}${dotQ}${nameEnding}`
        } else {
            nameFromNumber = n => `${nameStart}${n}${dotQ}${nameEnding}`
        }

        const maxNumberingTries = 1000
        for (let i = 1; i <= maxNumberingTries; i++) {
            let fileName = nameFromNumber(i)
            if (terminal.isValidFileName(fileName) && !directory.fileExists(fileName)) {
                copy.setName(fileName)
                break
            }
            
            if (i == maxNumberingTries) {
                throw new Error("Couldn't generate new unique filename. Provide one using the --name option")
            }
        }
    }

    directory.addChild(copy)
}, {
    description: "copy a file",
    args: {
        "file:f": "file to copy",
        "?d=directory:f": "directory to copy to",
        "?n=name:s": "new filename",
    },
    defaultValues: {
        directory: "."
    }
})



// ------------------- js/commands/crossp.js --------------------
terminal.addCommand("crossp", function(args) {
    const x = args.y1 * args.z2 - args.z1 * args.y2
    const y = args.z1 * args.x2 - args.x1 * args.z2
    const z = args.x1 * args.y2 - args.y1 * args.x2

    terminal.printLine(`< ${x}, ${y}, ${z} >`)
}, {
    description: "calculate the cross product of 2 3d vectors",
    args: {
        "x1:n": "the x component of the first vector",
        "y1:n": "the y component of the first vector",
        "z1:n": "the z component of the first vector",
        "x2:n": "the x component of the second vector",
        "y2:n": "the y component of the second vector",
        "z2:n": "the z component of the second vector"
    }
})

// ------------------- js/commands/curl.js --------------------
terminal.addCommand("curl", async function(args) {
    function corsError() {
        terminal.printError("Cross-origin requests are not allowed")
        terminal.print("What is ")
        terminal.printLink("CORS (Cross-Origin Resource Sharing)", "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS", undefined, false)
        terminal.printLine("?")
        terminal.printLine("You may only download files from a website that allows it.")
        terminal.print("If you are trying to download a file from a website that you own, you may need to ")
        terminal.printLink("enable CORS", "https://enable-cors.org/server.html", undefined, false)
        terminal.printLine(".")
        terminal.print("An example of a website that allows CORS is ")
        terminal.printLink("wikipedia.org", "https://wikipedia.org", undefined, false)
        terminal.printLine(".\n")
        terminal.printLine("It's also possible that the resource you are requesting does not exist.")
        terminal.printLine("> It may be worth checking the URL for typos.")
        throw new IntendedError()
    }

    try {
        var result = await fetch(args.url)
    } catch (e) {
        if (e instanceof TypeError) {
            corsError()
        } else {
            throw e
        }
    }

    if (result.status !== 200) {
        terminal.printError("Error: " + result.status)
        throw new IntendedError()
    }

    let contentType = result.headers.get("content-type")
    if (!contentType) {
        terminal.printError("No content type")
        throw new IntendedError()
    }

    let dataUrl = await result.blob()
    dataUrl = URL.createObjectURL(dataUrl)
    let fileName = args.url.split("/").pop()
    let file = new DataURLFile(dataUrl)

    if (terminal.fileExists(fileName))
        throw new Error("file already exists in folder")

    terminal.currFolder.content[fileName] = file
    await terminal.fileSystem.reload()

    terminal.printSuccess("download finished.") 
}, {
    description: "download a file from the internet",
    args: {
        "url:s": "the url to download the file from"
    },
    disableEqualsArgNotation: true
})

// ------------------- js/commands/cw.js --------------------
terminal.addCommand("cw", function(args) {
    if (args.date == "today" || !args.date) {
        args.date = "today"
        const today = new Date()
        var day = today.getDate()
        var month = today.getMonth() + 1
        var year = today.getFullYear()
    } else if (!/^[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,4}$/.test(args.date)) {
        throw new Error("Invalid date!")
    } else {
        var [day, month, year] = args.date.split(".").map(d => parseInt(d))
    }

    function getCalendarWeek(day, month, year, yearPlus=0) {
        let firstDay = new Date()
        firstDay.setFullYear(year, 0, 4)
        while (firstDay.getDay() != 1) {
            firstDay.setDate(firstDay.getDate() - 1)
        }
        let currDate = firstDay
        let count = 1
        while (currDate.getDate() != day
        || currDate.getMonth() != (month - 1)
        || currDate.getFullYear() != (year + yearPlus)
        ) {
            currDate.setDate(currDate.getDate() + 1)
            count++
            if (count > 400) {
                return 0
            }
        }
        return Math.ceil(count / 7)
    }

    let calendarWeek = getCalendarWeek(day, month, year)
    let iterationCount = 0

    while (calendarWeek == 0) {
        iterationCount += 1
        calendarWeek = getCalendarWeek(
            day, month, year - iterationCount, iterationCount
        )
        if (iterationCount > 3)
            throw new Error("Invalid day!")
    }

    terminal.printLine(`calenderweek of ${args.date}: ${calendarWeek}`)

}, {
    description: "get the calendar week of a date",
    args: {
        "?date": "the date to get the calendar week of"
    },
    standardVals: {
        date: null
    }
})



// ------------------- js/commands/debug.js --------------------
terminal.addCommand("debug", function(args) {
	if (terminal.debugMode) {
		throw new Error("Debug Mode already activated")
	}

	terminal.debugMode = true
	terminal.printSuccess("Activated Debug Mode")
	terminal.log("Activated Debug Mode")
} ,{
	description: "activate the debug mode to enable untested new features",
	isSecret: true
})

// ------------------- js/commands/donut.js --------------------
terminal.addCommand("donut", async function() {
    setTimeout(() => terminal.scroll(), 100)
    let commandIsActive = true
    terminal.onInterrupt(() => commandIsActive = false)
    setTimeout(() => {
        if (commandIsActive) {
            terminal.printEasterEgg("Donut-Egg")
        }
    }, 3 * 60 * 1000)

    // mostly copied from original donut.c code

               let p=terminal.
           print(),A=1,B=1,f=()=>{
         let b=[];let z=[];A+=0.07;B
       +=0.03;let s=Math.sin,c=Math.cos
     ,cA=c(A),sA=s(A),cB=c(B),sB=s(B);for(
    let k=0;k<1760;k++){b[k]=k%80==79?"\n":
    " ";z[k]=0;};for        (let j=0;j<6.28;
    j+=0.07){let ct          =c(j),st=s(j);
    for(i=0;i<6.28;          i+=0.02){let sp
    =s(i),cp=c(i),h          =ct+2,D=1/(sp*h
    *sA+st*cA+5),t=sp       *h*cA-st*sA;let
    x=0|(40+30*D*(cp*h*cB-t*sB)),y=0|(12+15
     *D*(cp*h*sB+t*cB)),o=x+80*y,N=0|(8*((st
     *sA-sp*ct*cA)*cB-sp*ct*sA-st*cA-cp*ct
     *sB));if(y<22&&y>=0&&x>=0&&x<79&&D>z
       [o]){z[o]=D;b[o]=".,-~:;=!*#$@"[
          N>0?N:0];}}}p.textContent=b
            .join("")};while(1){f();
              await sleep(30);}

}, {
    description: "display a spinning donut"
})



// ------------------- js/commands/download.js --------------------
terminal.addCommand("download", function(args) {
    let file = terminal.getFile(args.file)
    if (file.type == FileType.FOLDER)
        throw new Error("cannot download directory")
    downloadFile(file)
}, {
    description: "download a file",
    args: {"file:f": "the file to download"}
})

// ------------------- js/commands/draw.js --------------------
terminal.addCommand("draw", async function() {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../draw/",
        name: "Draw"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "start simple drawing app"
})

// ------------------- js/commands/du.js --------------------
terminal.addCommand("du", function(args) {
    let fileNames = []
    let fileSizes = []
    let totalSize = 0

    let targetFolder = terminal.getFile("")
    if (args.folder) {
        targetFolder = terminal.getFile(args.folder)
    }

    for (let file of targetFolder.children) {
        let fileBytes = file.computeSize()
        totalSize += fileBytes
        let fileSize = terminal.fileSystem.filesizeStr(fileBytes)

        let fileName = file.name
        if (file.type == FileType.FOLDER)
            fileName += "/"
        fileNames.push(fileName)
        fileSizes.push(fileSize)
    }
    
    fileNames.unshift("TOTAL")
    fileSizes.unshift(terminal.fileSystem.filesizeStr(totalSize))
    let longestSizeLength = fileSizes.reduce((a, e) => Math.max(a, e.length), 0) + 2
    let paddedFileSizes = fileSizes.map(s => stringPadBack(s, longestSizeLength))
    for (let i = 0; i < fileNames.length; i++) {
        if (i == 0) {
            terminal.print(paddedFileSizes[i] + fileNames[i] + "\n", Color.COLOR_1)
        } else {
            terminal.printLine(paddedFileSizes[i] + fileNames[i])
        }
    }
    if (fileNames.length == 0) {
        throw new Error("target-directory is empty")
    }
}, {
    description: "display storage of current directory",
    args: {
        "?folder:f": "folder to display storage of"
    },
})

// ------------------- js/commands/easter-eggs.js --------------------
terminal.addCommand("easter-eggs", async function(args) {
    if (args.reset) {
        await terminal.acceptPrompt("Do you really want to reset the easter egg hunt?", false)
        terminal.data.resetProperty("easterEggs")
        return
    }

    terminal.printLine("Welcome to the easter egg hunt.", Color.COLOR_1)
    terminal.printLine("You can find easter eggs all across different")
    terminal.printLine("parts (commands) of this website. An example")
    terminal.printLine("Easter Egg looks like this: (click on it!)")
    terminal.printEasterEgg("Starter-Egg")
    terminal.addLineBreak()
    terminal.printLine("RULES", Color.COLOR_2)
    terminal.printLine("1. You may not look at the source code of this website using your browser.")
    terminal.print("2. You may use the ")
    terminal.printCommand("code", "code", undefined, false)
    terminal.printLine(" command to look at the source code of commands.")
    terminal.printLine("3. You must have fun.")
    terminal.addLineBreak()
    terminal.printLine("YOUR EGGS", Color.COLOR_2)

    let listOutput = terminal.print("", undefined, {forceElement: true})

    function updateList() {
        let output = ""
        let eggs = terminal.data.easterEggs
        let count = 0
        for (let egg of eggs) {
            count++
            output += `${count}: ${egg}\n`
        }
        if (eggs.size == 0)
            output += "< no eggs found (yet) >\n"

        listOutput.textContent = output
    }

    updateList()
    terminal.window.setInterval(updateList, 500)

}, {
    description: "open easter egg hunt",
    args: {
        "?reset:b": "reset easter egg hunt"
    }
})

// ------------------- js/commands/echo.js --------------------
terminal.addCommand("echo", function(rawArgs) {
    terminal.printLine(rawArgs.slice(1))
}, {
    description: "print a line of text",
    rawArgMode: true,
})

// ------------------- js/commands/echonum.js --------------------
terminal.addCommand("echonum", function(args) {
    terminal.printLine(args.number)
}, {
    description: "echo a given number",
    args: {
        "number:n": "number to echo"
    },
    isSecret: true
})

// ------------------- js/commands/edit.js --------------------
terminal.addCommand("edit", async function(args) {
    function makeTextarea(textContent) {
        const textarea = document.createElement("textarea")
        textarea.value = textContent
        
        textarea.style.position = "relative"
        textarea.style.background = "var(--background)"
        textarea.style.color = "var(--foreground)"
        textarea.style.marginTop = `calc(var(--font-size) * 0.8)`
        textarea.style.padding = `calc(var(--font-size) * 0.8)`
        textarea.style.border = "1px solid var(--foreground)"
        textarea.style.borderRadius = `calc(var(--font-size) * 0.5)`

        textarea.style.width = `calc(var(--font-size) * 35)`
        textarea.style.minWidth = `calc(var(--font-size) * 15)`
        textarea.style.maxWidth = `calc(var(--font-size) * 100)`

        textarea.rows = 20

        return textarea
    }

    function makeButton(text) {
        const button = terminal.createTerminalButton({text})

        button.style.marginTop = `calc(var(--font-size) * -0.5)`
        button.style.marginRight = `calc(var(--font-size) * 0.2)`
        button.style.padding = `calc(var(--font-size) * 0.5)`
        button.style.border = "1px solid var(--foreground)"
        button.style.borderRadius = `0 0 calc(var(--font-size) * 0.5) calc(var(--font-size) * 0.5)`
        button.style.width = "5em"

        return button
    }

    const file = terminal.getFile(args.file)

    if (file.isDirectory) {
        throw new Error("Cannot edit directory data")
    }

    const textarea = makeTextarea(file.content)
    const saveButton = makeButton("Save")
    const cancelButton = makeButton("Cancel")
    const br = document.createElement("br")
    let editingActive = true

    terminal.parentNode.appendChild(textarea)
    terminal.parentNode.appendChild(br)
    terminal.parentNode.appendChild(saveButton)
    terminal.parentNode.appendChild(cancelButton)
    terminal.scroll()
    textarea.focus()

    function removeElements() {
        textarea.remove()
        saveButton.remove()
        cancelButton.remove()
        br.remove()
    }

    function cancel() {
        if (!editingActive) {
            return
        }

        editingActive = false
        removeElements()
        terminal.printLine("[Pressed Cancel]")
    }

    function save() {
        if (!editingActive) {
            return
        }

        file.content = textarea.value
        editingActive = false
        removeElements()
        terminal.printSuccess(`Changes saved at ${file.path}`)
    }

    saveButton.onclick = save
    cancelButton.onclick = cancel

    textarea.onkeydown = function(event) {
        if (!editingActive) {
            return
        }

        if (event.key == "Tab") {
            event.preventDefault()
            let start = this.selectionStart
            let end = this.selectionEnd
        
            this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
        
            this.selectionStart = this.selectionEnd = start + 1;
        }

        if (event.key == "s" && event.ctrlKey) {
            event.preventDefault()
            save()
        }
    }

    terminal.onInterrupt(() => {
        removeElements()
    })

    while (editingActive) {
        await sleep(1000)
    }
}, {
    description: "edit a file",
    args: {
        "file:f": "file to edit",
    }
})

// ------------------- js/commands/enigma.js --------------------
class EnigmaWheel {

    constructor(permutation, overflowLetter, offset, name) {
        this.permutation = permutation
        this.overflowLetter = overflowLetter
        this.offset = offset
        this.name = name
    }

    translate(letter, reverse=false) {
        if (!reverse) {
            let letterIndex = letter.charCodeAt(0) - 65
            let translatedIndex = (letterIndex + this.offset) % 26
            let translatedLetter = this.permutation[translatedIndex]
            return translatedLetter
        } else {
            let letterIndex = this.permutation.indexOf(letter)
            let translatedIndex = (letterIndex - this.offset + 26) % 26
            let translatedLetter = String.fromCharCode(translatedIndex + 65)
            return translatedLetter
        }
    }

    toString() {
        return this.permutation + " " + this.overflowLetter + " " + this.offset
    }

    rotate() {
        this.offset = (this.offset + 1) % 26
        // return true if the wheel has rotated to the overflow letter
        return this.offset == this.overflowLetter.charCodeAt(0) - 65
    }

    reset() {
        this.offset = 0
    }

    static get DEFAULTS() {
        return {
            I: new EnigmaWheel("EKMFLGDQVZNTOWYHXUSPAIBRCJ", "Q", 0, "I"),
            II: new EnigmaWheel("AJDKSIRUXBLHWTMCQGZNPYFVOE", "E", 0, "II"),
            III: new EnigmaWheel("BDFHJLCPRTXVZNYEIWGAKMUSQO", "V", 0, "III"),
            IV: new EnigmaWheel("ESOVPZJAYQUIRHXLNFTGKDCMWB", "J", 0, "IV"),
            V: new EnigmaWheel("VZBRGITYUPSDNHLXAWMJQOFECK", "Z", 0, "V")
        }
    }

}

terminal.wheel = EnigmaWheel

function flipObject(obj) {
    let flipped = {}
    for (let key in obj) {
        flipped[obj[key]] = key
    }
    return flipped
}

class EnigmaPlugboard {

    constructor(swaps={}) {
        this.swaps = swaps
    }

    static fromString(str) {
        if (str == " ")
            return new EnigmaPlugboard({})

        // str is "AB CD EF GH IJ KL MN OP QR ST UV WX YZ"
        if (!/^(?:[A-Z]{2}\s)*$/.test(str)) {
            throw new Error("Invalid plugboard string")
        }

        let swaps = {}
        for (let pair of str.split(" ")) {
            if (pair.length == 0)
                continue
            if (pair.length == 2) {
                let flippedSwaps = flipObject(swaps)
                if (pair[0] in swaps || pair[1] in swaps
                    || pair[0] in flippedSwaps || pair[1] in flippedSwaps)
                    throw new Error("Cannot swap a letter with multiple letters")

                swaps[pair[0]] = pair[1]

                if (Object.keys(swaps).length > 10)
                    throw new Error("Too many swaps")

                if (pair[0] == pair[1])
                    throw new Error("Cannot swap a letter with itself")
            } else {
                throw new Error("Invalid plugboard string")
            }
        }

        return new EnigmaPlugboard(swaps)
    }

    get reverseSwaps() {
        return flipObject(this.swaps)
    }

    translate(letter) {
        if (letter in this.swaps) {
            return this.swaps[letter]
        }
        if (letter in this.reverseSwaps) {
            return this.reverseSwaps[letter]
        }
        return letter
    }

    toString() {
        let output = ""
        for (let key in this.swaps) {
            output += `${key}${this.swaps[key]} `
        }
        if (output.length > 0) {
            return output.slice(0, -1)
        } else {
            return "No swaps"
        }
    }

}

class EnigmaReflector extends EnigmaPlugboard {

    constructor(swaps, name) {
        super(swaps)
        this.name = name
    }

    static get DEFAULTS() {
        return {
            UKW_A: new EnigmaReflector({
                "A": "E", "B": "J", "C": "M", "D": "Z",
                "F": "L", "G": "Y", "H": "X", "I": "V",
                "K": "W", "N": "R", "O": "Q", "P": "U",
                "S": "T"
            }, "UKW-A"),
            UKW_B: new EnigmaReflector({
                "A": "Y", "B": "R", "C": "U", "D": "H",
                "E": "Q", "F": "S", "G": "L", "I": "P",
                "J": "X", "K": "N", "M": "O", "T": "Z",
                "V": "W"
            }, "UKW-B"),
            UKW_C: new EnigmaReflector({
                "A": "F", "B": "V", "C": "P", "D": "J",
                "E": "I", "G": "O", "H": "Y", "K": "R",
                "L": "Z", "M": "X", "N": "W", "Q": "T",
                "S": "U"
            }, "UKW-C")
        }
    }

}

class EnigmaMachine {

    constructor() {
        this.wheels = [
            EnigmaWheel.DEFAULTS.I,
            EnigmaWheel.DEFAULTS.II,
            EnigmaWheel.DEFAULTS.III
        ]
        this.reflector = EnigmaReflector.DEFAULTS.UKW_A
        this.plugboard = new EnigmaPlugboard()

        this.letterOutputs = null
        this.inputOutput = null
        this.encryptedOutput = null

        this.running = false

        this.keyListener = terminal.window.addEventListener("keydown", event => {
            let key = event.key.toUpperCase()
            if (this.running && !event.repeat && !event.ctrlKey && !event.altKey) {
                if (key.length == 1 && key.match(/[A-Z]/)) {
                    let output = this.input(key)
                    this.lightupLetter(output)
                }
            }
        })

        this.pendingTimeouts = []
    }

    clearPendingTimeouts() {
        this.pendingTimeouts.forEach(timeout => clearTimeout(timeout))
        this.pendingTimeouts = []
    }

    reset() {
        this.wheels.forEach(wheel => wheel.reset())
    }

    rotate() {
        let rotateNextWheel = true
        for (let i = this.wheels.length - 1; i >= 0; i--) {
            if (rotateNextWheel) {
                rotateNextWheel = this.wheels[i].rotate()
            }
        }
    }

    input(letter) {
        let translatedLetter = letter
        translatedLetter = this.plugboard.translate(translatedLetter)
        for (let i = this.wheels.length - 1; i >= 0; i--) {
            translatedLetter = this.wheels[i].translate(translatedLetter)
        }
        translatedLetter = this.reflector.translate(translatedLetter)
        for (let i = 0; i < this.wheels.length; i++) {
            translatedLetter = this.wheels[i].translate(translatedLetter, true)
        }
        translatedLetter = this.plugboard.translate(translatedLetter)

        this.rotate()

        if (this.inputOutput) {
            this.inputOutput.textContent += letter
            this.encryptedOutput.textContent += translatedLetter
        }

        return translatedLetter
    }

    lightupLetter(letter, destroyElse=true, ms=1000) {
        if (!this.letterOutputs) {
            return
        }

        if (destroyElse) {
            this.clearPendingTimeouts()
        }

        for (let key in this.letterOutputs) {
            if (key == letter) {
                this.letterOutputs[key].style.backgroundColor = "var(--accent-color-1)"
                this.letterOutputs[key].style.color = "var(--background)"
                this.pendingTimeouts.push(setTimeout(() => {
                    this.letterOutputs[key].style.backgroundColor = "var(--background)"
                    this.letterOutputs[key].style.color = "var(--foreground)"
                }, ms))
            } else if (destroyElse) {
                this.letterOutputs[key].style.backgroundColor = "var(--background)"
                this.letterOutputs[key].style.color = "var(--foreground)"
            }
        }
    }

    printKeyboard() {
        this.letterOutputs = {}

        //  Q W E R T Z U I O
        //   A S D F G H J K
        //  P Y X C V B N M L

        const printLetter = letter => {
            let element = null
            for (let char of letter) {
                let temp = terminal.print(char, undefined, {forceElement: true})
                if (/[A-Z]/.test(char)) {
                    element = temp
                }
            }
            return element
        }

        terminal.printLine("+" + "-".repeat(19) + "+")
        terminal.print("| ")

        this.letterOutputs["Q"] = printLetter("Q ")
        this.letterOutputs["W"] = printLetter("W ")
        this.letterOutputs["E"] = printLetter("E ")
        this.letterOutputs["R"] = printLetter("R ")
        this.letterOutputs["T"] = printLetter("T ")
        this.letterOutputs["Z"] = printLetter("Z ")
        this.letterOutputs["U"] = printLetter("U ")
        this.letterOutputs["I"] = printLetter("I ")
        this.letterOutputs["O"] = printLetter("O")

        terminal.printLine(" |")
        terminal.print("| ")

        this.letterOutputs["A"] = printLetter(" A ")
        this.letterOutputs["S"] = printLetter("S ")
        this.letterOutputs["D"] = printLetter("D ")
        this.letterOutputs["F"] = printLetter("F ")
        this.letterOutputs["G"] = printLetter("G ")
        this.letterOutputs["H"] = printLetter("H ")
        this.letterOutputs["J"] = printLetter("J ")
        this.letterOutputs["K"] = printLetter("K ")

        terminal.printLine(" |")
        terminal.print("| ")

        this.letterOutputs["P"] = printLetter("P ")
        this.letterOutputs["Y"] = printLetter("Y ")
        this.letterOutputs["X"] = printLetter("X ")
        this.letterOutputs["C"] = printLetter("C ")
        this.letterOutputs["V"] = printLetter("V ")
        this.letterOutputs["B"] = printLetter("B ")
        this.letterOutputs["N"] = printLetter("N ")
        this.letterOutputs["M"] = printLetter("M ")
        this.letterOutputs["L"] = printLetter("L")

        terminal.printLine(" |")
        terminal.printLine("+" + "-".repeat(19) + "+")

        for (let [letter, element] of Object.entries(this.letterOutputs)) {
            element.classList.add("clickable")

            element.addEventListener("click", () => {
                if (!this.running) {
                    return
                }
                let translatedLetter = this.input(letter)
                this.lightupLetter(translatedLetter)
            })
        }

        terminal.printLine()
        terminal.print("Input:  ")
        this.inputOutput = terminal.print("", undefined, {forceElement: true})
        terminal.printLine()
        terminal.print("Output: ")
        this.encryptedOutput = terminal.print("", undefined, {forceElement: true})
        terminal.printLine()
    }

}

let enigmaMachine = new EnigmaMachine()
terminal.enigma = enigmaMachine

terminal.addCommand("enigma", async function(args) {
    function printHelp() {
        const printOpt = (opt, desc) => terminal.printCommand(` -${opt}: ${desc}`, `enigma -${opt}`)

        terminal.printLine("Use one of the following arguments:")
        printOpt("t", "translation mode")
        printOpt("c", "config mode")
        printOpt("s", "show current settings")
        printOpt("r", "reset")
    }

    let numArgsSpecified = [args.c, args.t, args.r, args.s].map(Boolean).reduce((a, b) => a + b, 0)
    if (numArgsSpecified > 1) {
        terminal.printError("Too many arguments specified")
        printHelp()
        return
    }

    if (args.s) {

        terminal.printLine("Current settings:")
        terminal.printLine(` - Rotors:`)
        for (let rotor of enigmaMachine.wheels) {
            terminal.printLine(`   - Rotor#${rotor.name} (${rotor.toString()})`)
        }
        terminal.printLine(` - Reflector: ${enigmaMachine.reflector.name} (${enigmaMachine.reflector.toString()})`)
        terminal.printLine(` - Plugboard: ${enigmaMachine.plugboard.toString()}`)

    } else if (args.c) {

        let availableRotors = Object.keys(EnigmaWheel.DEFAULTS)
        let availableReflectors = Object.keys(EnigmaReflector.DEFAULTS)

        const choose = async (msg, options, wheel=false) => {
            terminal.printLine(msg)
            let i = 0
            for (let [name, value] of Object.entries(options)) {
                terminal.printLine(`  [${i + 1}] ${name} (${value})`)
                i++
            }
            let input = await terminal.promptNum(`Choose a number [1-${i}]: `, {min: 1, max: i})
            let returnValue = Object.values(options)[input - 1]
            if (wheel) {
                let offset = await terminal.promptNum("Choose an offset [1-26]: ", {min: 1, max: 26})
                returnValue.offset = offset - 1
            }
            terminal.printLine()
            return returnValue
        }

        const choosePlugboard = async () => {
            terminal.printLine("Enter the plugboard settings (e.g. AB CD EF)")
            terminal.printLine("Leave empty to use the default plugboard")
            const promptP = async () => {
                return await terminal.prompt("> ")
            }
            while (true) {
                let input = (await promptP()).trim() + " "
                try {
                    return EnigmaPlugboard.fromString(input)
                } catch (e) {
                    terminal.printError(e.message)
                }
            }
        }

        let rotors = []
        rotors.push(await choose("Choose the first Rotor", EnigmaWheel.DEFAULTS, true))
        rotors.push(await choose("Choose the second Rotor", EnigmaWheel.DEFAULTS, true))
        rotors.push(await choose("Choose the third Rotor", EnigmaWheel.DEFAULTS, true))

        let reflector = await choose("Choose the reflector", EnigmaReflector.DEFAULTS)

        let plugboard = await choosePlugboard()

        enigmaMachine.wheels = rotors
        enigmaMachine.reflector = reflector
        enigmaMachine.plugboard = plugboard

        terminal.printSuccess("Enigma machine configured")

        terminal.print("Use ")
        terminal.printCommand("enigma -s", "enigma -s", undefined, false)
        terminal.printLine(" to see the current settings")

    } else if (args.t) {

        terminal.printLine("Click on a letter to translate it (Use Ctrl+C to exit)\n")
        enigmaMachine.printKeyboard()
        enigmaMachine.running = true

        terminal.onInterrupt(() => {
            enigmaMachine.running = false
        })

        terminal.scroll()

        while (enigmaMachine.running) {
            await sleep(100)
        }

    } else if (args.r) {

        enigmaMachine.reset()
        terminal.printSuccess("Enigma machine reset")
        terminal.printLine("All Rotors are now set to A again")

    } else {
        terminal.printError("No arguments specified")
        printHelp()
    }
}, {
    description: "Simulate an Enigma machine",
    args: {
        "?c=config:b": "Enables config mode",
        "?t=translate:b": "Enables translation mode",
        "?r=reset:b": "Resets the machine",
        "?s=show:b": "Shows the current settings"
    }
})

// ------------------- js/commands/error404.js --------------------
const warningText = `
 _  _    ___  _  _                            _        __                      _ 
| || |  / _ \\| || |                          | |      / _|                    | |
| || |_| | | | || |_              _ __   ___ | |_    | |_  ___ _   _ _ __   __| |
|__   _| | | |__   _|    ____    | '_ \\ / _ \\| __|   |  _|/ _ \\|| | | '_ \\ / _\` |
   | | | |_| |  | |     |____|   | | | | (_) | |_    | | | (_) ||_| | | | | (_| |
   |_|  \\___/   |_|              |_| |_|\\___/ \\__|   |_|  \\___/\\__,_|_| |_|\\__,_|

You have encountered a 404 error. This means that the page you are looking for
does not exist. Maybe you mistyped the URL? Or maybe the page has been moved or
deleted? Either way, you should try to find what you are looking for elsewhere.

To continue to the terminal homepage, press any key.`

terminal.addCommand("error404", async function() {
    terminal.clear(false)
    terminal.printLine(warningText)
    terminal.print("Alternatively, you can use this link: ")
    terminal.printLink("https://noel-friedrich.de/terminal/", "https://noel-friedrich.de/terminal/")

    terminal.window.addEventListener("keydown", () => {
        terminal.href("https://noel-friedrich.de/terminal/")
    })

    return new Promise(resolve => {})
}, {
    description: "Display a 404 error",
    rawArgMode: true
})

// ------------------- js/commands/eval.js --------------------
terminal.addCommand("eval", async function(argString) {
    await terminal.modules.load("mathenv", terminal)
    let [result, error] = terminal.modules.mathenv.eval(argString)
    if (error) {
        terminal.print("> ")
        terminal.printLine(error)
    } else if (result !== null) {
        terminal.print("> ")
        terminal.printLine(result)
    }
}, {
    description: "evaluate javascript code",
    rawArgMode: true
})

// ------------------- js/commands/exit.js --------------------
terminal.addCommand("exit", function() {
    terminal.printLine(`please don't exit. please.`)
}, {
    description: "exit the terminal"
})



// ------------------- js/commands/f-optimize.js --------------------
terminal.addCommand("f-optimize", async function(args) {
    if (args.seconds < 0) {
        throw new Error("Argument 'seconds' can't be negative.")
    }

    if (!args.names) {
        args.names = "alex ben colin"
    }

    const friendNames = args.names.split(" ").map(n => n.toLowerCase())

    async function randomFriendScore(friendName) {
        const msgBuffer = new TextEncoder().encode(friendName)
        const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer)
        const hashArray = Array.from(new Uint8Array(hashBuffer))
        const score = hashArray[0] * 256 + hashArray[1]
        return score / (256 * 256) * 10
    }

    async function error(nonce) {
        let worstScore = 10
        for (const name of friendNames) {
            const score = await randomFriendScore(name + nonce)
            worstScore = Math.min(worstScore, score)
        }
        return worstScore
    }

    let bestScore = -Infinity
    let nonceIndex = 0
    const startTime = Date.now()
    let bestNonce = null

    let stopFlag = false

    while (Date.now() - startTime < args.seconds * 1000) {
        const nonce = (nonceIndex).toString()
        const worstNonceScore = await error(nonce)
        
        if (worstNonceScore > bestScore) {
            terminal.printLine(`nonce: "${nonce}" worstScore=${worstNonceScore}`)
            bestScore = worstNonceScore
            bestNonce = nonce
            
            const scoreNameObj = []
            for (const name of friendNames) {
                const score = await randomFriendScore(name + bestNonce)
                scoreNameObj.push([name, score.toFixed(2)])
            }
            terminal.printLine(scoreNameObj.map(([n, s]) => `${n}=${s}`).join(", "))
            terminal.addLineBreak()

            terminal.scroll()
        }

        nonceIndex++

        if (nonceIndex % 100 == 0) {
            await sleep(0)
        }
    }
}, {
    args: {
        "?*names": "names to optimize",
        "?s=seconds:i": "how long to optimize for (seconds)"
    },
    defaultValues: {
        seconds: 99999999
    },
    description: "finds a good nonce value for the friendship score generator"
})

// ------------------- js/commands/f.js --------------------
terminal.addCommand("f", async function(args) {
    const round = (num, places) => Math.round(num * 10**places) / 10**places

    async function randomFriendScore(friendName) {
        const msgBuffer = new TextEncoder().encode(friendName)
        const hashBuffer = await crypto.subtle.digest("SHA-256", msgBuffer)
        const hashArray = Array.from(new Uint8Array(hashBuffer))
        const score = hashArray[0] * 256 + hashArray[1]
        return round(score / (256 * 256) * 10, 2)
    }

    const lowerCaseName = args.name.toLowerCase()
    const friendScore = await randomFriendScore(lowerCaseName + "pXxThFnonv4Qtbzz")

    terminal.printLine(`friendship score with ${args.name}: ${friendScore}/10`)
}, {
    description: "calculate friendship score with a friend",
    args: {
        "*name": "name of friend"
    }
})



// ------------------- js/commands/factor.js --------------------
terminal.addCommand("factor", async function(args) {
    function primeFactors(n) {
        let i = 2n
        let factors = []
        while (i * i <= n) {
            if (n % i) {
                i++
            } else {
                n /= i
                factors.push(i)
            }
        }
        if (n > 1n) {
            factors.push(n)
        }
        return factors
    }

    function printFactors(num) {
        let factors = primeFactors(num).join(" ")
        if (factors.length == 0 || isNaN(parseInt(num))) {
            terminal.printLine(`${num}: Invalid number!`)
        } else {
            terminal.print(num + ": ")
            terminal.printLine(factors, Color.COLOR_1)
        }
    }

    if (args.n != null) {
        printFactors(args.n)
        return
    }

    terminal.printLine("Type a number to factorize it.")

    while (true) {
        let text = await terminal.prompt()
        for (let word of text.trim().split(" ").map(w => w.trim()).filter(w => w.length > 0)) {
            if (word.length == 0 || isNaN(word)) {
                terminal.printLine(`${word}: Invalid number!`)
            } else {
                let num = BigInt(word)
                printFactors(num)
            }
        }
    }
}, {
    description: "print the prime factors of a number",
    args: {
        "?n:bn": "number to factorize"
    },
    standardVals: {
        n: null
    }
})

// ------------------- js/commands/fakechat.js --------------------
async function loadImage(url) {
    return new Promise((resolve, reject) => {
        let img = new Image()
        img.onload = () => resolve(img)
        img.onerror = reject    
        img.src = url
    })
}

// stolen from https://stackoverflow.com/questions/2936112/text-wrap-in-a-canvas-element
function getLines(ctx, text, maxWidth) {
    var words = text.split(" ");
    var lines = [];
    var currentLine = words[0];

    for (var i = 1; i < words.length; i++) {
        var word = words[i];
        var width = ctx.measureText(currentLine + " " + word).width;
        if (width < maxWidth) {
            currentLine += " " + word;
        } else {
            lines.push(currentLine);
            currentLine = word;
        }
    }
    lines.push(currentLine);
    return lines;
}

class ChatMessage {

    constructor(text, side, hasTick) {
        this.text = text
        this.side = side
        this.hasTick = hasTick
    }

}

class Chat {

    static whatsappLowerUrl = "https://noel-friedrich.de/terminal/res/img/fakechat/whatsapp-lower.png"
    static whatsappUpperUrl = "https://noel-friedrich.de/terminal/res/img/fakechat/whatsapp-upper.png"

    constructor() {
        this.messages = []
        this.chatName = "My Friend"
        this.chatImage = "https://imgur.com/D1DjO7T.png"
        this.backgroundColor = Color.hex("#000000")
        this.backgroundImage = "https://noel-friedrich.de/terminal/res/img/fakechat/default-background.png"
        this.resolution = [720, 1560]
        // set this.time to time now in 12:00 format
        this.time = new Date().toLocaleTimeString("en-US", {hour: "2-digit", minute: "2-digit", hour12: false})
        this.bubbleOffset = 0
        this.textSizeFactor = 1
    }

    addMessage(text, side) {
        let lastMessage = this.messages[this.messages.length - 1]
        let hasTick = lastMessage == null || lastMessage.side != side
        this.messages.push(new ChatMessage(text, side, hasTick))
    }

    get resolutionWidth() {
        return this.resolution[0]
    }

    get resolutionHeight() {
        return this.resolution[1]
    }

    async exportToCanvas() {
        let lowerImg = await loadImage(Chat.whatsappLowerUrl)
        let upperImg = await loadImage(Chat.whatsappUpperUrl)

        let canvas = document.createElement("canvas")
        canvas.width = this.resolutionWidth
        canvas.height = this.resolutionHeight
        let context = canvas.getContext("2d")
        context.fillStyle = this.backgroundColor.toString()
        context.fillRect(0, 0, canvas.width, canvas.height)

        let helvetica = new FontFace("Helvetica", "url(res/fonts/Helvetica.ttf)")
        await helvetica.load()
        document.fonts.add(helvetica)

        let helveticaBold = new FontFace("HelveticaBold", "url(res/fonts/Helvetica-Bold.ttf)", {
            weight: "bold"
        })
        await helveticaBold.load()
        document.fonts.add(helveticaBold)

        let bubbleTextSize = canvas.height * 0.022 * this.textSizeFactor
        let bubbleRadius = bubbleTextSize * 0.8
        let bubblePadding = bubbleTextSize * 0.5
        let sidePadding = canvas.width * 0.05
        
        function drawBubbleBox(x, y, width, height, withTick=false, tickLeft=true, color=Color.WHITE) {
            context.fillStyle = color.toString()
            context.beginPath()
            context.moveTo(x + bubbleRadius, y)
            context.lineTo(x + width - bubbleRadius, y)
            context.quadraticCurveTo(x + width, y, x + width, y + bubbleRadius)
            context.lineTo(x + width, y + height - bubbleRadius)
            context.quadraticCurveTo(x + width, y + height, x + width - bubbleRadius, y + height)
            context.lineTo(x + bubbleRadius, y + height)
            context.quadraticCurveTo(x, y + height, x, y + height - bubbleRadius)
            context.lineTo(x, y + bubbleRadius)
            context.quadraticCurveTo(x, y, x + bubbleRadius, y)
            context.fill()
            if (withTick && tickLeft) {
                let tickRadius = bubbleRadius * 0.5
                const SINCOS = Math.sin(Math.PI / 4)
                context.beginPath()
                context.moveTo(x - bubbleRadius + tickRadius, y)
                context.lineTo(x + bubbleRadius, y)
                context.lineTo(x + bubbleRadius, y + bubbleRadius * 2)
                context.lineTo(x - bubbleRadius + tickRadius * SINCOS, y + tickRadius * SINCOS)
                context.quadraticCurveTo(x - bubbleRadius, y, x - bubbleRadius + tickRadius, y)
                context.fill()
            } else if (withTick && !tickLeft) {
                let tickRadius = bubbleRadius * 0.5
                const SINCOS = Math.sin(Math.PI / 4)
                context.beginPath()
                context.moveTo(x + width + bubbleRadius - tickRadius, y)
                context.lineTo(x + width - bubbleRadius, y)
                context.lineTo(x + width - bubbleRadius, y + bubbleRadius * 2)
                context.lineTo(x + width + bubbleRadius - tickRadius * SINCOS, y + tickRadius * SINCOS)
                context.quadraticCurveTo(x + width + bubbleRadius, y, x + width + bubbleRadius - tickRadius, y)
                context.fill()
            }
        }

        let currBubbleY = 0

        function drawBubble(side, text, withTick=true) {
            if (withTick) currBubbleY += bubblePadding
            let isLeft = (side == "left")
            let color = isLeft ? Color.hex("#ffffff") : Color.hex("#e7ffdb")
            let x = isLeft ? sidePadding : canvas.width - sidePadding
            let textStartX = isLeft ? x + bubblePadding : x - bubblePadding
            let textStartY = currBubbleY + bubblePadding
            context.font = `${bubbleTextSize}px Helvetica`
            let lines = getLines(context, text, canvas.width * 0.7)
            let lineHeight = context.measureText("M").width * 1.2
            let textHeight = lines.length * lineHeight
            let maxTextWidth = Math.max(...lines.map(line => context.measureText(line).width))
            x -= isLeft ? 0 : maxTextWidth + 2 * bubblePadding
            drawBubbleBox(x, currBubbleY, maxTextWidth + 2 * bubblePadding, textHeight + 2 * bubblePadding, withTick, isLeft, color)
            for (let line of lines) {
                context.fillStyle = Color.hex("#131b20").toString()
                context.textAlign = (side == "left") ? "left" : "right"
                context.textBaseline = "top"
                context.fillText(line, textStartX, textStartY)
                textStartY += lineHeight
            }
            currBubbleY += textHeight + 2 * bubblePadding + 5
        }

        let upperImgHeight = (upperImg.height / upperImg.width) * this.resolutionWidth
        let lowerImgHeight = (lowerImg.height / lowerImg.width) * this.resolutionWidth

        function drawChatName(chatName) {
            context.font = `${canvas.width * 0.045}px HelveticaBold`
            context.fillStyle = "white"
            context.textAlign = "left"
            context.textBaseline = "middle"
            context.fillText(chatName, canvas.width * 0.2, upperImgHeight * 0.7)
        }

        function drawTime(timeString) {
            context.font = `${canvas.width * 0.04}px Helvetica`
            context.fillStyle = "#a5e8dd"
            context.textAlign = "left"
            context.textBaseline = "middle"
            context.fillText(timeString, canvas.width * 0.063, upperImgHeight * 0.18)
        }

        async function drawChatImage(chatImageSrc) {
            let chatImg = await loadImage(chatImageSrc)
            context.beginPath()
            context.arc(canvas.width * 0.1285, canvas.width * 0.159, canvas.width * 0.05, 0, 2 * Math.PI)
            context.clip()
            context.drawImage(chatImg, canvas.width * 0.0785, canvas.width * 0.109, canvas.width * 0.1, canvas.width * 0.1)
        }

        currBubbleY = upperImgHeight

        if (this.bubbleOffset) {
            currBubbleY += this.bubbleOffset * canvas.height
        }

        if (this.backgroundImage) {
            let backgroundImg = await loadImage(this.backgroundImage)
            let imageWidth = (backgroundImg.width / backgroundImg.height) * canvas.height
            context.drawImage(backgroundImg, 0, 0, imageWidth, canvas.height)
        }

        for (let bubble of this.messages) {
            drawBubble(bubble.side, bubble.text, bubble.withTick)
        }

        context.drawImage(upperImg, 0, 0, canvas.width, upperImgHeight)
        context.drawImage(lowerImg, 0, canvas.height - lowerImgHeight - 20, canvas.width, lowerImgHeight)

        if (this.chatName) {
            drawChatName(this.chatName)
        }

        if (this.time) {
            drawTime(this.time)
        }

        if (this.chatImage) {
            await drawChatImage(this.chatImage)
        }
        
        return canvas
    }
}

terminal.addCommand("fakechat", async function(args) {
    let animationInterval = args.f ? 0 : 15

    const printLn = async msg => await terminal.animatePrint(msg, animationInterval)
    const promptLn = async (msg, regex, defaultValue=null) => {
        if (defaultValue) {
            msg += ` (default: ${defaultValue}): `
        } else {
            msg += ": "
        }

        while (true) {
            let result = await terminal.prompt(msg)
            if (result == "" && defaultValue) {
                return defaultValue
            } else if (regex.test(result)) {
                return result
            } else {
                await printLn("Invalid input. Please try again.")
            }
        }
    }

    let chat = new Chat()

    chat.textSizeFactor = args.s
    chat.bubbleOffset = args.o
    chat.resolution[0] = args.x
    chat.resolution[1] = args.y

    await printLn("Welcome to the fake chat generator!", animationInterval)
    await printLn("Together we will create a fake chat conversation.")
    terminal.addLineBreak()
    await printLn("First, we need to know the name of the chat.")
    await printLn("This could be 'Tom' or 'Mamamia'.")
    chat.chatName = await promptLn("Chat Name", /.+/)

    terminal.addLineBreak()
    await printLn("Great! Now let's add some messages.")
    await printLn("You can add as many messages as you want.")
    await printLn("- To add a message, type the message and press enter.")
    await printLn("- To finish adding messages, type 'done' or 'd'.")
    await printLn("- To switch sides, type 'switch' or 's'.")
    await printLn("- to undo the last message, type 'undo' or 'u'.")
    terminal.addLineBreak()
    let currSide = "right"
    const getName = side => side != "left" ? "You" : chat.chatName
    const changeSide = () => currSide = currSide == "left" ? "right" : "left"
    while (true) {
        let msg = await promptLn(getName(currSide), /.+/)
        if (msg == "done" || msg == "d") break
        if (msg == "switch" || msg == "s") {
            changeSide()
            continue
        }
        if (msg == "undo" || msg == "u") {
            if (chat.messages.pop()) {
                terminal.printSuccess("Removed last message.")
            } else {
                terminal.printError("No messages to remove.")
            }
            changeSide()
            continue
        }
        chat.addMessage(msg, currSide)
        changeSide()
    }

    terminal.addLineBreak()
    await printLn("Awesome! Now let's the current time.")
    await printLn("This could be '12:00' or '3:14'.")
    chat.time = await promptLn("Time", /[0-9]{1,2}\:[0-9]{1,2}/, chat.time)

    await terminal.modules.load("upload", terminal)

    terminal.addLineBreak()
    await printLn("Now let's add a profile picture.")
    await printLn("The profile picture will be displayed in the top left corner.")
    await printLn("You can either enter a URL or upload a file.")
    await printLn("To upload a file, type 'upload' or 'u'.")
    await printLn("Type 'default' to skip this step and use the default profile picture.")

    let defaultChatImage = chat.chatImage
    chat.chatImage = null
    while (chat.chatImage == null) {
        chat.chatImage = await promptLn("Profile Picture Url", /.+/)
        if (chat.chatImage == "default") {
            chat.chatImage = defaultChatImage
        } else if (chat.chatImage == "upload" || chat.chatImage == "u") {
            try {
                chat.chatImage = (await terminal.modules.upload.image()).src
            } catch (e) {
                chat.chatImage = null
            }
        } else {
            try {
                await loadImage(chat.chatImage)
            } catch (e) {
                terminal.printError("Invalid image URL.")
                chat.chatImage = null
            }
        }
    }

    terminal.addLineBreak()
    await printLn("Now let's add a background image.")
    await printLn("The background image will be displayed behind the chat.")
    await printLn("You can either enter a URL or upload a file.")
    await printLn("Type 'default' to skip this step and use the default background.")

    let defaultBackgroundImage = chat.backgroundImage
    chat.backgroundImage = null
    while (chat.backgroundImage == null) {
        chat.backgroundImage = await promptLn("Background Image Url", /.+/)
        if (chat.backgroundImage == "default") {
            chat.backgroundImage = defaultBackgroundImage
            break
        }
        if (chat.backgroundImage == "upload" || chat.backgroundImage == "u") {
            try {
                chat.backgroundImage = (await terminal.modules.upload.image()).src
            } catch (e) {
                chat.backgroundImage = null
            }
        } else {
            try {
                await loadImage(chat.backgroundImage)
            } catch (e) {
                terminal.printError("Invalid image URL.")
                chat.backgroundImage = null
            }
        }
    }

    terminal.addLineBreak()
    let canvas = await chat.exportToCanvas()
    terminal.parentNode.appendChild(canvas)
    canvas.classList.add("terminal-img")
    terminal._styleImgElement(canvas, true)
    terminal.addLineBreak()
}, {
    description: "fake a whatsapp chat conversation",
    args: {
        "?f=fast:b": "skip typing animations [fast mode]",
        "?o=offset:n:-100~100": "offset the chat by a procentage of the screen height",
        "?s=scale:n:0.1~5": "scale the chat by a factor",
        "?x=width:n:100~10000": "set the width of the screen in pixels",
        "?y=height:n:100~10000": "set the height of the screen in pixels",
    },
    standardVals: {
        o: 0,
        s: 1,
        x: 720,
        y: 1560,
    }
})

// ------------------- js/commands/fibo.js --------------------
terminal.addCommand("fibo", function(args) {
    let a = 0
    let b = 1

    if (args.phi && args.n < 3)
        throw new Error("n must be greater than 1 when using phi")

    let lastTwo = []

    for (let i = 0; i < args.n; i++) {
        terminal.printLine(a)
        lastTwo.push(a)
        if (lastTwo.length > 2)
            lastTwo.shift()

        let c = a + b
        a = b
        b = c
    }

    if (args.phi) {
        let [a, b] = lastTwo
        terminal.printLine(`phi ≈ ${b / a}`, Color.COLOR_1)
    }
}, {
    description: "Prints the Fibonacci sequence",
    args: { 
        "?n:i:1~100": "The number of elements to print",
        "?p=phi:b": "calculate the golden ratio using the last two elements"
    },
    defaultValues: {
        n: 10
    }
})

// ------------------- js/commands/fizzbuzz.js --------------------
terminal.addCommand("fizzbuzz", function(args) {
    let output = ""
    for (let i = 1; i <= args.max; i++) {
        let outs = ""
        if (i % 3 == 0) outs += "fizz"
        if (i % 5 == 0) outs += "buzz"
        if (outs == "") outs += i
        output += outs + "\n"
    }
    terminal.printLine(output.slice(0, -1))
},{
    description: "print the fizzbuzz sequence",
    args: {
        "?max:n:1~100000": "the maximum number to print"
    },
    standardVals: {
        max: 15
    }
})



// ------------------- js/commands/flaci-to-turing.js --------------------
terminal.addCommand("flaci-to-turing", async function(args) {
    const file = terminal.getFile(args.file)
    const code = file.content
    let outputCode = ""

    const write = (str, endline=true) => {
        outputCode += str
        if (endline)
            outputCode += "\n"
    }

    try {
        const json = JSON.parse(code)
        const name = json.name
        if (json.type != "TM")
            throw new Error("Not a Turing Machine")

        write(`// ${name} converted from flaci.com`)
        write(`// Converter by noel-friedrich.de\n`)

        const automaton = json.automaton

        const states = automaton.States

        if (automaton.simulationInput) {
            const inputs = automaton.simulationInput
            if (inputs.length > 0) {
                let input = inputs.join("")
                write(`; Start Tape Content: "${input}"`)
            }
        }

        const getState = id => {
            return states.find(state => state.ID == id)
        }

        for (let state of states) {
            let stateName = state.Name
            if (state.Start)
                write(`; Start State: "${stateName}"\n`)

            for (let transition of state.Transitions) {
                let targetState = getState(transition.Target)
                for (let label of transition.Labels) {

                    let [
                        content,
                        newContent,
                        direction
                    ] = label

                    if (direction == "R")
                        direction = "r"
                    else if (direction == "L")
                        direction = "l"
                    else if (direction == "N")
                        direction = "*"
                    else
                        throw new Error("Invalid Direction")

                    write(`${stateName} ${content} ${newContent} ${direction} ${targetState.Name}`)
                }
            }

            write("")
        }
    } catch (e) {
        terminal.printError("Invalid Flaci.com File")
        console.error(e)
        return
    }

    if (args.s) { // save
        await terminal.createFile(args.s, TextFile, outputCode)
        terminal.printLine(`Saved as ${args.s}`)
    } else {
        terminal.printLine(outputCode)
    }
}, {
    description: "Converts a flaci.com JSON File of a turing machine to a turing machine file",
    args: {
        "file": "file to convert",
        "?s=save:b": "save the converted file"
    },
    isSecret: true,
    helpFunc() {
        terminal.addLineBreak()
        terminal.printLink("flaci.com", "https://flaci.com/", undefined, false)
        terminal.printItalic(" lets you create Turing Machines")
        terminal.printItalic("graphically. This command converts the")
        terminal.printItalic("JSON file of a Turing Machine to a Turing")
        terminal.printItalic("Machine file that can be used in this")
        terminal.printItalic("terminal using the 'turing' command.")
    }
})

// ------------------- js/commands/flappy.js --------------------
terminal.addCommand("flappy", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({name: "Flappy Turtlo", fullscreen: args.f})

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT
    context.imageSmoothingEnabled = false
    
    const fps = 44

    let gameRunning = true

    const gravity = canvas.height / 700
    const jump = canvas.height / -40

    function clearCanvas() {
        context.fillStyle = "black"
        context.fillRect(0, 0, canvas.width, canvas.height)
    }

    class Turtlo {

        constructor() {
            this.y = 0
            this.velY = 0
            this.imageSrc = "res/img/turtlo/walking-0.png"
            this.image = null
            this.imageX = 64
            this.dead = false
        }

        get rotation() {
            if (this.dead) return Math.PI
            return Math.min(Math.max(this.velY / 10, -1), 1) + Math.PI / 2
        }

        get points() {
            return [
                new Vector2d(this.x - this.imageX / 2, this.y - this.imageY / 2),
                new Vector2d(this.x + this.imageX / 2, this.y - this.imageY / 2),
                new Vector2d(this.x + this.imageX / 2, this.y + this.imageY / 2),
                new Vector2d(this.x - this.imageX / 2, this.y + this.imageY / 2)
            ]
        }

        jump() {
            if (this.dead) return
            this.velY = jump
            if (!args.silent) {
                playFrequency(400, 100, 0.5)
                setTimeout(() => playFrequency(500, 50, 0.5), 50)
            }
        }

        get x() {
            return canvas.width * (1 / 5)
        }

        async loadImage() {
            let image = new Image()
            image.src = this.imageSrc
            await new Promise(resolve => image.onload = resolve)
            this.image = image
            this.imageY = this.imageX * (image.height / image.width)
        }

        update() {
            this.velY += gravity
            this.y += this.velY

            if (this.y > canvas.height) {
                this.y = canvas.height
                this.velY = 0
            }

            if (this.y < 0) {
                this.y = 0
                this.velY = 0
            }

            if (this.dead && this.y == canvas.height) {
                gameRunning = false
            }
        }

        draw() {
            context.save()
            context.translate(this.x, this.y)
            context.rotate(this.rotation)
            context.drawImage(this.image, -this.imageX / 2, -this.imageY / 2, this.imageX, this.imageY)
            context.restore()
        }

        die() {
            this.dead = true
            if (!args.silent)
                playFrequency(300, 1000)
        }

    }

    const turtlo = new Turtlo()
    await turtlo.loadImage()

    class Wall {

        generateHole() {
            this.holeStartRelative = Math.random()
            this.holeSizeRelative = 0.4
        }

        constructor(n) {
            this.number = n
            this.x = canvas.width
            this.generateHole()
            while (this.holeStartRelative + this.holeSizeRelative > 1) {
                this.generateHole()
            }
        }

        get velX() {
            return -4
        }

        get width() {
            return 100
        }

        get height() {
            return canvas.height
        }

        get holeStart() {
            return this.holeStartRelative * this.height
        }

        get holeSize() {
            return this.holeSizeRelative * this.height
        }

        get touching() {
            return turtlo.touching(this.x, this.y) || turtlo.touching(this.x, this.y + this.height)
        }

        update() {
            this.x += this.velX
        }

        draw() {
            context.fillStyle = "white"
            context.fillRect(this.x, 0, this.width, this.holeStart)
            context.fillRect(
                this.x,
                this.holeStart + this.holeSize,
                this.width,
                this.height
            )
        }

        drawNumber() {
            context.fillStyle = "white"
            context.font = "48px monospace"
            context.textAlign = "center"
            context.textBaseline = "middle"
            context.fillText(this.number, this.x + this.width / 2, this.holeStart + this.holeSize / 2)
        }

        collision() {
            for (let point of turtlo.points) {
                if (point.x > this.x && point.x < this.x + this.width) {
                    if (point.y < this.holeStart || point.y > this.holeStart + this.holeSize) {
                        turtlo.die()
                    }
                }
            }
        }

    }

    let walls = []

    let wallSpawnCount = 0
    let wallSpawnInterval = 100
    let score = 0

    const intervalKey = setInterval(() => {
        if (!gameRunning)
            return

        clearCanvas()

        for (let wall of walls) {
            wall.update()
            wall.drawNumber()
        }

        turtlo.update()
        turtlo.draw()

        for (let wall of walls) {
            wall.draw()
            wall.collision()
        }

        wallSpawnCount++
        if (wallSpawnCount >= wallSpawnInterval) {
            walls.push(new Wall(score++))
            wallSpawnCount = 0
        }

        walls = walls.filter(wall => wall.x > -wall.width)
    }, 1000 / fps)

    addEventListener("keydown", e => {
        if (!gameRunning) return
        if (e.key == " ")
            turtlo.jump()
    })

    addEventListener("touchstart", e => {
        if (!gameRunning) return
        turtlo.jump()
    })

    terminal.onInterrupt(() => {
        terminalWindow.close()
        gameRunning = false
        clearInterval(intervalKey)
    })

    while (gameRunning) {
        await sleep(100)
    }

    terminalWindow.close()
    clearInterval(intervalKey)

    terminal.printLine(`Your score: ${score}`)
    await HighscoreApi.registerProcess("flappy")
    await HighscoreApi.uploadScore(score)

}, {
    description: "play a game of flappy turtlo",
    args: {
        "?f=fullscreen:b": "fullscreen",
        "?s=silent:b": "silent mode"
    },
    isGame: true
})

// ------------------- js/commands/font.js --------------------
const OG_FONT = 

terminal.addCommand("font", function(args) {
    if (args.font.toLowerCase() == "reset") {
        terminal.data.font = terminal.data.getDefault("font")
        return
    }
    terminal.data.font = args.font
}, {
    description: "change the font of the terminal",
    args: ["*font"]
})


// ------------------- js/commands/foreground.js --------------------
const OG_FOREGROUND_COLOR = Color.rgb(255, 255, 255)

terminal.addCommand("foreground", function(args) {
    if (args.color.toLowerCase() == "reset") {
        terminal.data.foreground = OG_FOREGROUND_COLOR
        return
    }
    let color = parseColor(args.color)
    let distance = terminal.data.background.distanceTo(color)
    if (distance >= 80) {
        terminal.data.foreground = color
    } else {
        throw new Error("The foreground color is too close to the background color")
    }
}, {
    description: "change the foreground color of the terminal",
    args: {
        "color": "the color to change the foreground to"
    }
})

// ------------------- js/commands/fraction.js --------------------
terminal.addCommand("fraction", function(args) {
    let n = args.n

    let bestFraction = null
    let bestError = Infinity
    for (let denominator = 1; denominator < args.d; denominator++) {
        let numerator = Math.round(n * denominator)
        const newValue = numerator / denominator
        
        const error = Math.abs(n - newValue)

        if (error == 0) {
            bestFraction = [numerator, denominator]
            break
        }

        if (error < bestError) {
            bestError = error
            bestFraction = [numerator, denominator]
        }
    }

    const fractionN = bestFraction[0] / bestFraction[1]

    const error = fractionN - n
    terminal.print("Best result: ")
    terminal.printLine(`${bestFraction[0]}/${bestFraction[1]}`, Color.COLOR_1)

    // print comparison

    const strFractionN = fractionN.toString()
    const strN = n.toString()
    terminal.print("           = ")
    for (let i = 0; i < strFractionN.length; i++) {
        let isCorrect = false
        if (i < strN.length) {
            isCorrect = strFractionN[i] == strN[i]
        }

        const color = isCorrect ? Color.fromHex("#00ff00") : Color.ERROR
        terminal.print(strFractionN[i], Color.BLACK, {background: color})
    }
    terminal.addLineBreak()

    if (error != 0) {
        terminal.printLine(`approximate error: ${error}`)
    }
}, {
    description: "find a fraction from a decimal number",
    args: {
        "n=number:n": "number (decimal)",
        "?d=max-denominator:i:1~999999999": "maximum denominator",
    },
    defaultValues: {
        d: 1000
    }
})

// ------------------- js/commands/freq.js --------------------
terminal.addCommand("freq", async function(args) {
    await playFrequency(args.f, args.t * 1000)

    if (args.f == 3500) {
        terminal.print("Random Fun Fact! ", Color.COLOR_1)
        terminal.printEasterEgg("Loudest-Egg")
        terminal.printLine("According to some research, the perceived loundness of")
        terminal.printLine("sounds is actually very different from the actual amplitude")
        terminal.printLine("of the soundwaves. For example, a frequency of 3500 is")
        terminal.printLine("found to be the perceived* loudest that a speaker can play!")
    }
}, {
    description: "play a frequency for an amount of time",
    args: {
        "f=frequency:n:0~30000": "the frequency to play",
        "?t=time:n:0~9999": "time in seconds to play frequency"
    },
    defaultValues: {
        time: 0.5
    }
})

// ------------------- js/commands/games.js --------------------
terminal.addCommand("games", function() {
    let gameCommands = Object.entries(terminal.commandData)
        .filter(([_, info]) => info.isGame)
        .map(([name, _]) => name)
    let longestCommandLength = gameCommands.reduce((p, c) => Math.max(p, c.length), 0)
    for (let command of gameCommands.sort((a, b) => a.localeCompare(b))) {
        terminal.printCommand(command, command, Color.PURPLE, false)
        let spaces = strRepeat(" ", longestCommandLength - command.length + 2)
        let description = terminal.allCommands[command]
        terminal.printLine(`${spaces}${description}`)
    }
}, {
    description: "shows the game menu",
})

// ------------------- js/commands/get.js --------------------
terminal.addCommand("get", async function(args) {
    await terminal.modules.load("cliapi", terminal)
    const CliApi = terminal.modules.cliapi
    if (!CliApi.KEY_REGEX.test(args.key)) {
        terminal.printError("Invalid key")
        return
    }
    let value = await CliApi.get(args.key)
    terminal.print(">>> ", Color.COLOR_2)
    terminal.printLine(value)
}, {
    description: "get a value from the server",
    args: {
        key: "the key to get the value of"
    },
    disableEqualsArgNotation: true
})



// ------------------- js/commands/greed.js --------------------
terminal.addCommand("greed", async function(args) {
    await terminal.modules.import("game", window)

    args.w = 30
    args.h = 20

    if (args.b) {
        args.w *= 2
        args.h *= 2
    }

    let gameName = "greed" + (args.b ? ":big" : "")

    let numberColors = [undefined]
    let numColors = 9
    for (let i = 0; i < numColors; i++) {
        let color = `hsl(${i / numColors * 360}deg, 30%, 50%)`
        numberColors.push(color)
    }

    class Player {

        constructor(pos) {
            this.pos = pos
            this.score = 0
        }

    }

    class Game {

        initData(fillFunc) {
            this.data = []
            for (let y = 0; y < this.size.y; y++) {
                let dataRow = []
                for (let x = 0; x < this.size.x; x++) {
                    dataRow.push(fillFunc(x, y))
                }
                this.data.push(dataRow)
            }
        }

        get(x, y) {
            return this.data[y][x]
        }

        getPos(pos) {
            return this.get(pos.x, pos.y)
        }

        set(x, y, value) {
            this.data[y][x] = value
            this.elements[y][x].textContent = value
            this.elements[y][x].style.color = numberColors[value]
        }

        getElement(pos) {
            return this.elements[pos.y][pos.x]
        }

        firstDraw() {
            this.elements = []

            const drawLine = () => terminal.printLine("+" + "-".repeat(this.size.x * 2 + 1) + "+")

            terminal.addLineBreak()
            drawLine()
            for (let y = 0; y < this.size.y; y++) {
                let row = []
                terminal.print("| ")
                for (let x = 0; x < this.size.x; x++) {
                    let pos = new Vector2d(x, y)
                    let element = terminal.print(this.get(x, y), undefined, {forceElement: true})
                    terminal.print(" ")
                    element.style.color = numberColors[this.get(x, y)]
                    row.push(element)
                    element.style.cursor = "pointer"
                    element.onclick = event => {
                        if (!this.running || this.processing) return
                        let relative = this.player.pos.sub(pos).scale(-1)
                        if (relative.length == 1) {
                            this.movePlayer(relative)
                        }
                    }
                }
                terminal.print("|")
                terminal.addLineBreak()
                this.elements.push(row)
            }
            drawLine()
            terminal.print("| Score: ")
            this.scoreOutput = terminal.print("0000")
            terminal.print(" | Next Highscore: ")
            this.highscoreOutput = terminal.print()
            terminal.printLine("|")
            drawLine()
        }

        async updateScore() {
            this.scoreOutput.textContent = stringPad(this.player.score, 4, "0")
            let highscore = await this.getNextHighscore()
            if (args.b) {
                this.highscoreOutput.textContent = stringPadBack(highscore.slice(0, 89), 90)
            } else {
                this.highscoreOutput.textContent = stringPadBack(highscore.slice(0, 29), 30)
            }
        }

        inBounds(pos) {
            return pos.x >= 0 && pos.x < this.size.x && pos.y >= 0 && pos.y < this.size.y
        }

        async movePlayer(direction) {
            this.processing = true
            let newPos = this.player.pos.add(direction)
            if (!this.inBounds(newPos) || this.getPos(newPos) == " ") {
                this.running = false
                this.drawPlayer(true)
                this.processing = false
                return
            }
            let value = this.getPos(newPos)
            this.player.pos.iadd(direction)
            this.player.score++
            for (let i = 0; i < value - 1; i++) {
                await sleep(10)
                this.player.score++
                this.drawPlayer(true)
                let newPos = this.player.pos.add(direction)
                if (!this.inBounds(newPos) || this.getPos(newPos) == " ") {
                    this.running = false
                    this.drawPlayer(true)
                    this.processing = false
                    return
                }
                this.player.pos = newPos
            }
            this.drawPlayer(true)
            this.processing = false
        }

        removeHeads() {
            for (let y = 0; y < this.size.y; y++) {
                for (let x = 0; x < this.size.x; x++) {
                    let value = this.get(x, y)
                    if (value == "@") {
                        this.set(x, y, " ")
                    }
                }
            }
        }

        drawPlayer(drawHead) {
            this.set(this.player.pos.x, this.player.pos.y, " ")
            let element = this.getElement(this.player.pos)
            element.style.color = "white"
            if (drawHead) {
                this.removeHeads()
                this.set(this.player.pos.x, this.player.pos.y, "@")
            }
        }

        async getNextHighscore() {
            if (!this.highscores) return "Loading..."
            let backwards = this.highscores.slice().reverse()
            let score = backwards.find(score => score.score > this.player.score)
            let rank = await HighscoreApi.getRank(gameName, this.player.score, this.highscores)
            return score ? `${stringPad(score.score, 4, "0")} by ${score.name} (#${rank})` : "You got the highscore!"
        }

        async cacheHighscores() {
            let highscores = await HighscoreApi.getHighscores(gameName)
            this.highscores = highscores
        }

        constructor(width, height) {
            this.size = new Vector2d(width, height)
            this.initData(() => Math.floor(Math.random() * 9) + 1)
            this.firstDraw()
            this.player = new Player(this.size.scale(0.5).map(Math.floor))
            this.running = true
            this.processing = false
            this.cacheHighscores()
        }

    }

    class Solver {

        static callCount = 0

        static evalPos(data, playerX, playerY, score, currDepth=1, maxDepth=2) {
            this.callCount++

            if (currDepth >= maxDepth) {
                return [score, null]
            }

            let bestScore = 0
            let bestMove = null

            const inBounds = (x, y) => {
                return !(
                    x < 0 || y < 0 ||
                    y >= data.length ||
                    x >= data[0].length
                )
            }

            let possibleMoves = [[0, 1], [0, -1], [1, 0], [-1, 0]]

            moveLoop:
            for (let move of possibleMoves) {
                let currX = playerX + move[0]
                let currY = playerY + move[1]

                if (!inBounds(currX, currY)) {
                    continue
                }

                let value = data[currY][currX]
                if (value == -1) {
                    continue
                }

                let dataCopy = data.map(row => {
                    return row.map(cell => {
                        return (cell == "@" || cell == " ") ? -1 : cell
                    })
                })

                dataCopy[currY][currX] = -1

                for (let i = 1; i < value; i++) {
                    currX += move[0]
                    currY += move[1]
                    if (!inBounds(currX, currY)) {
                        continue moveLoop
                    }
                    if (dataCopy[currY][currX] == -1) {
                        continue moveLoop
                    }
                    dataCopy[currY][currX] = -1
                }

                let [moveScore, _] = this.evalPos(dataCopy, currX, currY, score + value, currDepth + 1, maxDepth)

                if (moveScore > bestScore) {
                    bestMove = move
                    bestScore = moveScore
                }
            }

            return [bestScore, bestMove]
        }

        static getBestMove(data, playerPos, depth) {
            this.callCount = 0

            if (this.logging) {
                console.log(`-- starting search with depth=${depth} --`)
            }

            let [score, move] = this.evalPos(
                data,
                playerPos.x,
                playerPos.y,
                0, 1, depth
            )

            if (this.logging) {
                console.log(`-- ending search, score=${score} --`)
            }

            if (move) {
                return Vector2d.fromArray(move)
            } else {
                return null
            }
        }

    }

    terminal.printLine("Use the arrow keys to move the player. You will move the")
    terminal.printLine("number of spaces equal to the number on the tile you land on")
    terminal.printLine("Don't crash into the walls or yourself!")
    let game = new Game(args.w, args.h)

    addEventListener("keydown", event => {
        if (!game.running || game.processing) return

        if (event.key == "s") {
            let bestMove = Solver.getBestMove(game.data, game.player.pos, 10)
            if (bestMove) {
                game.movePlayer(bestMove)
            }
            event.preventDefault()
        } else if (event.key == "ArrowUp") {
            game.movePlayer(new Vector2d(0, -1))
            event.preventDefault()
        } else if (event.key == "ArrowDown") {
            game.movePlayer(new Vector2d(0, 1))
            event.preventDefault()
        } else if (event.key == "ArrowLeft") {
            game.movePlayer(new Vector2d(-1, 0))
            event.preventDefault()
        } else if (event.key == "ArrowRight") {
            game.movePlayer(new Vector2d(1, 0))
            event.preventDefault()
        } else if (event.key == "c" && event.ctrlKey) {
            game.running = false
        }
    })

    game.drawPlayer(true)

    terminal.scroll()

    while (game.running) {
        await sleep(100)
        game.updateScore()
    }

    terminal.printLine(`Game over! Your score was ${game.player.score}.`)

    await HighscoreApi.registerProcess(gameName)
    await HighscoreApi.uploadScore(game.player.score)

}, {
    description: "play a game of greed",
    isGame: true,
    args: {
        "?b": "play the bigger version"
    }
})


// ------------------- js/commands/grep.js --------------------
terminal.addCommand("grep", async function(args) {
    let recursive = args.r ?? false
    let ignorecase = args.i ?? false
    let invert = args.v ?? false
    let linematch = args.x ?? false

    if (ignorecase)
        args.pattern = args.pattern.toLowerCase()

    let matches = []

    function processFile(file, allowRecursionOnce=false) {
        if (file.type == FileType.DIRECTORY) {
            if (recursive || allowRecursionOnce) {
                for (let newFile of file.children) {
                    if (!recursive && newFile.type == FileType.DIRECTORY) continue
                    processFile(newFile)
                }
            } else {
                throw new Error(`File ${file.name} is a directory!`)
            }
        } else {
            for (let line of file.content.split("\n")) {
                if (linematch) {
                    let tempLine = line
                    if (ignorecase)
                        tempLine = line.toLowerCase()
                    var matching = tempLine === args.pattern
                } else if (ignorecase) {
                    var matching = line.toLowerCase().includes(args.pattern)
                } else {
                    var matching = line.includes(args.pattern)
                }
                if (matching ^ invert) {
                    if (ignorecase) {
                        var offset = line.toLowerCase().indexOf(args.pattern)
                    } else {
                        var offset = line.indexOf(args.pattern)
                    }
                    matches.push({
                        filename: file.name,
                        filepath: file.path,
                        line: line,
                        offset: offset,
                    })
                }
            }
        }
    }

    if (args.file == "*") {
        processFile(terminal.currDirectory, true)
    } else {
        for (let filename of args.file.split(" ")) {
            let file = terminal.getFile(filename)
            processFile(file, filename)
        }
    }

    for (let match of matches) {
        terminal.printCommand(
            match.filename,
            `cat ${match.filepath}`,
            Color.COLOR_1, false
        )
        terminal.print(": ")
        if (match.offset == -1) {
            terminal.print(match.line)
        } else {
            let slicePoint = match.offset + 100
            if (slicePoint < match.line.length)
                match.line = match.line.slice(0, slicePoint) + "..."
            let prevLine = match.line.substring(0, match.offset)
            let matchLine = match.line.substring(match.offset, match.offset + args.pattern.length)
            let nextLine = match.line.substring(match.offset + args.pattern.length)
            terminal.print(prevLine)
            terminal.print(matchLine, Color.COLOR_2)
            terminal.print(nextLine)
        }
        terminal.addLineBreak()
    }

    if (matches.length == 0) {
        terminal.printLine("no matches")
    }

}, {
    description: "search for a pattern in a file",
    args: {
        "pattern": "the pattern to search for",
        "file": "the file to search in",
        "?r=recurse:b": "search recursively",
        "?i=ignore-case:b": "ignore case",
        "?v=invert-match:b": "invert match",
        "?x=match-whole-lines:b": "match whole lines",
    }
})



// ------------------- js/commands/gui.js --------------------
terminal.addCommand("gui", async function(args) {
    terminal.href(`gui/${args.command}/index.html`)
}, {
    description: "open the GUI page for a given command",
    args: {
        "command:c": "a terminal command"
    }
}) 

// ------------------- js/commands/hangman.js --------------------
var englishWords = [
    "spokesman", "slots", "man", "targets", "sec", "reflects", "constitutional", "hereby", "progressive", 
    "authors", "secrets", "basically", "wild", "beautiful", "theatre", "cry", "vhs", "fraction", "breakfast", "meal", "far", 
    "out", "glow", "literally", "specialist", "touch", "coastal", "ala", "ingredients", "medal", "adsl", "extract", "corresponding", 
    "twelve", "wizard", "micro", "cartoon", "steering", "moved", "inspection", "jul", "jpeg", "christopher", "index", 
    "value", "initially", "motivated", "threads", "friends", "worldwide", "frontier", "intense", "proprietary", "loaded", 
    "otherwise", "spider", "civilian", "detect", "tulsa", "closely", "trick", "expenditure", "responses", "deleted", "pubmed", 
    "listening", "thrown", "rosa", "relief", "magical", "thickness", "zone", "prot", "lectures", "prove", "published", "crap", 
    "allah", "dimensions", "panties", "perl", "ricky", "front", "tradition", "favourites", "naples", "sleep", "anime", 
    "introduces", "classical", "ntsc", "breeds", "city", "casey", "printable", "radar", "spend", "signed", "claimed", 
    "anymore", "accident", "which", "crossword", "evening", "iran", "matters", "justice", "sarah", "textbook", 
    "silly", "follows", "iraqi", "butts", "discrete", "pod", "afraid", "error", "homeless", "tracker", "optimize", "infected", 
    "side", "nice", "knock", "clinic", "diana", "reputation", "representation", "lyric", "compensation", "std", 
    "uploaded", "possess", "balls", "bon", "until", "info", "legs", "section", "lodging", "gallery", "allows", "attachments", 
    "mini", "mighty", "characterized", "mit", "restore", "swiss", "profiles", "herald", "henderson", "bedford", "peru", "jerry", 
    "movements", "condos", "asn", "annotation", "expand", "electron", "photoshop", "inquire", "anybody", "clip", "formed", 
    "processes", "casa", "cassette", "part", "inch", "difference", "dump", "carter", "knows", "undertake", "twisted", "were", 
    "rover", "versions", "farmers", "cartridges", "permit", "wolf", "decimal", "millions", "republic", "promotions", "photographers", 
    "unlock", "mono", "deck", "boots", "repair", "varieties", "sophisticated", "impacts", "liberal", "investment", "training", 
    "republicans", "fifth", "actor", "skating", "acts", "operated", "clear", "swaziland", "dylan", "nation", "aud", "bizrate", 
    "harm", "approaches", "martin", "confused", "pharmaceutical", "viking", "tunisia", "howto", "viagra", "conceptual", "downtown", 
    "geek", "fell", "observations", "managed", "select", "outer", "calculator", "barriers", "attributes", "rules", "spy", 
    "close", "foul", "wheels", "warrior", "bandwidth", "compressed", "bond", "creature", "minor", "mysql", "tuition", "invitations", 
    "elsewhere", "girls", "identical", "captured", "corporation", "ellis", "fifteen", "cds", "culture", "teeth", "frozen", 
    "rugs", "explained", "pop", "deutsch", "replace", "regulation", "against", "prominent", "higher", "arena", "commonly", 
    "int", "sucks", "equations", "enjoying", "marcus", "assembled", "denmark", "edinburgh", "purchasing", "printer", "puts", 
    "delivered", "oaks", "implement", "controller", "pets", "numerous", "celebs", "actors", "lottery", "biographies", "surprising", 
    "situated", "design", "penalties", "sheer", "insert", "craps", "report", "endorsement", "manage", "award", "medicines", 
    "degree", "farm", "skin", "tongue", "flight", "upload", "portuguese", "activities", "bound", "mongolia", "internship", 
    "three", "boys", "spray", "tests", "ppc", "shades", "consequence", "institute", "wang", "poly", "pins", "notion", "ever", 
    "starting", "yea", "somehow", "visibility", "surplus", "seeing", "noble", "andrea", "applied", "mpg", "ear", "normal", 
    "victoria", "necessity", "never", "juvenile", "bhutan", "techniques", "temple", "qualification", "trial", "carolina", 
    "potential", "diagnosis", "butter", "ant", "belt", "titles", "consideration", "unexpected", "evanescence", "sunrise", 
    "gone", "opportunity", "resort", "occurrence", "dictionaries", "amp", "commissioners", "atlantic", "von", "scanner", 
    "worn", "hollywood", "corporations", "documentary", "shift", "ambien", "hobby", "organisations", "poet", "oliver", "weekly", 
    "particular", "mark", "permitted", "wallpaper", "output", "wage", "donna", "hammer", "spirit", "university", 
    "licensed", "girl", "navy", "blogger", "poem", "descending", "powder", "cad", "website", "graphical", "root", 
    "needed", "printed", "recreational", "ordered", "mounting", "arcade", "dictionary", "lately", "computer", "responded", 
    "much", "saves", "street", "modified", "pretty", "denied", "happy", "pose", "mice", "desert", "package", "rewards", "than", 
    "pickup", "instantly", "relatives", "flooring", "better", "cycle", "indie", "leg", "health", "magnificent", "hacker", 
    "databases", "classics", "translator", "ian", "shine", "assignment", "verify", "chevrolet", "vendors", "applicants", 
    "legislation", "prozac", "beta", "blend", "soup", "perfect", "midwest", "matter", "kathy", "snake", "treo", "features", 
    "howard", "discounted", "probably", "patient", "polyphonic", "shoot", "ram", "thousands", "couples", "gabriel", "dense", 
    "plugins", "alumni", "terrorism", "parental", "deer", "build", "counted", "tokyo", "promotion", "sensitive", 
    "improved", "ultimate", "alloy", "scroll", "iceland", "knife", "featuring", "nodes", "helmet", "maintained", "male", 
    "adults", "logical", "kenneth", "sticker", "band", "sciences", "mild", "holders", "stable", "singapore", "recipients", 
    "rolling", "ranked", "wheat", "main", "slovenia", "severe", "handles", "forecasts", "fabric", "presence", 
    "mediawiki", "slope", "situations", "displays", "api", "sympathy", "manga", "straight", "obtaining", "preferred", "locking", 
    "performance", "guarantees", "approval", "davis", "activation", "calcium", "coal", "raises", "characteristics", 
    "behavioral", "sri", "reached", "takes", "reflect", "linear", "poverty", "canvas", "controversial", "drink", "cashiers", 
    "meals", "enables", "shortcuts", "budgets", "articles", "altered", "valve", "sex", "accessories", "advice", "countries", 
    "indicators", "unfortunately", "budapest", "vacancies", "argue", "den", "potter", "victor", "able", "dealtime", "idle", 
    "tax", "lucky", "reservations", "along", "spouse", "funding", "pre", "wound", "job", "exploring", "threatening", "ceo", 
    "scores", "stages", "combinations", "would", "satisfied", "seemed", "gratuit", "miracle", "poor", "abortion", 
    "interaction", "developer", "original", "trail", "wait", "lawyer", "pressure", "hint", "estimates", "arranged", 
    "bye", "sim", "therapy", "commercial", "ghost", "withdrawal", "finishing", "whereas", "vocal", "began", "shape", "language", 
    "forty", "told", "thinks", "rent", "patents", "chem", "asset", "officials", "drove", "deutsche", "central", "bargain", 
    "arbitration", "pull", "females", "ball", "chi", "compact", "path", "disorder", "revolution", "marie", "cemetery", "earliest", 
    "direction", "slide", "books", "consequently", "gourmet", "sports", "bite", "material", "nickname", 
    "burning", "caroline", "titten", "addition", "juice", "oscar", "measures", "pharmacology", "assumes", "professor", "adjustments", 
    "yeast", "monte", "magazines", "blessed", "partially", "whole", "reform", "distinction", "annex", "arm", "usage", "sen", 
    "buried", "stuffed", "continues", "game", "inf", "minimum", "inquiry", "visits", "kim", "campaigns", "album", "teen", 
    "ethical", "sic", "architecture", "judge", "nursery", "half", "textile", "mambo", "politicians", "offline", "you", "consistency", 
    "refused", "crimes", "cruz", "maintains", "prepare", "beatles", "manor", "things", "standard", "adaptation", "cons", 
    "market", "crops", "chuck", "configure", "scheme", "platforms", "obvious", "atm", "wants", "guides", "statewide", "goods", 
    "supported", "tennessee", "chaos", "zum", "rights", "hamburg", "bachelor", "infant", "take", "espn", "died", "decision", 
    "importantly", "defining", "wallpapers", "prep", "sept", "sapphire", "careful", "albany", "holly", "liberty", "appropriations", 
    "depends", "heavily", "shemales", "undergraduate", "relaxation", "injury", "placement", "stress", "day", "recipient", 
    "achieving", "header", "explanation", "figures", "grove", "amd", "currently", "immigrants", 
    "strings", "protein", "lung", "spending", "donation", "inter", "belly", "product", "tent", "instead", 
    "css", "fuzzy", "observed", "leasing", "several", "moldova", "remove", "complaint", "correct", "accountability", "bolt", 
    "second", "serial", "wrapped", "screw", "sake", "tasks", "recommend", "spring", "bad", "grants", "ken", "illustration", 
    "upgrades", "chronicles", "agencies", "missile", "limits", "varying", "laundry", "emission", "bow", "honey", "expenditures", 
    "library", "xxx", "merit", "selections", "wearing", "differently", "forests", "pounds", "restrict", "containing", "apnic", 
    "florence", "other", "ddr", "interracial", "initiated", "ins", "units", "attempt", "ran", "railroad", "appearance", "over", 
    "trials", "paint", "performs", "deborah", "tears", "merely", "none", "realtors", "ryan", "gpl", "def", "queens", "jewish", 
    "receive", "cables", "tuner", "intelligent", "louis", "beds", "restricted", "gangbang", "earth", "internet", "best", 
    "master", "screensavers", "continuity", "swift", "luis", "iso", "shall", "jane", "fool", "posts", "different", "teacher", 
    "manual", "scholarships", "mad", "clearing", "improvements", "lancaster", "federation", "nut", "ceiling", "furnishings", 
    "twice", "concepts", "francis", "give", "licenses", "down", "context", "scored", "deficit", "dos", "demands", "spam", 
    "tom", "suggest", "bind", "rich", "perspective", "thanksgiving", "dave", "metallica", "greece", "translation", "adventure", 
    "rail", "plaza", "stability", "chart", "paperback", "component", "abuse", "tel", "daniel", "backing", "feelings", "rid", 
    "skills", "reed", "filled", "voyeurweb", "proceeds", "ministries", "delivering", "departments", "deployment", "framing", 
    "pan", "contacting", "shakespeare", "retained", "remedy", "answer", "denial", "events", "opens", "integral", "tried", 
    "recorded", "fallen", "accurately", "coupons", "sending", "levy", "hot", "ppm", "commands", "hosts", "wireless", "above", 
    "thriller", "off", "forecast", "fundamental", "thanks", "harbor", "dark", "manner", "usb", "instance", "imagine", "bridge", 
    "tigers", "cigarettes", "deviant", "include", "fame", "qualifying", "distant", "minds", "trainer", "wonderful", "involving", 
    "visit", "chorus", "prediction", "associate", "threats", "contributor", "restaurant", "strategies", "postage", "sounds", 
    "watching", "die", "demonstrated", "florist", "transition", "greatest", "postal", "format", "playstation", 
    "blowing", "graphs"
]

const stages = [`
    
          
Welcome to Hangman!
I'm thinking of a random (common) english word...
You may guess single letters or whole words.
Good Luck!
    
    
`,`
    
          
          
         
           
          
    
    
+===+===+`,`
    +
    |      
    |      
    |     
    |       
    |      
    |
    | 
+===+===+`,`
    +
    |      
    |      
    |     
    |       
    |      
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    |      
    |      
    |     
    |       
    |      
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    | /     
    |/     
    |     
    |      
    |     
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    | /     |
    |/      O
    |      
    |         
    |      
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    | /     |
    |/      O
    |       |
    |       |  
    |      
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    | /     |
    |/      O
    |      /|\\
    |       |  
    |       
   /|\\
  / | \\
+===+===+`,`
    +--+----+
    | /     |
    |/      O
    |      /|\\
    |       |  
    |      / \\
   /|\\
  / | \\
+===+===+`]

terminal.addCommand("hangman", async function(args) {
    let secretWord = englishWords[Math.floor(Math.random() * englishWords.length)]
    let guessedLetters = []
    let correctLetters = new Set()
    let coveredLetters = "_".repeat(secretWord.length).split("")
    let stageIndex = 0

    let stageOutput = terminal.print("", undefined, {forceElement: true})
    terminal.addLineBreak(2)
    let letterOutput = terminal.print("", undefined, {forceElement: true})

    while (stageIndex + 1 < stages.length) {
        stageOutput.textContent = stages[stageIndex] + "\n"
        if (guessedLetters.length)
            stageOutput.textContent += `(${guessedLetters.length}) ${guessedLetters.join(",")}`
        letterOutput.textContent = coveredLetters.join(" ") + " : "

        if (!coveredLetters.includes("_"))
            break

        let guess = await terminal.prompt("", {printInputAfter: false})

        if (correctLetters.has(guess))
            continue
        
        if (guess.length == 1) {
            let replaceCount = 0
            for (let i = 0; i < secretWord.length; i++) {
                if (coveredLetters[i] == "_" && secretWord.charAt(i) == guess) {
                    coveredLetters[i] = guess
                    replaceCount++
                    correctLetters.add(guess)
                }
            }

            if (!replaceCount && !guessedLetters.includes(guess)) {
                guessedLetters.push(guess)
                stageIndex++
            }
        } else if (guess.length == 0) {
            // do nothing
        } else {
            if (guess.trim().toLowerCase() == secretWord.toLowerCase()) {
                break
            } else if (guess.length == secretWord.length) {
                stageIndex++
            }
        }
    }

    stageOutput.textContent = stages[stageIndex]

    if (stageIndex == stages.length - 1) {
        terminal.printLine("You lost!", Color.ERROR)
        terminal.printLine(`The correct word was: ${secretWord}`)
    } else {
        letterOutput.textContent = secretWord.split("").join(" ") + " : "
        terminal.printSuccess("You won!")
    }
}, {
    description: "play a game of hangman",
    isGame: true
})

// ------------------- js/commands/head.js --------------------
terminal.addCommand("head", function(args) {
    let file = terminal.getFile(args.file)
    if (file.isDirectory)
        throw new Error("Cannot display a folder")
    if (file.content.length == 0)
        throw new Error("File is empty")
    let lines = file.content.split("\n")
    let result = lines.slice(0, args.l).join("\n")
    terminal.printLine(result)
}, {
    description: "display the first lines of a file",
    args: ["file", "?l:i:1~1000"],
    standardVals: {
        l: 10
    }
})



// ------------------- js/commands/helloworld.js --------------------
terminal.addCommand("helloworld", async function() {
    const printLinks = links => {
        for (const {name, url} of links) {
            terminal.printLink(name, url, undefined, false)
            terminal.print(" ")
        }
        terminal.print(" ")
    }

    const welcomeLineFuncs = [
        () => terminal.print("                  _    __      _          _      _      _       "),
        () => terminal.print("                 | |  / _|    (_)        | |    (_)    | |      "),
        () => terminal.print(" _ __   ___   ___| | | |_ _ __ _  ___  __| |_ __ _  ___| |__    "),
        () => terminal.print("| '_ \\ / _ \\ / _ \\ | |  _| '__| |/ _ \\/ _\` | '__| |/ __| '_ \\   "),
        () => terminal.print("| | | | (_) |  __/ |_| | | |  | |  __/ (_| | |  | | (__| | | |  "),
        () => terminal.print("|_| |_|\\___/ \\___|_(_)_| |_|  |_|\\___|\\__,_|_|  |_|\\___|_| |_|  "),
        () => terminal.print("                                                                "),
        () => terminal.print("Welcome to my homepage. It's also a very interactive terminal.  "),
        () => terminal.print(`Enter commands to navigate over ${Object.keys(terminal.allCommands).length - 1} unique tools and features.  `),
        () => {
            terminal.print("Start your adventure using the ")
            terminal.printCommand("help", "help", undefined, false)
            terminal.print(" command. Have lots of fun!  ")
        },
        () => terminal.print("                                                                "),

        // --------------------------------------------------------------
        // Instagram GitHub Perli Library AntiCookieBox Stray GUI YouTube
        // Partycolo HR-Codes 3d Turtlo Coville Compli Spion Lettre Presi

        () => printLinks([
                {name: "Instagram", url: "https://instagram.com/noel.friedrich/"},
                {name: "GitHub", url: "https://github.com/noel-friedrich/terminal"},
                {name: "Perli", url: "https://noel-friedrich.de/perli"},
                {name: "Library", url: "https://noel-friedrich.de/lol"},
                {name: "AntiCookieBox", url: "https://noel-friedrich.de/anticookiebox"},
                {name: "Stray", url: "https://noel-friedrich.de/stray"},
                {name: "GUI", url: "https://noel-friedrich.de/terminal/gui"},
                {name: "YouTube", url: "https://www.youtube.com/@noel.friedrich"}
        ]),
        () => printLinks([
            {name: "Partycolo", url: "https://noel-friedrich.de/partycolo"},
            {name: "HR-Codes", url: "https://noel-friedrich.de/hr-code"},
            {name: "3d", url: "https://noel-friedrich.de/3d"},
            {name: "Turtlo", url: "https://noel-friedrich.de/turtlo"},
            {name: "Coville", url: "https://noel-friedrich.de/coville"},
            {name: "Compli", url: "https://play.google.com/store/apps/details?id=de.noelfriedrich.compli"},
            {name: "Spion", url: "https://noel-friedrich.de/spion"},
            {name: "Lettre", url: "https://noel-friedrich.de/lettre"},
            {name: "Presi", url: "https://noel-friedrich.de/presi"}
        ])
    ]

    let size = {
        x: welcomeLineFuncs.length * 2,
        y: welcomeLineFuncs.length
    }

    for (let i = 0; i < size.y; i++) {

        welcomeLineFuncs[i]()
        
        for (let j = 0; j < size.x; j++) {
            let x = (j / size.x - 0.5) * 2
            let y = (i / size.y - 0.5) * 2
            if (x*x + y*y > 1) {
                terminal.print(" ")
            } else {
                let angle = Math.atan2(y, x) / Math.PI * 180
                let hue = Math.round(angle)
                let lightness = Math.round(90 - (x*x + y*y) * 90)
                terminal.print("#", Color.hsl(hue / 360, 1, lightness / 100))
            }
        }
        terminal.addLineBreak()
    }
}, {
    description: "display the hello-world text",
    rawArgMode: true,
})

// ------------------- js/commands/help.js --------------------
terminal.addCommand("help", function() {
    terminal.printLine("Welcome to the Help Menu!", Color.COLOR_1)
    terminal.printLine("Here are some commands to try out:\n")
    let helpCommands = ["cat", "cd", "games", "ls", "lscmds", "man", "turtlo", "easter-eggs", "contact"]
    let longestCommandLength = helpCommands.reduce((p, c) => Math.max(p, c.length), 0)
    for (let command of helpCommands.sort((a, b) => a.localeCompare(b))) {
        let spaces = strRepeat(" ", longestCommandLength - command.length + 2)
        let description = terminal.allCommands[command]
        terminal.printCommand(`  ${command}${spaces}`, command, Color.PURPLE, false)
        terminal.printLine(`${description}`)
    }
    terminal.printLine("\n(there are also A LOT of secret ones)")
}, {
    description: "shows this help menu",
})

// ------------------- js/commands/hi.js --------------------
terminal.addCommand("hi", async function(args) {
    const suggestions = [
        () => {
            terminal.printLine("You should go for a run outside!", Color.COLOR_1)
            terminal.print("- download ")
            terminal.printLink("Strava", "https://www.strava.com/", undefined, false)
            terminal.print(" or ")
            terminal.printLink("Nike Run Club", "https://www.nike.com/ie/nrc-app")
            terminal.printLine("- play some of your favourite music")
            terminal.printLine("- running is great for mental health")
        },
        () => {
            terminal.print("You should play a round of ", Color.COLOR_1)
            terminal.printCommand("longjump", "longjump", Color.COLOR_1, false)
            terminal.printLine("!")
            terminal.print("- enter '")
            terminal.printCommand("longjump", "longjump", undefined, false)
            terminal.printLine("' in the terminal to start")
            terminal.printLine("- fly turtlo as long as you can")
            terminal.printLine("- try to beat the highscores")
        },
        () => {
            terminal.printLine("You should go for a walk!", Color.COLOR_1)
            terminal.print("- download ")
            terminal.printLink("Stray", "https://noel-friedrich.de/stray/", undefined, false)
            terminal.printLine(" to make it fun")
            terminal.printLine("- don't play music, just explore your sorrounding")
            terminal.printLine("- go somewhere where you haven't ever been")
        }
    ]

    await terminal.animatePrint("Hello there!")
    await terminal.acceptPrompt("Are you bored?")
    terminal.printLine("\n> Thats fine! If you want, I can give")
    terminal.printLine("> you some suggestions what to do!")
    await terminal.acceptPrompt("\nDo you want a suggestion?")

    const indeces = shuffle(suggestions.map((_, i) => i))
    for (let index of indeces) {
        terminal.addLineBreak()
        suggestions[index]()
        await terminal.acceptPrompt("\nDo you want another suggestion?")
        if (index == indeces[indeces.length - 1]) {
            break
        }
    }

    await terminal.animatePrint("\nHm. Those were all suggestions I had.")
    await terminal.animatePrint("Maybe run ", undefined, {newLine: false})
    terminal.printCommand("lscmds", "lscmds", undefined, false)
    await terminal.animatePrint(" to see if there's some")
    await terminal.animatePrint("command that you will enjoy?")
}, {
    description: "say hello to the terminal"
})

// ------------------- js/commands/highscore-admin.js --------------------
terminal.addCommand("highscore-admin", async function(args) {
    await terminal.modules.import("game", window)
    
    if (args.delete) {
        localStorage.removeItem("highscore_password")
        HighscoreApi.tempPassword = null
        terminal.printLine("Removed password from local storage")
        return
    } else if (args.list) {
        await HighscoreApi.loginAdmin(true)
        const highscores = await HighscoreApi.getUnconfirmedHighscores()
        highscores.sort((a, b) => a.game.localeCompare(b.game))

        terminal.printLine(`Showing ${highscores.length} Highscores...`)
        terminal.printTable(highscores.map(s => [
            s.id, s.game, s.name, s.score, s.time
        ]), ["id", "game", "name", "score", "time"])
    } else if (args.tinder) {
        await HighscoreApi.loginAdmin(true)
        const highscores = await HighscoreApi.getUnconfirmedHighscores()
        highscores.sort((a, b) => a.game.localeCompare(b.game))

        let i = 0
        for (let s of highscores) {
            i++

            terminal.printLine(`> Highscore #${i}/${highscores.length}:`)

            const rank = await HighscoreApi.getRank(s.game, s.score)

            try {
                terminal.printTable([[
                    rank, s.game, s.name, s.score, s.time
                ]], ["rank", "game", "name", "score", "time"])
                await terminal.acceptPrompt("Looks good?")
                await HighscoreApi.confirmHighscore(s.uid, 1)
                terminal.addLineBreak()
            } catch {
                await HighscoreApi.confirmHighscore(s.uid, 2)
                terminal.printSuccess("Removed Highscore successfully")
                terminal.addLineBreak()
            }
        }

        terminal.printSuccess("You're finished!")
    } else {
        await HighscoreApi.loginAdmin()
    }

}, {
    description: "Highscore Admin Management",
    isSecret: true,
    args: {
        "?l=list:b": "List all unconfirmed highscores",
        "?t=tinder:b": "Play Tinder Swiping with highscores",
        "?d=delete:b": "Delete password from local storage"
    }
})

// ------------------- js/commands/highscore-remove.js --------------------
terminal.addCommand("highscore-remove", async function(args) {
    
    await terminal.modules.import("game", window)
    await HighscoreApi.loginAdmin(true)
    if (args.uid) {
        await HighscoreApi.removeHighscore(args.uid)
        terminal.printSuccess("Removed highscore #" + args.uid)
        return
    }

    terminal.printLine(`Highscores for ${args.game}:`)

    let highscores = (await HighscoreApi.getHighscores(args.game))
        .slice(0, args.l).filter(h => h.name == args.n || args.n == null)

    if (highscores.length == 0)
        throw new Error("No highscores found")

    let maxNameLength = Math.max(...highscores.map(h => h.name.length))
    let maxScoreLength = Math.max(...highscores.map(h => h.score.toString().length))
    for (let highscore of highscores) {
        terminal.print(stringPadBack(highscore.name, maxNameLength + 2))
        terminal.print(stringPadBack(highscore.score, maxScoreLength + 2))
        terminal.print(highscore.time + "  ")
        terminal.printCommand("Remove", "highscore-remove x --uid " + highscore.uid)
    }
}, {
    description: "Remove a highscore",
    isSecret: true,
    args: {
        "game": "the game to remove the highscore from",
        "?n": "only show highscores with this name",
        "?l:n:1~10000": "limit the number of highscores to show",
        "?uid": "the uid of the highscore to remove",
    },
    standardVals: {
        "n": null,
        "l": Infinity
    }
})

// ------------------- js/commands/highscores.js --------------------
terminal.addCommand("highscores", async function(args) {
    if (args["show-all"]) args.l = Infinity

    await terminal.modules.import("game", window)

    {
        let commandName = args.game.split(":")[0]
        if (!terminal.commandExists(args.game.split(":")[0]))
            throw new Error(`Game ${commandName} not found`)
        let terminalFunc = await terminal.loadCommand(commandName)
        if (!terminalFunc.info.isGame)
            throw new Error(`Game ${commandName} not found`)
    }

    let allHighscores = await HighscoreApi.getHighscores(args.game)
    let highscores = allHighscores
        .filter(h => h.name == args.n || args.n == null)
        .slice(0, args.l)

    if (highscores.length == 0) {
        if (args.n != null)
            throw new Error(`No highscores found for ${args.n}`)
        else
            throw new Error("No highscores found")
    }

    let tableData = []
    for (let highscore of highscores) {
        let rank = await HighscoreApi.getRank(args.game, highscore.score, allHighscores)
        tableData.push([rank, highscore.name, Math.abs(highscore.score), highscore.time])
    }
    
    terminal.printTable(tableData, ["Rank", "Name", "Score", "Time"])
    
    if (highscores.length != allHighscores.length) {
        terminal.print(`(showing ${highscores.length} of ${allHighscores.length} highscores. `)
        let cmdText = `highscores ${args.game} --show-all`
        if (args.n != null) cmdText += ` -n ${args.n}`
        terminal.printCommand("show all", cmdText, undefined, false)
        terminal.printLine(")")
    }

}, {
    description: "Show global highscores for a game",
    args: {
        "game:s": "the game to show the highscores for",
        "?n:s": "only show highscores with this name",
        "?l:i:1~10000": "limit the number of highscores to show",
        "?show-all:b": "show all highscores, not just the top ones"
    },
    standardVals: {
        "n": null,
        "l": 10
    }
})

// ------------------- js/commands/history.js --------------------
terminal.addCommand("history", function(args) {
    let sliceLimit = args["show-full"] ? Infinity : 50
    let output = ""
    for (let i = Math.max(0, terminal.prevCommands.length - args.l); i < terminal.prevCommands.length; i++) {
        if (terminal.prevCommands[i].length >= sliceLimit) {
            output += `${i + 1}: ${terminal.prevCommands[i].slice(0, sliceLimit)} [...]\n`
        } else {
            output += `${i + 1}: ${terminal.prevCommands[i]}\n`
        }
    }
    terminal.printLine(output.slice(0, -1))
}, {
    description: "print the command history",
    args: {
        "?l=limit:n:1~100000": "the maximum number of commands to print",
        "?show-full:b": "show the full command instead of the shortened version"
    },
    standardVals: {
        l: 1000
    }
})

// ------------------- js/commands/hr-draw.js --------------------
terminal.addCommand("hr-draw", async function(args) {
    const makeCanvas = (data, width=30) => {
        const canvas = terminal.document.createElement("canvas")

        const sizePx = width * terminal.charWidth
        canvas.width = sizePx
        canvas.height = canvas.width * (data.length / data[0].length)

        terminal.parentNode.appendChild(canvas)
        terminal.addLineBreak()

        return canvas
    }

    const drawPixelData = (context, data) => {
        const canvas = context.canvas

        const xStep = canvas.width / data[0].length
        const yStep = canvas.height / data.length

        context.fillStyle = "white"
        context.fillRect(0, 0, canvas.width, canvas.height)

        context.fillStyle = "blue"
        for (let x = 0; x < data[0].length; x++) {
            for (let y = 0; y < data.length; y++) {
                if (data[y][x]) {
                    context.fillRect(
                        x * xStep, y * yStep,
                        xStep, yStep
                    )
                }
            }
        }
    }
    
    let pixelData = Array.from({length: args.height},
        () => Array.from({length: args.width}, () => false))
    
    const canvas = makeCanvas(pixelData)
    const context = canvas.getContext("2d")

    let mouseLeftDown = false
    let mouseRightDown = false

    terminal.window.addEventListener("mousedown", event => {
        if (event.button == 0) mouseLeftDown = true
        if (event.button == 2) mouseRightDown = true
        canvas.onmousemove(event)
    })
    terminal.window.addEventListener("contextmenu", event => {
        event.preventDefault()
    })
    terminal.window.addEventListener("mouseup", _ => {
        mouseLeftDown = false
        mouseRightDown = false
    })

    const eventToPos = event => {
        let rect = canvas.getBoundingClientRect()
        let xPx = event.clientX - rect.left
        let yPx = event.clientY - rect.top
        let x = Math.floor(xPx / (canvas.width / pixelData[0].length))
        let y = Math.floor(yPx / (canvas.height / pixelData.length))
        x = Math.min(Math.max(0, x), pixelData[0].length - 1)
        y = Math.min(Math.max(0, y), pixelData.length - 1)
        return {x, y}
    }

    canvas.onmousemove = event => {
        let {x, y} = eventToPos(event)
        pixelData[y][x] = mouseRightDown ? false : (mouseLeftDown ? true : pixelData[y][x])
        drawPixelData(context, pixelData)
    }

    const getBinaryData = () => {
        let output = "0b"
        for (let i = 0; i < args.width * args.height; i++) {
            let x = i % args.width
            let y = (i - x) / args.height
            if (pixelData[y][x]) {
                output += "1"
            } else {
                output += "0"
            }
        }
        return output
    }

    drawPixelData(context, pixelData)

    let running = true

    terminal.onInterrupt(() => running = false)

    terminal.window.addEventListener("keydown", event => {
        if (event.key.length != 1 || !running) return
        let output = `"${event.key}": ${getBinaryData()}`
        terminal.printLine(output)
        terminal.copy(output)
    })

    while (running) {
        await sleep(100)
    }

}, {
    description: "turn drawings into bitmaps",
    args: {
        "?x=width:i:1~100": "width (pixels)",
        "?y=height:i:1~100": "height (pixels)" 
    },
    defaultValues: {
        width: 5,
        height: 5
    },
    isSecret: true
})

// ------------------- js/commands/hr.js --------------------
const letterData = {
    "4x4": {
        letters: {
            "A": 0b1111100111111001, "B": 0b1100101011011010, "C": 0b1111100010001111,
            "D": 0b1110100110011110, "E": 0b1111111010001111, "F": 0b1111100011101000,
            "G": 0b1111100010011111, "H": 0b1001100111111001, "I": 0b1111010001001111,
            "J": 0b1111000110011111, "K": 0b1011110010101001, "L": 0b1000100010001111,
            "M": 0b1111101110011001, "N": 0b1101101110011001, "O": 0b1111100110011111,
            "P": 0b1111100111111000, "Q": 0b1111100110111111, "R": 0b1111100111111010,
            "S": 0b1111100011110111, "T": 0b1111010001000100, "U": 0b1001100110011111,
            "V": 0b1001100110010110, "W": 0b1001100110111111, "X": 0b1001011001101001,
            "Y": 0b1001100111110100, "Z": 0b1111001001001111, "0": 0b1111101111011111,
            "1": 0b0010011000100111, "2": 0b1111001001001111, "3": 0b1111011100011111,
            "4": 0b1001100111110001, "5": 0b1111100011110111, "6": 0b1000111110011111,
            "7": 0b1111000100010001, "8": 0b1110101111010111, "9": 0b1111100111110001,
            " ": 0b0000000000000000
        },
        size: 4
    },
    "5x5": {
        letters: {
            "A": 0b1111110001111111000110001, "B": 0b1111010001111111000111110,
            "C": 0b1111110000100001000011111, "D": 0b1111010001100011000111110,
            "E": 0b1111110000111101000011111, "F": 0b1111110000111101000010000,
            "G": 0b1111110000101111000111111, "H": 0b1000110001111111000110001,
            "I": 0b1111100100001000010011111, "J": 0b1111000100001001010011100,
            "K": 0b1001010100110001010010010, "L": 0b1000010000100001000011111,
            "M": 0b1000111011101011000110001, "N": 0b1000111001101011001110001,
            "O": 0b1111110001100011000111111, "P": 0b1111110001111111000010000,
            "Q": 0b1111110001100011001111111, "R": 0b1111110001111111001010001,
            "S": 0b1111110000111110000111111, "T": 0b1111100100001000010000100,
            "U": 0b1000110001100011000111111, "V": 0b1000110001010100101000100,
            "W": 0b1000110001101011101110001, "X": 0b1000101010001000101010001,
            "Y": 0b1000101010001000010000100, "Z": 0b1111100010001000100011111,
            "0": 0b0111010001101011000101110, "1": 0b0110000100001000010000100,
            "2": 0b0110010010001000100011110, "3": 0b1111000010011100001011110,
            "4": 0b1000110001111110000100001, "5": 0b0111010000111100001011110,
            "6": 0b1111010000111101001011110, "7": 0b1111000010001000100010000,
            "8": 0b1111010010011001001011110, "9": 0b1111010010111100001011110,
            " ": 0b0000000000000000000000000, "/": 0b0001100110011001100010000,
            "\\": 0b1100001100001100001100001, "#": 0b0101011111010101111101010,
            "?": 0b1111100001001110000000100, ":": 0b0110001100000000110001100,
            "-": 0b0000000000011100000000000, ".": 0b0000000000000000110001100,
            ",": 0b0000000000001000110001000, 
            "a": 0b0000001110100101001001111, "b": 0b1000010000111001001011100,
            "c": 0b0000001110100001000001110, "d": 0b0001000010011101001001110,
            "e": 0b0110010010111101000001110, "f": 0b0001000100011100010000100,
            "g": 0b0110010010011100001011100, "h": 0b1000010000111001001010010,
            "i": 0b0010000000011100010001110, "j": 0b0010000000001000010011000,
            "k": 0b0100001000010100110001010, "l": 0b0100001000010000101000100,
            "m": 0b0000000000010101010110001, "n": 0b0000000000111001001010010,
            "o": 0b0000001100100101001001100, "p": 0b0000001110010100111001000,
            "q": 0b0000001110010100111000010, "r": 0b0000000000001100100001000,
            "s": 0b0000000110010000011001100, "t": 0b0010001110001000010000110,
            "u": 0b0000000000010100101000110, "v": 0b0000000000010100101000100,
            "w": 0b0000000000100011010101011, "x": 0b0000000000010100010001010,
            "y": 0b0101001010001100001000100, "z": 0b0000001110000100010001110
        },
        size: 5
    }
}

const randomCharData = size => {
    let out = ""
    for (let i = 0; i < size*size; i++) {
        out += (Math.random() < 0.5) ? "0" : "1"
    }
    return parseInt(out, 2)
}

const maxCodeSize = 100

terminal.addCommand("hr", async function(args) {
    const fontData = letterData[args.fontmode]
    if (fontData === undefined) {
        throw new Error(`Unknown fontmode "${args.fontmode}"`)
    }

    const symbols = Array.from(args.message).map(letter => fontData.letters[letter])

    if (symbols.some(s => s === undefined)) {
        throw new Error("Message contains unsupported characters!")
    }

    let codeSize = 1
    for (; (codeSize ** 2) < symbols.length; codeSize++) {
        if (codeSize >= maxCodeSize) {
            throw new Error("Maximum Code Size exeeded.")
        }
    }
    
    let sizePx = (fontData.size + 1) * codeSize - 1
    let pixelData = Array.from({length: sizePx + 2},
        () => Array.from({length: sizePx + 2}, () => false))

    while (args.fill && symbols.length < (codeSize * codeSize)) {
        // let randomIndex = Math.floor(Math.random() * pixelData.length)
        // symbols.splice(randomIndex, 0, randomCharData(fontData.size))
        symbols.push(randomCharData(fontData.size))
    }

    const drawPixelData = (data, width=30) => {
        const canvas = terminal.document.createElement("canvas")
        const context = canvas.getContext("2d")

        const sizePx = width * terminal.charWidth
        canvas.width = sizePx
        canvas.height = canvas.width * (data.length / data[0].length)

        const xStep = canvas.width / data[0].length
        const yStep = canvas.height / data.length

        context.fillStyle = "white"
        context.fillRect(0, 0, canvas.width, canvas.height)

        context.fillStyle = "black"
        for (let x = 0; x < data[0].length; x++) {
            for (let y = 0; y < data.length; y++) {
                if (data[y][x]) {
                    context.fillRect(
                        x * xStep, y * yStep,
                        xStep, yStep
                    )
                }
            }
        }

        terminal.parentNode.appendChild(canvas)
        terminal.addLineBreak()
    }

    for (let i = 0; i < symbols.length; i++) {
        let px = (i % codeSize) * (fontData.size + 1) + 1
        let py = Math.floor(i / codeSize) * (fontData.size + 1) + 1

        for (let j = 0; j < fontData.size ** 2; j++) {
            let bitMask = (1 << (fontData.size ** 2 - j - 1))
            let bitActive = (symbols[i] & bitMask) != 0
            if (bitActive) {
                let x = j % fontData.size
                let y = Math.floor(j / fontData.size)
                pixelData[py + y][px + x] = true
            }
        }
    }

    drawPixelData(pixelData)
}, {
    description: "create a hr code",
    args: {
        "message:s": "the message to encode",
        "?f=fontmode:s": "the font mode to use",
        "?fill:b": "fill empty spaces with random data"
    },
    defaultValues: {
        fontmode: "5x5"
    }
})

// ------------------- js/commands/href.js --------------------
terminal.addCommand("href", function(args) {
    function href(url) {
        if (!url.includes(".")) url = `noel-friedrich.de/${url}`
        if (!url.startsWith("http")) url = "https://" + url
        terminal.window.open(url, "_blank").focus()
    }

    if (args.url && args.file) {
        throw new Error("Too many arguments provided. Please provide either a url or a file.")
    }

    if (args.url) {
        href(args.url)
    } else if (args.file) {
        let file = terminal.getFile(args.file, FileType.PROGRAM)
        href(file.content)
    } else {
        throw new Error("Please provide either a url or a file.")
    }
}, {
    description: "open a link in another tab",
    args: {
        "?u=url:s": "url to open",
        "?f=file:s": "file to open"
    }
})



// ------------------- js/commands/hyp-lines.js --------------------
terminal.addCommand("hyp-lines", async function(args) {
    await terminal.modules.import("game", window)

    function initDisplay(size) {
        let canvas = document.createElement("canvas")
        let context = canvas.getContext("2d")
        let widthPx = Math.floor(terminal.charWidth * size.x)
        let heightPx = Math.floor(terminal.charWidth * size.y)
        canvas.width = widthPx
        canvas.height = heightPx
        canvas.style.width = widthPx + "px"
        canvas.style.height = heightPx + "px"
        terminal.parentNode.appendChild(canvas)
        canvas.style.border = "2px solid var(--foreground)"
        return [context, canvas]
    }

    const displaySize = new Vector2d(args.width, args.height)
    const displayHeaders = ["Poincaré Disk Model", "Upper Half-Plane Model"]

    terminal.addLineBreak()
    for (const headerText of displayHeaders) {
        const paddingWidthTotal = displaySize.x - headerText.length
        const paddingWidthLeft = Math.ceil(paddingWidthTotal / 2)
        const paddingWidthRight = Math.floor(paddingWidthTotal / 2)

        terminal.print(" ".repeat(paddingWidthLeft))
        terminal.print(headerText)
        terminal.print(" ".repeat(paddingWidthRight))
    }

    class ModelCanvas {

        constructor(viewCentre, viewHeight) {
            const [context, canvas] = initDisplay(displaySize)
            this.context = context
            this.canvas = canvas

            this.viewCentre = viewCentre
            this.viewHeight = viewHeight
        }

        get viewWidth() {
            return this.canvas.width / this.canvas.height * this.viewHeight
        }

        pointToScreenPos(point) {
            const relativePoint = point.sub(this.viewCentre)
            return new Vector2d(
                (relativePoint.x / (this.viewWidth) + 0.5) * this.canvas.width,
                (-relativePoint.y / (this.viewHeight) + 0.5) * this.canvas.height
            )
        }

        screenPosToPoint(screenPos) {
            const x = (screenPos.x / this.canvas.width - 0.5) * this.viewWidth
            const y = -(screenPos.y / this.canvas.height - 0.5) * this.viewHeight
            const relativePoint = new Vector2d(x, y)
            return relativePoint.add(this.viewCentre)
        }

        clear() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
        }

        drawPoint(point, {atScreenPos=false, radius=5, color="blue",
            label=null, labelSize=13, labelColor=null, labelOffset=null,
            labelBaseline="top", labelAlign="left"
        }={}) {
            labelColor ??= terminal.data.foreground.toString()
            
            this.context.beginPath()
            let screenPos = null
            if (atScreenPos) {
                screenPos = point
            } else {
                screenPos = this.pointToScreenPos(point)
            }

            this.context.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2)
            this.context.fillStyle = color
            this.context.fill()

            if (label !== null) {
                this.context.fillStyle = labelColor
                this.context.textAlign = labelAlign
                this.context.textBaseline = labelBaseline
                this.context.font = `${labelSize}px monospace`
                const labelPos = screenPos.addX(radius).addY(radius)
                if (labelOffset !== null) {
                    labelPos.iadd(labelOffset.scale(labelSize))
                }

                this.context.fillText(label, screenPos.x + radius, screenPos.y + radius)
            }
        }

        connectPoints(points, {atScreenPos=false, color=null, width=1}={}) {
            color ??= terminal.data.foreground.toString()

            this.context.strokeStyle = color
            this.context.lineWidth = width
            this.context.beginPath()

            for (let i = 0; i < points.length; i++) {
                const screenPos = atScreenPos ? points[i] : this.pointToScreenPos(points[i])
                if (i == 0) {
                    this.context.moveTo(screenPos.x, screenPos.y)
                } else {
                    this.context.lineTo(screenPos.x, screenPos.y)
                }
            }

            this.context.stroke()
        }

        drawAxes() {
            const minXY = this.screenPosToPoint(new Vector2d(0, this.canvas.height))
            const maxXY = this.screenPosToPoint(new Vector2d(this.canvas.width, 0))

            // x axis
            this.connectPoints([
                new Vector2d(Math.floor(minXY.x) - 1, 0),
                new Vector2d(Math.ceil(maxXY.x) + 1, 0)
            ])

            // y axis
            this.connectPoints([
                new Vector2d(0, Math.floor(minXY.y) - 1),
                new Vector2d(0, Math.ceil(maxXY.y) + 1)
            ])

            const pinStyling = {color: terminal.data.foreground.toString(), radius: 3}

            for (let x = Math.floor(minXY.x); x <= Math.ceil(maxXY.x); x++) {
                if (x == 0) continue
                this.drawPoint(new Vector2d(x, 0), {label: x, ...pinStyling})
            }

            for (let y = Math.floor(minXY.y); y <= Math.ceil(maxXY.y); y++) {
                const label = Math.abs(y) > 1 ? `${y}i` : (y < 0 ? "-i" : (y > 0 ? "i" : "0"))
                this.drawPoint(new Vector2d(0, y), {label, ...pinStyling})
            }
        }

        drawCircle(point, radius, {color=null, dashed=false, width=1, startAngle=0, endAngle=Math.PI * 2, clockwise=true}={}) {
            color ??= terminal.data.foreground.toString()

            radius = radius / this.viewHeight * this.canvas.height
            this.context.beginPath()
            const screenPos = this.pointToScreenPos(point)
            this.context.arc(screenPos.x, screenPos.y, radius, startAngle, endAngle, !clockwise)
            this.context.strokeStyle = color
            if (dashed) {
                this.context.setLineDash([5, 5])
            }
            this.context.lineWidth = width
            this.context.stroke()
            this.context.setLineDash([])
        }

    }

    terminal.addLineBreak()
    const diskCanvas = new ModelCanvas(new Vector2d(0, 0), 2.5)
    const planeCanvas = new ModelCanvas(new Vector2d(0, 2.5), 6)
    terminal.addLineBreak(2)
    terminal.printLine("Drag to move z1/z2 around and see what happens (use a mouse!)")
    
    // custom styling
    diskCanvas.canvas.style.borderRight = "none"
    planeCanvas.canvas.style.borderLeft = "2px dashed var(--foreground)"

    const z1 = new Vector2d(0.7, 2.5)
    const z2 = new Vector2d(-1.7, 1.5)

    const movablePoints = [z1, z2]

    function diskToPlaneIso(p) {
        // from https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model
        return new Vector2d(
            2 * p.x / (p.x ** 2 + (1 - p.y) ** 2),
            (1 - p.x ** 2 - p.y ** 2) / (p.x ** 2 + (1 - p.y) ** 2)
        )
    }

    function planeToDiskIso(p) {
        // from https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model
        return new Vector2d(
            2 * p.x / (p.x ** 2 + (1 + p.y) ** 2),
            (p.x ** 2 + p.y ** 2 - 1) / (p.x ** 2 + (1 + p.y) ** 2)
        )
    }

    function redraw() {
        // realign points with half-plane
        for (const point of movablePoints) {
            if (point.y < 0) {
                point.y = 0
            }
        }

        diskCanvas.clear()
        planeCanvas.clear()

        diskCanvas.drawAxes()
        planeCanvas.drawAxes()

        diskCanvas.drawCircle(new Vector2d(0, 0), 1, {dashed: true})

        // draw movable points in plane
        for (let i = 0; i < movablePoints.length; i++) {
            planeCanvas.drawPoint(movablePoints[i], {label: `z${i + 1}`})
        }

        // draw movable points in disk
        for (let i = 0; i < movablePoints.length; i++) {
            const diskPos = planeToDiskIso(movablePoints[i])
            diskCanvas.drawPoint(diskPos, {label: `z${i + 1}`})
        }

        const connectingPoints = []
        const numConnectingPoints = 200

        // draw hyperbolic line on which z1 and z2 lie
        if (Math.abs(z1.x - z2.x) < 0.01) {
            // calculate and draw line in plane
            const minXY = planeCanvas.screenPosToPoint(new Vector2d(0, planeCanvas.canvas.height))
            const maxXY = planeCanvas.screenPosToPoint(new Vector2d(planeCanvas.canvas.width, 0))

            planeCanvas.connectPoints([
                new Vector2d(z1.x, 0),
                new Vector2d(z1.x, maxXY.y),
            ], {color: "lightblue", width: 2})

            for (let i = 0; i < numConnectingPoints; i++) {
                const linePos = new Vector2d(z1.x, i / 10)
                connectingPoints.push(linePos)
            }
        } else {
            // calculate and draw half circle in plane
            const midPoint = z1.add(z2).scale(0.5)
            const tanAlpha = Math.tan(z1.angleTo(z2))
            const halfCircleCentre = new Vector2d(midPoint.x + tanAlpha * midPoint.y, 0)
            const halfCirlceRadius = halfCircleCentre.distance(z1)

            planeCanvas.drawCircle(halfCircleCentre, halfCirlceRadius, {
                endAngle: Math.PI, clockwise: false, color: "lightblue", width: 2
            })

            for (let i = 0; i < numConnectingPoints; i++) {
                const unitCirclePos = Vector2d.fromAngle(i / (numConnectingPoints - 1) * Math.PI)
                const circlePos = unitCirclePos.scale(halfCirlceRadius).add(halfCircleCentre)
                connectingPoints.push(circlePos)
            }
        }

        diskCanvas.connectPoints(connectingPoints.map(p => planeToDiskIso(p)), {color: "lightblue", width: 2})
    }

    let draggingPoint = null
    const dragMaxDistancePx = 30

    const pointFromEvent = (canvas, event) => {
        const screenPos = Vector2d.fromEvent(event, canvas.canvas)
        return canvas.screenPosToPoint(screenPos)
    }

    const halfPlanePointInFunc = (event) => {
        const regularPlanePos = pointFromEvent(planeCanvas, event)
        regularPlanePos.y = Math.abs(regularPlanePos.y)
        return regularPlanePos.scale(10).round().scale(0.1)
    }

    const halfPlanePointOutFunc = point => planeCanvas.pointToScreenPos(point)

    const diskPointInFunc = (event) => {
        const normalPlanePos = pointFromEvent(diskCanvas, event)
        const planePos = diskToPlaneIso(normalPlanePos)
        return planePos
    }

    const diskPointOutFunc = point => diskCanvas.pointToScreenPos(planeToDiskIso(point))

    for (const [canvas, pointInFunc, pointOutFunc] of [
        [planeCanvas, halfPlanePointInFunc, halfPlanePointOutFunc],
        [diskCanvas, diskPointInFunc, diskPointOutFunc]
    ]) {
        canvas.canvas.addEventListener("mousedown", event => {
            const mousePos = pointInFunc(event)
            const mouseScreenPos = pointOutFunc(mousePos)
            for (const point of movablePoints) {
                if (pointOutFunc(point).distance(mouseScreenPos) <= dragMaxDistancePx) {
                    draggingPoint = point
                    draggingPoint.set(mousePos)
                    return redraw()
                }
            }
        })

        canvas.canvas.addEventListener("touchstart", event => {
            const mousePos = pointInFunc(event)
            const mouseScreenPos = pointOutFunc(mousePos)
            for (const point of movablePoints) {
                if (pointOutFunc(point).distance(mouseScreenPos) <= dragMaxDistancePx) {
                    draggingPoint = point
                    draggingPoint.set(mousePos)
                    return redraw()
                }
            }
            event.preventDefault()
        })

        canvas.canvas.addEventListener("mousemove", event => {
            if (draggingPoint !== null) {
                const mousePos = pointInFunc(event)
                draggingPoint.set(mousePos)
                redraw()
            }
        })

        canvas.canvas.addEventListener("touchmove", event => {
            if (draggingPoint !== null) {
                const mousePos = pointInFunc(event)
                draggingPoint.set(mousePos)
                redraw()
                event.preventDefault()
            }
        })

        canvas.canvas.addEventListener("mouseup", event => {
            draggingPoint = null
            redraw()
        })

        canvas.canvas.addEventListener("touchend", event => {
            draggingPoint = null
            redraw()
            event.preventDefault()
        })
    }

    redraw()

}, {
    description: "spawn a simulation of the hyperbolic disk and half-plane model",
    args: {
        "?w=width:i:22~100": "width of each screen in characters",
        "?h=height:i:10~100": "height of each screen in characters",
    },
    defaultValues: {
        width: 50,
        height: 40
    }
})

// ------------------- js/commands/image-crop.js --------------------
terminal.addCommand("image-crop", async function() {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../image-crop/",
        name: "Image Cropper"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "start image cropper program"
})

// ------------------- js/commands/img2ascii.js --------------------
terminal.addCommand("img2ascii", async function(args) {
    await terminal.modules.load("upload", terminal)

    let image = await terminal.modules.upload.image()

    let outputSize = {x: args.width, y: 0}
    outputSize.y = parseInt(outputSize.x * (image.height / image.width) * 0.6)

    let asciiChars = " .:-=+*#%@"

    let tempCanvas = document.createElement("canvas")
    tempCanvas.style.display = "none"
    document.body.appendChild(tempCanvas)
    tempCanvas.width = image.width
    tempCanvas.height = image.height

    let context = tempCanvas.getContext("2d")
    context.drawImage(image, 0, 0)

    let imageData = context.getImageData(0, 0, tempCanvas.width, tempCanvas.height)

    let xStep = parseInt(tempCanvas.width / outputSize.x)
    let yStep = parseInt(tempCanvas.height / outputSize.y)
    
    function getAverageColor(blockX, blockY) {
        let colorSum = 0
        let colorCount = 0
        let i = blockY * yStep * tempCanvas.width * 4 + blockX * 4 * xStep
        for (let y = 0; y < yStep; y++) {
            for (let x = 0; x < xStep; x++) {
                colorSum += imageData.data[i + 0]
                colorSum += imageData.data[i + 1]
                colorSum += imageData.data[i + 2]
                colorCount += 3
                i += 4
            }
            i += tempCanvas.width * 4 - xStep * 4
        }
        return colorSum / colorCount
    }

    terminal.printLine()
    for (let i = 0; i < outputSize.y; i++) {
        for (let j = 0; j < outputSize.x; j++) {
            let averageColor = getAverageColor(j, i)
            let char = asciiChars[parseInt((asciiChars.length - 1) * (averageColor / 255))]
            terminal.print(char)
        }
        terminal.printLine()
    }
}, {
    description: "Convert an image to ASCII art",
    args: {
        "?w=width:i:1~500": "the width of the output image in characters"
    },
    defaultValues: {
        width: 60
    }
})

// ------------------- js/commands/img2pdf.js --------------------
const img2pdfUrl = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.debug.js"

async function rotateImg90(img) {
    const canvas = document.createElement("canvas")
    const context = canvas.getContext("2d")

    canvas.width = img.naturalHeight
    canvas.height = img.naturalWidth

    context.rotate(Math.PI / 2)

    context.drawImage(img, 0, -canvas.width, canvas.height, canvas.width)

    const newImg = new Image()

    return new Promise(resolve => {
        newImg.onload = () => resolve(newImg)
        newImg.name = img.name
        newImg.src = canvas.toDataURL()
    })
}

terminal.addCommand("img2pdf", async function(args) {
    if (!document.getElementById("img2pdfScript")) {
        await new Promise(resolve => {
            const script = document.createElement("script")
            script.addEventListener("load", resolve)
            script.src = img2pdfUrl
            script.id = "img2pdfScript"
            document.body.appendChild(script)
        })
    }

    await terminal.modules.load("upload", terminal)
    const images = await terminal.modules.upload.image({multiple: true})

    const doc = new jsPDF()
    const pdfWidth = doc.internal.pageSize.getWidth()
    const pdfHeight = doc.internal.pageSize.getHeight()
    const pdfPadding = args.padding
    
    for (let i = 0; i < images.length; i++) {
        let img = images[i]
        const format = img.src.split("image/")[1].split(";")[0]
        let imgAspectRatio = img.naturalWidth / img.naturalHeight

        if (args.rotate && imgAspectRatio > 1) {
            img = await rotateImg90(img)
            imgAspectRatio = img.naturalWidth / img.naturalHeight
        }

        let imgWidth = pdfWidth - pdfPadding * 2
        let imgHeight = imgWidth / imgAspectRatio

        if (imgHeight > pdfHeight - pdfPadding * 2) {
            imgHeight = pdfHeight - pdfPadding * 2
            imgWidth = imgHeight * imgAspectRatio
        }

        let xOffset = pdfWidth / 2 - imgWidth / 2
        let yOffset = pdfHeight / 2 - imgHeight / 2

        try {
            doc.addImage(img.src, format, xOffset, yOffset, imgWidth, imgHeight)
        } catch (e) {
            if (e.message.includes("Supplied Data is not a valid base64-String")) {
                throw new Error(`${img.name} isn't an image!`)
            } else {
                throw e
            }
        }

        if (i != images.length - 1) {
            doc.addPage()
        }

        if (images.length > 1) {
            terminal.printLine(`Loaded ${img.name} (${i+1}/${images.length})`)
            terminal.scroll()
            await sleep(50)

            if (i == images.length - 1) {
                terminal.addLineBreak()
            }
        }
    }

    const validFilenameRegex = /^[a-zA-Z0-9\.\_\s\-]+$/
    let fileName = args.filename

    while (!fileName) {
        fileName = await terminal.prompt("filename: ")
        if (!validFilenameRegex.test(fileName)) {
            terminal.printError("Invalid Filename. Must not include special characters!")
            fileName = null
        }
    }

    if (!fileName.endsWith(".pdf")) {
        fileName += ".pdf"
    }

    doc.save(fileName)
    terminal.printSuccess(`Downloaded ${fileName}`)
}, {
    description: "convert image files to pdf",
    args: {
        "?f=filename:s": "filename for the pdf",
        "?p=padding:i:0~50": "padding of pdf (in px)",
        "?r=rotate:b": "rotate the images to maximise space",
    },
    defaultValues: {
        filename: null,
        padding: 5,
    }
})

// ------------------- js/commands/imgwarp.js --------------------
terminal.addCommand("imgwarp", async function(args) {
	await terminal.modules.import("game", window)

    const priorityFunction = new Function("x", "y", `return ${args.f}`)

	function initDisplay() {
        let canvas = document.createElement("canvas")
        let context = canvas.getContext("2d")
        let widthPx = Math.floor(terminal.charWidth * 50)
        let heightPx = widthPx
        canvas.width = widthPx
        canvas.height = heightPx
        canvas.style.width = widthPx + "px"
        canvas.style.height = heightPx + "px"
        terminal.parentNode.appendChild(canvas)
        context.fillStyle = "white"
        context.fillRect(0, 0, canvas.width, canvas.height)
        return [context, canvas]
	}

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image()
            img.onload = () => {
                resolve(img)   
            }
            img.onerror = (err) => {
                reject(err)
            }
            img.src = src
        })
    }

    terminal.addLineBreak()
    const backgroundImage = await loadImage("res/img/imgwarp/BlankMap-World-v2.png")
	const [context2d, canvas] = initDisplay()
	const [resultContext2d, resultCanvas] = initDisplay()

    const sorroundingDirections = [
        new Vector2d( 0,  1),
        new Vector2d( 0, -1),
        new Vector2d( 1,  0),
        new Vector2d(-1,  0)
    ]

    context2d.drawImage(backgroundImage, 0, 0)

    // start exploration

    const startPos = new Vector2d(
        Math.round(canvas.width / 2),
        Math.round(canvas.height / 2)
    )

    const pixelQueue = [[0, startPos]]

    function setPixelToRGBA(imgData, pos, r=null, g=null, b=null, a=null) {
        if (!isWithinBounds(pos)) {
            return
        }

        const i = pos.y * (canvas.width * 4) + pos.x * 4
        if (r !== null) imgData.data[i]     = r
        if (g !== null) imgData.data[i + 1] = g
        if (b !== null) imgData.data[i + 2] = b
        if (a !== null) imgData.data[i + 3] = a
    }

    function getPixelRGBA(imgData, pos) {
        const i = pos.y * (canvas.width * 4) + pos.x * 4
        return [
            imgData.data[i],
            imgData.data[i + 1],
            imgData.data[i + 2],
            imgData.data[i + 3],
        ]
    }
    
    function pixelPosToPriorityPos(pixelPos) {
        const canvasHalfWidth = canvas.width / 2
        const canvasHalfHeight = canvas.height / 2
        return new Vector2d(
            (pixelPos.x - canvasHalfWidth),
            (pixelPos.y - canvasHalfHeight)
        )
    }

    function popFromQueue() {
        if (pixelQueue.length == 0) {
            return null
        } else {
            return pixelQueue.shift()[1]
        }
    }

    function insortIntoQueue(priority, pos) {
        if (pixelQueue.length == 0) {
            pixelQueue.push([priority, pos])
            return
        }

        if (priority <= pixelQueue[0][0]) {
            pixelQueue.unshift([priority, pos])
            return
        }

        if (priority >= pixelQueue[pixelQueue.length - 1][0]) {
            pixelQueue.push([priority, pos])
            return
        }

        let left = 0
        let right = pixelQueue.length
        let lastLeft = left
        let lastRight = right
        while (left < right) {
            const middle = Math.floor((left + right) / 2)
            if (pixelQueue[middle][0] < priority) {
                left = middle
            } else if (pixelQueue[middle][0] > priority) {
                right = middle
            } else {
                left = middle
                right = middle
            }

            if (left === lastLeft && right === lastRight) {
                break
            }

            lastLeft = left
            lastRight = right   
        }

        pixelQueue.splice(right, 0, [priority, pos])
    }

    function isMarked(imgData, pos) {
        const i = pos.y * (canvas.width * 4) + pos.x * 4
        return imgData.data[i + 3] == 0
    }

    function markPixel(resultImgData, imgData, pos) {
        const pixelRGBA = getPixelRGBA(imgData, pos)
        setPixelToRGBA(imgData, pos, null, null, null, 0)
        
        const priorityPos = pixelPosToPriorityPos(pos)
        const distance = priorityFunction(priorityPos.x, priorityPos.y)
        const resultPos = new Vector2d(canvas.width, canvas.height)
            .scale(0.5)
            .add(priorityPos.normalized.scale(distance))

        const resultFlooredPos = new Vector2d(Math.floor(resultPos.x), Math.floor(resultPos.y))
        setPixelToRGBA(resultImgData, resultFlooredPos, ...pixelRGBA)
    }

    function isWithinBounds(pos) {
        return pos.x >= 0 && pos.y >= 0 && pos.x < canvas.width && pos.y < canvas.height
    }

    function explorePixel(imgData, pos) {
        for (const direction of sorroundingDirections) {
            const newPos = pos.add(direction)
            if (isWithinBounds(newPos) && !isMarked(imgData, newPos)) {
                const priorityPos = pixelPosToPriorityPos(newPos)
                const priority = priorityFunction(priorityPos.x, priorityPos.y)
                insortIntoQueue(priority, newPos)
            }
        }
    }

    const imgData = context2d.getImageData(0, 0, canvas.width, canvas.height)
    const resultImgData = resultContext2d.getImageData(0, 0, canvas.width, canvas.height)

    await sleep(100)
    terminal.scroll()
    await sleep(100)

    for (let i = 0; pixelQueue.length > 0; i++) {
        const pos = popFromQueue()
        if (isMarked(imgData, pos)) {
            continue
        }

        markPixel(resultImgData, imgData, pos)
        explorePixel(imgData, pos)

        context2d.putImageData(imgData, 0, 0)
        resultContext2d.putImageData(resultImgData, 0, 0)

        if (i % 10 == 0) {
            await sleep(0)
        }
    }

}, {
	description: "warp an image using a geometric step-distance function",
    args: {
        "f=function:s": "step distance function",
    },
    isSecret: true
})

// ------------------- js/commands/isprime.js --------------------
terminal.addCommand("isprime", async function(args) {
    function isPrime(n) {
        if (n < 2)
            return {result: false}
        if (n === 2)
            return {result: true}
        if (n % 2 === 0)
            return {result: false, divisor: 2}
        for (let i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i === 0)
                return {result: false, divisor: i}
        }
        return {result: true}
    }

    if (args.n < 0) {
        return terminal.printLine(`${args.n} is not prime (negative numbers just aren't)`)
    } else if (args.n == 0) {
        return terminal.printLine("0 is not prime (not even composite!)")
    } else if (args.n == 1) {
        return terminal.printLine("1 is not prime (it's the identity, wouldn't make much sense)")
    } else if (args.n == 2) {
        return terminal.printLine("2 is prime (the only even prime!)")
    } else if (args.n.toString().includes("e+")) {
        return terminal.printLine("Honestly no idea, too large for me.")
    } else if (args.n == 57) {
        terminal.printEasterEgg("Grothendieck-Egg")
        return terminal.printLine("57 looks prime, but isn't")
    }

    let primeResult = isPrime(args.n)
    if (primeResult.result) {
        terminal.printLine(`${args.n} is prime`)
    } else {
        if (primeResult.divisor) {
            const m = args.n / primeResult.divisor
            terminal.printLine(`${args.n} is not prime (${primeResult.divisor} * ${m} = ${args.n})`)
        } else {
            terminal.printLine(`${args.n} is not prime`)
        }

        let n = args.n
        let distanceCount = 1
        if (args["find-next"]) {
            await sleep(10)
            while (!isPrime(++n).result) {distanceCount++}
            terminal.printLine(`the next prime is ${n} (diff=${distanceCount})`)
        }
    }
}, {
    description: "Check if a number is prime",
    args: {
        "n:i": "The number to check",
        "?f=find-next:b": "if n is not prime, find the next one"
    }
})

// ------------------- js/commands/joke.js --------------------
terminal.addCommand("joke", async function(args) {
    let response = await fetch("https://official-joke-api.appspot.com/random_joke")
    let joke = await response.json()
    terminal.printLine(joke.setup)
    await sleep(3000)
    terminal.printLine(joke.punchline)
}, {
    description: "tell a joke",
})



// ------------------- js/commands/kaprekar.js --------------------
terminal.addCommand("kaprekar", async function(args) {
    let startNumber = ~~args.n
    let numDigits = startNumber.toString().length

    let history = new Set([startNumber])

    function f(n) {
        let a = Array.from(n.toString())
        let b = Array.from(n.toString())

        while (a.length < numDigits)
            a.push("0")

        while (b.length < numDigits)
            b.push("0")

        a = a.sort().join("")
        b = b.sort((a, b) => b - a).join("")

        let m = b - a

        terminal.printLine(`${b} - ${a} = ${stringPad(m, numDigits, "0")}`)

        if (n === m || m === 0)
            return n

        if (history.has(m)) {
            terminal.printLine("Cycle detected!")
            return m
        }

        history.add(m)

        return f(m)
    }

    f(startNumber)

}, {
    description: "display the kaprekar steps of a number",
    args: {
        "n:n:1~999999999": "the number to display the kaprekar steps of"
    }
})



// ------------------- js/commands/keyboard.js --------------------
terminal.addCommand("keyboard", function(args) {
    let mode = args.m || "toggle"

    if (mode == "status") {
        let status = "auto"
        if (terminal.data.mobile === true) {
            status = "on"
        } else if (terminal.data.mobile === false) {
            status = "off"
        }

        terminal.printLine(`keyboard_mode=\"${status}\"`)
        terminal.addLineBreak()
        terminal.printCommand("Set to \"on\"", "keyboard on")
        terminal.printCommand("Set to \"off\"", "keyboard off")
        terminal.printCommand("Set to \"auto\"", "keyboard auto")
    }

    if (mode == "on") {
        terminal.data.mobile = true
        terminal.reload()
    }

    if (mode == "off") {
        terminal.data.mobile = false
        terminal.reload()
    }

    if (mode == "auto") {
        terminal.data.resetProperty("mobile")
        terminal.reload()
    }
}, {
    description: "Toggle mobile mode",
    args: {
        "?m=mode:s": "status | on | off | auto"
    },
    defaultValues: {
        m: "status"
    }
})

// ------------------- js/commands/kill.js --------------------
terminal.addCommand("kill", async function(args) {
    if (args.process.toLowerCase() == "turtlo") {
        await terminal.modules.load("turtlo", terminal)
        if (terminal.modules.turtlo.kill()) {
            terminal.printLine("done.")
        } else {
            terminal.printLine("i see no turtlo alive here")
        }
    } else {
        terminal.printLine("sorry no killing allowed here (except turtlo)")
    }
}, {
    description: "kill a process",
    args: {
        "process": "the process to kill"
    }
})



// ------------------- js/commands/labyrinth.js --------------------
terminal.addCommand("labyrinth", async function(args) {
    await terminal.modules.import("game", window)

    let laberynthSize = new Vector2d(15, 15)
    let horizontalResolution = 90
    let verticalResolution = 30
    let FOV = Math.PI / 2
    let FPS = ~~args.fps

    let playerPos = new Vector2d(1, 1)
    let playerAngle = Math.PI / 4
    let playerTurnSpeed = Math.PI / 32
    let playerMoveSpeed = 0.05

    const EMPTY = " "
    const END = "E"
    const WALL = "#"
    const PATH = EMPTY

    function generateTilemap() {
        function isWall(x, y) {
            return x % 2 == 0 || y % 2 == 0
        }

        let tiles = Array.from({length: laberynthSize.y},
            (_, y) => Array.from({length: laberynthSize.x}, (_, x) => isWall(x, y) ? WALL : null))

        // generate maze

        let visitedTiles = [new Vector2d(1, 1)]

        function randomVisitedTile() {
            return visitedTiles[Math.floor(Math.random() * visitedTiles.length)]
        }

        const neighborDirections = [
            new Vector2d(0, -2),
            new Vector2d(0, 2),
            new Vector2d(-2, 0),
            new Vector2d(2, 0)
        ]

        function randomDirection() {
            return neighborDirections[Math.floor(Math.random() * neighborDirections.length)]
        }

        let totalVisibleTiles = (laberynthSize.x - 1) * (laberynthSize.y - 1) / 4 + 1
        while (visitedTiles.length < totalVisibleTiles) {
            let tile = randomVisitedTile()
            let direction = randomDirection()
            let neighbor = tile.add(direction)
            if (tiles[neighbor.y] && tiles[neighbor.y][neighbor.x] === null) {
                tiles[tile.y + direction.y / 2][tile.x + direction.x / 2] = PATH
                tiles[neighbor.y][neighbor.x] = PATH
                visitedTiles.push(neighbor)
            }
        }
        
        return tiles
    }

    let tilemap = generateTilemap()
    let colorMap = generateColormap()

    function setGoal(x, y) {
        tilemap[y][x] = END
        colorMap[y][x] = "white"
    }

    setGoal(laberynthSize.x - 2, laberynthSize.y - 2)

    function generateColormap() {
        let colormap = []
        for (let y = 0; y < laberynthSize.y; y++) {
            let row = []
            for (let x = 0; x < laberynthSize.x; x++) {
                row.push(Math.floor(Math.random() * 360))
            }
            colormap.push(row)
        }
        return colormap
    }

    function darkenColor(hue, distance) {
        let brightness = Math.max(0, 50 - distance * 6)
        return `hsl(${hue}, 30%, ${brightness}%)`
    }

    let drawnElements = []
    let lineElements = [];

    (function firstPrint() {
        terminal.printLine("Use the arrow keys to move around. Press Ctrl+C to quit.")
        terminal.printLine("Your Goal: find the exit (a white box) and run into it as fast as possible!")
        terminal.addLineBreak()
        for (let y = 0; y < verticalResolution; y++) {
            let row = []
            for (let x = 0; x < horizontalResolution; x++) {
                let element = terminal.print(" ", undefined, {forceElement: true})
                element.style.transition = "none"
                row.push(element)
                drawnElements.push(element)
            }
            lineElements.push(row)
            let br = terminal.print("\n", undefined, {forceElement: true})
            drawnElements.push(br)
        }
    })()

    function drawLine(x, height, color="blue") {
        for (let y = 0; y < verticalResolution; y++) {
            let element = lineElements[y][x]
            if (y < verticalResolution / 2 - height / 2 || y > verticalResolution / 2 + height / 2) {
                element.textContent = " "
            } else {
                element.textContent = "#"
                element.style.color = color
            }
        }
    }

    function rayCast(angle, accuracy=0.1) {
        let ray = new Vector2d(Math.cos(angle), Math.sin(angle)).scale(accuracy)
        let rayPos = playerPos.copy()
        let distance = 0
        while (true) {
            rayPos.iadd(ray)
            distance += accuracy
            let value = tilemap[Math.floor(rayPos.y)][Math.floor(rayPos.x)]
            if (value == WALL || value == END) {
                let color = colorMap[Math.floor(rayPos.y)][Math.floor(rayPos.x)]
                return [distance, (typeof color == "string") ? color : darkenColor(color, distance)]
            }
        }
    }

    function drawPlayerview() {
        for (let x = 0; x < horizontalResolution; x++) {
            let angle = FOV / 2 - FOV * x / horizontalResolution
            let [distance, color] = rayCast(playerAngle + angle)
            let height = verticalResolution / distance
            drawLine(x, height, color)
        }
    }

    function playerDirection() {
        return Vector2d.fromAngle(playerAngle)
    }

    let gameRunning = true

    function moveForward() {
        let direction = playerDirection().scale(playerMoveSpeed)
        let newPos = playerPos.add(direction)
        let value = tilemap[Math.floor(newPos.y)][Math.floor(newPos.x)]
        if (value == END) {
            gameRunning = false
        } else if (value != WALL) {
            playerPos = newPos
        }
    }

    function moveBackward() {
        let direction = playerDirection().scale(-playerMoveSpeed)
        let newPos = playerPos.add(direction)
        if (tilemap[Math.floor(newPos.y)][Math.floor(newPos.x)] != WALL) {
            playerPos = newPos
        }
    }

    function removeScreen() {
        for (let element of drawnElements) {
            element.remove()
        }
        drawnElements = []
    }

    function turnLeft() {
        playerAngle += playerTurnSpeed
    }

    function turnRight() {
        playerAngle -= playerTurnSpeed
    }

    let keyDown = {
        "UP": false,
        "DOWN": false,
        "LEFT": false,
        "RIGHT": false
    }

    function parseKeyCode(keycode, up) {
        if (keycode == "ArrowUp" || keycode == "w") {
            keyDown.UP = !up
            return true
        } else if (keycode == "ArrowDown" || keycode == "s") {
            keyDown.DOWN = !up
            return true
        } else if (keycode == "ArrowLeft" || keycode == "a") {
            keyDown.LEFT = !up
            return true
        } else if (keycode == "ArrowRight" || keycode == "d") {
            keyDown.RIGHT = !up
            return true
        }
    }

    let upListener = addEventListener("keyup", function(event) {
        if (!gameRunning) return

        if (parseKeyCode(event.key, true)) event.preventDefault()
    })

    let downListener = addEventListener("keydown", function(event) {
        if (!gameRunning) return

        if (event.key == "c" && event.ctrlKey) {
            gameRunning = false
            removeScreen()
            removeEventListener("keydown", downListener)
            removeEventListener("keyup", upListener)
        }

        if (parseKeyCode(event.key, false)) event.preventDefault()
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout(
            terminal.mobileKeyboard.Layout.ARROWS
        )

        terminal.mobileKeyboard.onkeydown = function(event, keyCode) {
            parseKeyCode(keyCode, false)
        }

        terminal.mobileKeyboard.onkeyup = function(event, keyCode) {
            parseKeyCode(keyCode, true)
        }
    }

    function processInput() {
        if (keyDown.UP) moveForward()
        if (keyDown.DOWN) moveBackward()
        if (keyDown.LEFT) turnLeft()
        if (keyDown.RIGHT) turnRight()
    }

    terminal.scroll()
    
    let score = 0

    while (gameRunning) {
        score++
        let startTime = performance.now()
        processInput()
        drawPlayerview()
        let deltaMs = performance.now() - startTime
        await sleep(1000 / FPS - deltaMs)
    }

    score *= -1

    removeScreen()
    terminal.addLineBreak()
    terminal.printLine(`You won! Your score is ${Math.abs(score)}.`)

    await HighscoreApi.registerProcess("labyrinth")
    await HighscoreApi.uploadScore(score)

}, {
    description: "play a game of labyrinth",
    isGame: true,
    args: {
        "?fps:n:1~60": "the frames per second of the game",
    },
    standardVals: {
        fps: 30
    }
})

// ------------------- js/commands/letters.js --------------------
const AsciiArtLetters = {}
{
    let chars = "abcdefghijklmnopqrstuvwxyz"
    chars += "0123456789"
    chars += ".-,!? +"

    for (let char of chars) {
        AsciiArtLetters[char] = ""
    }
}

AsciiArtLetters["a"] += "       \n"
AsciiArtLetters["a"] += "       \n"
AsciiArtLetters["a"] += "  __ _ \n"
AsciiArtLetters["a"] += " / _` |\n"
AsciiArtLetters["a"] += "| (_| |\n"
AsciiArtLetters["a"] += " \\__,_|\n"
AsciiArtLetters["a"] += "       \n"
AsciiArtLetters["a"] += "       \n"

AsciiArtLetters["b"] += "  _     \n"
AsciiArtLetters["b"] += " | |    \n"
AsciiArtLetters["b"] += " | |__  \n"
AsciiArtLetters["b"] += " | '_ \\ \n"
AsciiArtLetters["b"] += " | |_) |\n"
AsciiArtLetters["b"] += " |_.__/ \n"
AsciiArtLetters["b"] += "        \n"
AsciiArtLetters["b"] += "        \n"

AsciiArtLetters["c"] += "      \n"
AsciiArtLetters["c"] += "      \n"
AsciiArtLetters["c"] += "  ___ \n"
AsciiArtLetters["c"] += " / __|\n"
AsciiArtLetters["c"] += "| (__ \n"
AsciiArtLetters["c"] += " \\___|\n"
AsciiArtLetters["c"] += "      \n"
AsciiArtLetters["c"] += "      \n"

AsciiArtLetters["d"] += "     _ \n"
AsciiArtLetters["d"] += "    | |\n"
AsciiArtLetters["d"] += "  __| |\n"
AsciiArtLetters["d"] += " / _` |\n"
AsciiArtLetters["d"] += "| (_| |\n"
AsciiArtLetters["d"] += " \\__,_|\n"
AsciiArtLetters["d"] += "       \n"
AsciiArtLetters["d"] += "       \n"

AsciiArtLetters["e"] += "      \n"
AsciiArtLetters["e"] += "      \n"
AsciiArtLetters["e"] += "  ___ \n"
AsciiArtLetters["e"] += " / _ \\\n"
AsciiArtLetters["e"] += "|  __/\n"
AsciiArtLetters["e"] += " \\___|\n"
AsciiArtLetters["e"] += "      \n"
AsciiArtLetters["e"] += "      \n"

AsciiArtLetters["f"] += "  __ \n"
AsciiArtLetters["f"] += " / _|\n"
AsciiArtLetters["f"] += "| |_ \n"
AsciiArtLetters["f"] += "|  _|\n"
AsciiArtLetters["f"] += "| |  \n"
AsciiArtLetters["f"] += "|_|  \n"
AsciiArtLetters["f"] += "     \n"
AsciiArtLetters["f"] += "     \n"

AsciiArtLetters["g"] += "       \n"
AsciiArtLetters["g"] += "       \n"
AsciiArtLetters["g"] += "  __ _ \n"
AsciiArtLetters["g"] += " / _` |\n"
AsciiArtLetters["g"] += "| (_| |\n"
AsciiArtLetters["g"] += " \\__, |\n"
AsciiArtLetters["g"] += "  __/ |\n"
AsciiArtLetters["g"] += " |___/ \n"

AsciiArtLetters["h"] += " _     \n"
AsciiArtLetters["h"] += "| |    \n"
AsciiArtLetters["h"] += "| |__  \n"
AsciiArtLetters["h"] += "| '_ \\ \n"
AsciiArtLetters["h"] += "| | | |\n"
AsciiArtLetters["h"] += "|_| |_|\n"
AsciiArtLetters["h"] += "       \n"
AsciiArtLetters["h"] += "       \n"

AsciiArtLetters["i"] += " _ \n"
AsciiArtLetters["i"] += "(_)\n"
AsciiArtLetters["i"] += " _ \n"
AsciiArtLetters["i"] += "| |\n"
AsciiArtLetters["i"] += "| |\n"
AsciiArtLetters["i"] += "|_|\n"
AsciiArtLetters["i"] += "   \n"
AsciiArtLetters["i"] += "   \n"

AsciiArtLetters["j"] += "     \n"
AsciiArtLetters["j"] += "     \n"
AsciiArtLetters["j"] += "   _ \n"
AsciiArtLetters["j"] += "  (_)\n"
AsciiArtLetters["j"] += "   _ \n"
AsciiArtLetters["j"] += "  | |\n"
AsciiArtLetters["j"] += "  | |\n"
AsciiArtLetters["j"] += "  | |\n"
AsciiArtLetters["j"] += " _/ |\n"
AsciiArtLetters["j"] += "|__/ \n"

AsciiArtLetters["k"] += " _    \n"
AsciiArtLetters["k"] += "| |   \n"
AsciiArtLetters["k"] += "| | __\n"
AsciiArtLetters["k"] += "| |/ /\n"
AsciiArtLetters["k"] += "|   < \n"
AsciiArtLetters["k"] += "|_|\\_\\\n"
AsciiArtLetters["k"] += "      \n"
AsciiArtLetters["k"] += "      \n"

AsciiArtLetters["l"] += " _ \n"
AsciiArtLetters["l"] += "| |\n"
AsciiArtLetters["l"] += "| |\n"
AsciiArtLetters["l"] += "| |\n"
AsciiArtLetters["l"] += "| |\n"
AsciiArtLetters["l"] += "|_|\n"
AsciiArtLetters["l"] += "   \n"
AsciiArtLetters["l"] += "   \n"

AsciiArtLetters["m"] += "           \n"
AsciiArtLetters["m"] += "           \n"
AsciiArtLetters["m"] += " _ __ ___  \n"
AsciiArtLetters["m"] += "| '_ ` _ \\ \n"
AsciiArtLetters["m"] += "| | | | | |\n"
AsciiArtLetters["m"] += "|_| |_| |_|\n"
AsciiArtLetters["m"] += "           \n"
AsciiArtLetters["m"] += "           \n"

AsciiArtLetters["n"] += "       \n"
AsciiArtLetters["n"] += "       \n"
AsciiArtLetters["n"] += " _ __  \n"
AsciiArtLetters["n"] += "| '_ \\ \n"
AsciiArtLetters["n"] += "| | | |\n"
AsciiArtLetters["n"] += "|_| |_|\n"
AsciiArtLetters["n"] += "       \n"
AsciiArtLetters["n"] += "       \n"

AsciiArtLetters["o"] += "       \n"
AsciiArtLetters["o"] += "       \n"
AsciiArtLetters["o"] += "  ___  \n"
AsciiArtLetters["o"] += " / _ \\ \n"
AsciiArtLetters["o"] += "| (_) |\n"
AsciiArtLetters["o"] += " \\___/ \n"
AsciiArtLetters["o"] += "       \n"
AsciiArtLetters["o"] += "       \n"

AsciiArtLetters["p"] += "       \n"
AsciiArtLetters["p"] += "       \n"
AsciiArtLetters["p"] += " _ __  \n"
AsciiArtLetters["p"] += "| '_ \\ \n"
AsciiArtLetters["p"] += "| |_) |\n"
AsciiArtLetters["p"] += "| .__/ \n"
AsciiArtLetters["p"] += "| |    \n"
AsciiArtLetters["p"] += "|_|    \n"

AsciiArtLetters["q"] += "       \n"
AsciiArtLetters["q"] += "       \n"
AsciiArtLetters["q"] += "  __ _ \n"
AsciiArtLetters["q"] += " / _` |\n"
AsciiArtLetters["q"] += "| (_| |\n"
AsciiArtLetters["q"] += " \\__, |\n"
AsciiArtLetters["q"] += "    | |\n"
AsciiArtLetters["q"] += "    |_|\n"

AsciiArtLetters["r"] += "      \n"
AsciiArtLetters["r"] += "      \n"
AsciiArtLetters["r"] += " _ __ \n"
AsciiArtLetters["r"] += "| '__|\n"
AsciiArtLetters["r"] += "| |   \n"
AsciiArtLetters["r"] += "|_|   \n"
AsciiArtLetters["r"] += "      \n"
AsciiArtLetters["r"] += "      \n"

AsciiArtLetters["s"] += "     \n"
AsciiArtLetters["s"] += "     \n"
AsciiArtLetters["s"] += " ___ \n"
AsciiArtLetters["s"] += "/ __|\n"
AsciiArtLetters["s"] += "\\__ \\\n"
AsciiArtLetters["s"] += "|___/\n"
AsciiArtLetters["s"] += "     \n"
AsciiArtLetters["s"] += "     \n"

AsciiArtLetters["t"] += " _   \n"
AsciiArtLetters["t"] += "| |  \n"
AsciiArtLetters["t"] += "| |_ \n"
AsciiArtLetters["t"] += "| __|\n"
AsciiArtLetters["t"] += "| |_ \n"
AsciiArtLetters["t"] += " \\__|\n"
AsciiArtLetters["t"] += "     \n"
AsciiArtLetters["t"] += "     \n"

AsciiArtLetters["u"] += "       \n"
AsciiArtLetters["u"] += "       \n"
AsciiArtLetters["u"] += " _   _ \n"
AsciiArtLetters["u"] += "| | | |\n"
AsciiArtLetters["u"] += "| |_| |\n"
AsciiArtLetters["u"] += " \\__,_|\n"
AsciiArtLetters["u"] += "       \n"
AsciiArtLetters["u"] += "       \n"

AsciiArtLetters["v"] += "       \n"
AsciiArtLetters["v"] += "       \n"
AsciiArtLetters["v"] += "__   __\n"
AsciiArtLetters["v"] += "\\ \\ / /\n"
AsciiArtLetters["v"] += " \\ V / \n"
AsciiArtLetters["v"] += "  \\_/  \n"
AsciiArtLetters["v"] += "       \n"
AsciiArtLetters["v"] += "       \n"

AsciiArtLetters["w"] += "          \n"
AsciiArtLetters["w"] += "          \n"
AsciiArtLetters["w"] += "__      __\n"
AsciiArtLetters["w"] += "\\ \\ /\\ / /\n"
AsciiArtLetters["w"] += " \\ V  V / \n"
AsciiArtLetters["w"] += "  \\_/\\_/  \n"
AsciiArtLetters["w"] += "          \n"
AsciiArtLetters["w"] += "          \n"

AsciiArtLetters["x"] += "      \n"
AsciiArtLetters["x"] += "      \n"
AsciiArtLetters["x"] += "__  __\n"
AsciiArtLetters["x"] += "\\ \\/ /\n"
AsciiArtLetters["x"] += " >  < \n"
AsciiArtLetters["x"] += "/_/\\_\\ \n"
AsciiArtLetters["x"] += "      \n"
AsciiArtLetters["x"] += "      \n"

AsciiArtLetters["y"] += "       \n"
AsciiArtLetters["y"] += "       \n"
AsciiArtLetters["y"] += " _   _ \n"
AsciiArtLetters["y"] += "| | | |\n"
AsciiArtLetters["y"] += "| |_| |\n"
AsciiArtLetters["y"] += " \\__, |\n"
AsciiArtLetters["y"] += "  __/ |\n"
AsciiArtLetters["y"] += " |___/ \n"

AsciiArtLetters["z"] += "     \n"
AsciiArtLetters["z"] += "     \n"
AsciiArtLetters["z"] += " ____\n"
AsciiArtLetters["z"] += "|_  /\n"
AsciiArtLetters["z"] += " / / \n"
AsciiArtLetters["z"] += "/___|\n"
AsciiArtLetters["z"] += "     \n"
AsciiArtLetters["z"] += "     \n"

AsciiArtLetters["0"] += "  ___  \n"
AsciiArtLetters["0"] += " / _ \\ \n"
AsciiArtLetters["0"] += "| | | |\n"
AsciiArtLetters["0"] += "| | | |\n"
AsciiArtLetters["0"] += "| |_| |\n"
AsciiArtLetters["0"] += " \\___/ \n"
AsciiArtLetters["0"] += "       \n"
AsciiArtLetters["0"] += "       \n"

AsciiArtLetters["1"] += " __ \n"
AsciiArtLetters["1"] += "/_ |\n"
AsciiArtLetters["1"] += " | |\n"
AsciiArtLetters["1"] += " | |\n"
AsciiArtLetters["1"] += " | |\n"
AsciiArtLetters["1"] += " |_|\n"
AsciiArtLetters["1"] += "    \n"
AsciiArtLetters["1"] += "    \n"

AsciiArtLetters["2"] += " ___  \n"
AsciiArtLetters["2"] += "|__ \\ \n"
AsciiArtLetters["2"] += "   ) |\n"
AsciiArtLetters["2"] += "  / / \n"
AsciiArtLetters["2"] += " / /_ \n"
AsciiArtLetters["2"] += "|____|\n"
AsciiArtLetters["2"] += "      \n"
AsciiArtLetters["2"] += "      \n"

AsciiArtLetters["3"] += " ____  \n"
AsciiArtLetters["3"] += "|___ \\ \n"
AsciiArtLetters["3"] += "  __) |\n"
AsciiArtLetters["3"] += " |__ < \n"
AsciiArtLetters["3"] += " ___) |\n"
AsciiArtLetters["3"] += "|____/ \n"
AsciiArtLetters["3"] += "       \n"
AsciiArtLetters["3"] += "       \n"

AsciiArtLetters["4"] += " _  _   \n"
AsciiArtLetters["4"] += "| || |  \n"
AsciiArtLetters["4"] += "| || |_ \n"
AsciiArtLetters["4"] += "|__   _|\n"
AsciiArtLetters["4"] += "   | |  \n"
AsciiArtLetters["4"] += "   |_|  \n"
AsciiArtLetters["4"] += "        \n"
AsciiArtLetters["4"] += "        \n"

AsciiArtLetters["5"] += " _____ \n"
AsciiArtLetters["5"] += "| ____|\n"
AsciiArtLetters["5"] += "| |__  \n"
AsciiArtLetters["5"] += "|___ \\ \n"
AsciiArtLetters["5"] += " ___) |\n"
AsciiArtLetters["5"] += "|____/ \n"
AsciiArtLetters["5"] += "       \n"
AsciiArtLetters["5"] += "       \n"

AsciiArtLetters["6"] += "   __  \n"
AsciiArtLetters["6"] += "  / /  \n"
AsciiArtLetters["6"] += " / /_  \n"
AsciiArtLetters["6"] += "| '_ \\ \n"
AsciiArtLetters["6"] += "| (_) |\n"
AsciiArtLetters["6"] += " \\___/ \n"
AsciiArtLetters["6"] += "       \n"
AsciiArtLetters["6"] += "       \n"

AsciiArtLetters["7"] += " ______ \n"
AsciiArtLetters["7"] += "|____  |\n"
AsciiArtLetters["7"] += "    / / \n"
AsciiArtLetters["7"] += "   / /  \n"
AsciiArtLetters["7"] += "  / /   \n"
AsciiArtLetters["7"] += " /_/    \n"
AsciiArtLetters["7"] += "        \n"
AsciiArtLetters["7"] += "        \n"

AsciiArtLetters["8"] += "  ___  \n"
AsciiArtLetters["8"] += " / _ \\ \n"
AsciiArtLetters["8"] += "| (_) |\n"
AsciiArtLetters["8"] += " > _ < \n"
AsciiArtLetters["8"] += "| (_) |\n"
AsciiArtLetters["8"] += " \\___/ \n"
AsciiArtLetters["8"] += "       \n"
AsciiArtLetters["8"] += "       \n"

AsciiArtLetters["9"] += "  ___  \n"
AsciiArtLetters["9"] += " / _ \\ \n"
AsciiArtLetters["9"] += "| (_) |\n"
AsciiArtLetters["9"] += " \\__, |\n"
AsciiArtLetters["9"] += "   / / \n"
AsciiArtLetters["9"] += "  /_/  \n"
AsciiArtLetters["9"] += "       \n"
AsciiArtLetters["9"] += "       \n"

AsciiArtLetters["."] += "   \n"
AsciiArtLetters["."] += "   \n"
AsciiArtLetters["."] += "   \n"
AsciiArtLetters["."] += "   \n"
AsciiArtLetters["."] += " _ \n"
AsciiArtLetters["."] += "(_)\n"
AsciiArtLetters["."] += "   \n"
AsciiArtLetters["."] += "   \n"

AsciiArtLetters[","] += "    \n"
AsciiArtLetters[","] += "    \n"
AsciiArtLetters[","] += "    \n"
AsciiArtLetters[","] += "    \n"
AsciiArtLetters[","] += "  _ \n"
AsciiArtLetters[","] += " ( )\n"
AsciiArtLetters[","] += " |/ \n"
AsciiArtLetters[","] += "    \n"

AsciiArtLetters["-"] += "       \n"
AsciiArtLetters["-"] += "       \n"
AsciiArtLetters["-"] += "       \n"
AsciiArtLetters["-"] += "  ____ \n"
AsciiArtLetters["-"] += " |____|\n"
AsciiArtLetters["-"] += "       \n"
AsciiArtLetters["-"] += "       \n"
AsciiArtLetters["-"] += "       \n"

AsciiArtLetters["+"] += "        \n"
AsciiArtLetters["+"] += "    _   \n"
AsciiArtLetters["+"] += "  _| |_ \n"
AsciiArtLetters["+"] += " |_   _|\n"
AsciiArtLetters["+"] += "   |_|  \n"
AsciiArtLetters["+"] += "        \n"
AsciiArtLetters["+"] += "        \n"
AsciiArtLetters["+"] += "        \n"

AsciiArtLetters["!"] += "  _ \n"
AsciiArtLetters["!"] += " | |\n"
AsciiArtLetters["!"] += " | |\n"
AsciiArtLetters["!"] += " | |\n"
AsciiArtLetters["!"] += " |_|\n"
AsciiArtLetters["!"] += " (_)\n"
AsciiArtLetters["!"] += "    \n"
AsciiArtLetters["!"] += "    \n"

AsciiArtLetters["?"] += "  ___  \n"
AsciiArtLetters["?"] += " |__ \\ \n"
AsciiArtLetters["?"] += "    ) |\n"
AsciiArtLetters["?"] += "   / / \n"
AsciiArtLetters["?"] += "  |_|  \n"
AsciiArtLetters["?"] += "  (_)  \n"
AsciiArtLetters["?"] += "       \n"
AsciiArtLetters["?"] += "       \n"

AsciiArtLetters[" "] += "   \n"

terminal.addCommand("letters", function(args) {
    let text = args.text.trim().toLowerCase()

    if (!text)
        throw new Error("No text given")

    for (let char of text) {
        if (!(char in AsciiArtLetters)) {
            throw new Error("Unsupported character used ('" + char + "')")
        }
    }

    function pasteHorizontal(a, b, l1, l2) {
        let lines = {a: a.split("\n").slice(0, -1), b: b.split("\n").slice(0, -1)}
        let width = {a: () => lines.a[0].length, b: () => lines.b[0].length}
        let height = {a: () => lines.a.length, b: () => lines.b.length}
        
        while (height.a() > height.b()) {
            lines.b.unshift(stringMul(" ", width.b()))
        }
        while (height.b() > height.a()) {
            lines.a.unshift(stringMul(" ", width.a()))
        }

        function eq(a, b) {
            if (a == b) return true
            if (a == " " || b == " ") return true
            if (a == "(" && b == "|") return true
            if (a == ")" && b == "|") return true
            if (b == "(" && a == "|") return true
            if (b == ")" && a == "|") return true
            return false
        }

        if (l1 != " " && l2 != " ")
        for (let i = 0; i < 2; i++) {
            let compressBoth = true
            for (let i = 0; i < height.a(); i++) {
                let [x, y] = [lines.a[i].slice(-1), lines.b[i][0]]
                if (!(eq(x, y))) {
                    compressBoth = false
                    break
                }
            }

            if (!compressBoth)
                break

            for (let i = 0; i < height.a(); i++) {
                let [x, y] = [lines.a[i].slice(-1), lines.b[i][0]]
                if (x == " ")
                    lines.a[i] = lines.a[i].slice(0, -1) + y
                lines.b[i] = lines.b[i].slice(1)
            }
        }

        let combined = ""
        for (let i = 0; i < height.a(); i++)
            combined += lines.a[i] + lines.b[i] + "\n"
        return combined
    }

    let output = AsciiArtLetters[text[0]]
    for (let i = 1; i < text.length; i++) {
        output = pasteHorizontal(output, AsciiArtLetters[text[i]], text[i - 1], text[i])
    }
    terminal.printLine(output)
}, {
    description: "prints the given text in ascii art",
    args: {
        "*text": "the text to print"
    },
    example: "letters hello world"
})



// ------------------- js/commands/live-quiz.js --------------------
terminal.addCommand("live-quiz", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../quiz/",
        name: "Live Quiz Game",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "a simple quiz game that uses your camera as input for your answer",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/live-rocket.js --------------------
terminal.addCommand("live-rocket", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../sport/",
        name: "Live Rocket Avoid Game",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "a simple avoid game that you steer using camera input",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/logistic-map.js --------------------
terminal.addCommand("logistic-map", async function(args) {
    const maxIterations = 100
    const startValue = 0.5
    const minR = args.min
    const maxR = args.max

    const Vector2d = (await terminal.modules.load("game", terminal)).Vector2d

    if (minR >= maxR) {
        throw new Error("max value must be greater than min value")
    }

    if (maxR - minR < 0.5) {
        throw new Error("span of values too small to plot")
    }
    
    const fieldSize = new Vector2d(args.w, args.h)

    let field = Array.from(Array(fieldSize.y), () => Array.from(Array(fieldSize.x), () => " "))

    function drawNumberLines() {
        for (let x = 0; x < 5; x++) {
            let xPos = Math.floor((x - minR) / (maxR - minR) * fieldSize.x)
            for (let y = 0; y < fieldSize.y; y++) {
                if (xPos < 0 || xPos >= fieldSize.x) continue
                field[y][xPos] = String(x)
            }
        }
    }

    function test(r) {
        let currVal = startValue
        for (let i = 0; i < maxIterations; i++) {
            currVal = r * currVal * (1 - currVal)
        }
        let findings = new Set()
        for (let i = 0; i < maxIterations; i++) {
            currVal = r * currVal * (1 - currVal)
            let rounded = Math.round(currVal * 10000) / 10000
            findings.add(rounded)
        }
        return Array.from(findings)
    }

    let ys = []
    for (let x = 0; x < fieldSize.x; x++) {
        let xVal = (x / fieldSize.x) * (maxR - minR) + minR
        ys.push(test(xVal))
    }

    let maxY = Math.max(...ys.flat()) + 0.1
    for (let x = 0; x < fieldSize.x; x++) {
        for (let yVal of ys[x]) {
            let y = Math.floor(yVal / maxY * fieldSize.y)
            let mirroredY = fieldSize.y - y - 1
            if (mirroredY < 0 || mirroredY >= fieldSize.y) continue
            field[mirroredY][x] = "#"
        }
    }

    for (let y = 0; y < field.length; y++) {
        let rowString = ""
        for (let x = 0; x < field[y].length; x++) {
            rowString += field[y][x]
        }
        terminal.printLine(rowString)
    }

}, {
    description: "draw the logistic map",
    args: {
        "?min:n:-2~4": "minimum R value",
        "?max:n:-2~4": "maximum R value",
        "?w:n:10~200": "width of display",
        "?h:n:5~100": "height of display"
    },
    standardVals: {
        min: 0,
        max: 4,
        w: 80,
        h: 20
    },
})



// ------------------- js/commands/longjump.js --------------------
terminal.addCommand("longjump", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    terminal.printLine("Loading Highscores...")

    let allHighscores = []
    try {
        allHighscores = await HighscoreApi.getHighscores("longjump")
    } catch (e) {
        terminal.log("Failed to load highscores.")
    }

    let turtloImage = new Image()
    turtloImage.src = terminal.baseUrl + "res/img/turtlo/walking-0.png"
    await new Promise((resolve) => {
        turtloImage.onload = resolve
    })

    let turtloImageLanded = new Image()
    turtloImageLanded.src = terminal.baseUrl + "res/img/turtlo/hidden.png"
    await new Promise((resolve) => {
        turtloImageLanded.onload = resolve
    })

    let terminalWindow = terminal.modules.window.make({
        name: "LongJump", fullscreen: args.fullscreen
    })

    let canvas = terminalWindow.CANVAS
    let context = terminalWindow.CONTEXT

    let viewOffset = new Vector2d(0, 0)
    let desiredOffset = new Vector2d(0, 0)
    let groundHeight = 0.8

    let touchModeActive = false

    function posToScreenPos(pos) {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2

        return pos
            .add(viewOffset)
            .scale(meterScaleFactor)
            .add(new Vector2d(canvas.width / 2, canvas.height / 2))
    }

    function drawRect(position, size, color="white") {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2

        let drawPosition = posToScreenPos(position)
        context.fillStyle = color
        size = size.scale(meterScaleFactor)
        context.fillRect(drawPosition.x, drawPosition.y, size.x, size.y)
    }

    function drawLine(position1, position2, {
        color="white", width=0.01
    }={}) {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2
        let drawPosition1 = posToScreenPos(position1)
        let drawPosition2 = posToScreenPos(position2)
        context.strokeStyle = color
        context.lineWidth = width * meterScaleFactor
        context.beginPath()
        context.moveTo(drawPosition1.x, drawPosition1.y)
        context.lineTo(drawPosition2.x, drawPosition2.y)
        context.stroke()
    }

    function drawText(position, text, {
        color="white", size=0.1, align="center", baseline="middle", bold=false, rotation=0
    }={}) {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2
        let drawPosition = posToScreenPos(position)
        context.save()
        context.translate(drawPosition.x, drawPosition.y)
        context.rotate(rotation)
        context.fillStyle = color
        context.font = `${bold ? "bold " : ""}${size * meterScaleFactor}px sans-serif`
        context.textAlign = align
        context.textBaseline = baseline
        context.fillText(text, 0, 0)
        context.restore()
    }

    function drawCircle(position, radius, color="white") {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2
        let drawPosition = posToScreenPos(position)
        context.fillStyle = color
        context.beginPath()
        context.arc(drawPosition.x, drawPosition.y, radius * meterScaleFactor, 0, Math.PI * 2)
        context.fill()
    }

    function drawCloud(position, color) {
        let random = mulberry32(Math.floor(position.x * 1000 + position.y * 1000))

        drawCircle(position, 0.1, color)
        for (let i = 0; i < 10; i++) {
            let angle = random() * Math.PI * 2
            let offset = new Vector2d(
                Math.sin(angle) * 0.15,
                Math.cos(angle) * 0.05
            )
            drawCircle(position.add(offset), 0.1, color)
        }
    }

    function drawImage(position, size, image, rotation=0) {
        let meterScaleFactor = Math.min(canvas.width, canvas.height) / 2
        let drawPosition = posToScreenPos(position)
        context.save()
        context.translate(drawPosition.x, drawPosition.y)
        context.rotate(rotation)
        let sizeX = size * meterScaleFactor
        let sizeY = (size * image.height / image.width) * meterScaleFactor
        context.imageSmoothingEnabled = false
        context.drawImage(
            image,
            -sizeX / 2,
            -sizeY / 2,
            sizeX,
            sizeY
        )
        context.restore()
    }

    function updateViewOffset() {
        let diff = desiredOffset.sub(viewOffset)
        viewOffset = viewOffset.add(diff.scale(zoomSpeed))
    }

    let zoomSpeed = 0.1
    const gravityConstant = 0.0003
    const jumpEfficiency = 0.4

    class Player {

        constructor() {
            this.size = 0.2
            this.position = new Vector2d(0, 0)
            this.velocity = new Vector2d(0, 0)

            this.isSwinging = true
            this.swingAmplitude = 0.5
            this.swingLengthMs = 2000
            this.landed = false
            this._lastPosition = null

            this.spawnTime = Date.now()
        }

        get canJump() {
            if (this.isSwinging) {
                let msSinceSpawn = Date.now() - this.spawnTime
                if (msSinceSpawn > 1000) {
                    return true
                }
            }
            return false
        }

        get lastPosition() {
            if (!this._lastPosition) return this.position
            return this._lastPosition
        }

        jump() {
            this.isSwinging = false

            let swingPosX = Date.now() / this.swingLengthMs % 1
            swingPosX = Math.cos(swingPosX * Math.PI * 2) * 0.7
            let speed = Math.abs(swingPosX)

            function gaussianRandom(mean=0, stdev=1) {
                const u = 1 - Math.random()
                const v = Math.random()
                const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v )
                return z * stdev + mean
            }

            let randomFactor = gaussianRandom(1, 0.05)

            this.velocity = this.position.sub(this.lastPosition).normalized.scale(0.1 * speed * randomFactor)
            zoomSpeed = 0.1
        }

        _drawBody() {
            drawImage(
                this.position,
                this.size,
                this.landed ? turtloImageLanded : turtloImage,
                this.angle + Math.PI / 2 * 3
            )
        }

        get angle() {
            if (!this.lastPosition) return 0
            if (this.landed) return Math.PI / 2 * 3
            return this.position.angleTo(this.lastPosition)
        }

        _drawScore() {
            drawText(
                new Vector2d(this.position.x, -0.1),
                `Your Score: ${this.score}`,
                {bold: true, color: "yellow"}
            )
            drawText(
                new Vector2d(this.position.x, 0.03),
                touchModeActive ? `Tap to restart` : `Press Space to play again`,
                {color: "yellow"}
            )
            drawText(
                new Vector2d(this.position.x, 0.14),
                touchModeActive ? `Swipe to upload score` : `Press Enter to upload your score`,
                {color: "yellow"}
            )
        }

        update() {
            this._lastPosition = this.position

            if (this.isSwinging) {
                let swingPosX = Date.now() / this.swingLengthMs % 1
                swingPosX = Math.sin(swingPosX * Math.PI * 2) * 0.7

                const posFromX = (x) => {
                    return new Vector2d(
                        Math.sin(x * Math.PI) * this.swingAmplitude,
                        Math.cos(x * Math.PI) * this.swingAmplitude
                    )
                }

                this.position = posFromX(swingPosX)
                particles.push(new FlyParticle(this.position))
            } else if (!this.landed) {
                this.velocity.iadd(new Vector2d(0, gravityConstant))
                this.position = this.position.add(this.velocity)

                if (this.position.y > groundHeight) {
                    this.velocity = new Vector2d(this.velocity.x, -this.velocity.y).scale(jumpEfficiency)
                    this.position = new Vector2d(this.position.x, groundHeight)
                    spawnExplosion(this.position.add(new Vector2d(0, -0.01)), this.velocity.length * 20)
                }

                if (this.velocity.length < 0.001 && Math.abs(this.position.y - groundHeight) < 0.01) {
                    this.landed = true
                    zoomSpeed = 0.03
                }

                particles.push(new FlyParticle(this.position))
            }
        }

        draw() {
            if (this.isSwinging) {
                drawLine(this.position, new Vector2d(0, 0))
                this._drawBody()
            } else if (!this.landed) {
                desiredOffset = this.position.scale(-1)
                this._drawBody()
            } else {
                desiredOffset = this.position.scale(-1).add(new Vector2d(0, 0.6))
                this._drawBody()
                this._drawScore()
            }
        }

        get score() {
            return Math.ceil(this.position.x * 10)
        }

    }

    class Particle {

        constructor(position) {
            this.color = [
                "#90ed68",
                "#7ae34d",
                "#4e9131"
            ][Math.floor(Math.random() * 3)]
            this.position = position
            let sizeFactor = Math.random() * 0.02 + 0.01
            this.size = new Vector2d(sizeFactor, sizeFactor)
            this.velocity = new Vector2d(Math.random() - 0.5, Math.random() - 0.5).scale(0.005)
            this.readyToDie = false
        }

        get volume() {
            return this.size.x * this.size.y
        }

        update() {
            this.velocity.iadd(new Vector2d(0, gravityConstant * this.volume * 1000).scale(3))
            this.position.iadd(this.velocity)
            if (this.position.y > groundHeight) {
                this.readyToDie = true
            }
        }

        draw() {
            if (this.readyToDie) return
            drawRect(this.position.add(this.size.scale(-0.5)), this.size, this.color)
        }

    }

    class FlyParticle extends Particle {

        constructor(position) {
            super(position)
            this.velocity = new Vector2d(0, 0)
            this.color = "#90ed68"
            this.originalSize = 0.03
            this.originalDieCounter = 25
            this.size = new Vector2d(this.originalSize, this.originalSize)
            this.dieCounter = this.originalDieCounter
        }

        update() {
            this.dieCounter--
            if (this.dieCounter < 0) {
                this.readyToDie = true
            }

            let sizeDecrease = -1 / this.originalDieCounter * this.originalSize
            this.size.iadd(new Vector2d(sizeDecrease, sizeDecrease))
        }

    }

    function spawnExplosion(position, strength=1) {
        for (let i = 0; i < strength * 100; i++) {
            let particle = new Particle(position.copy())
            particle.velocity = Vector2d.fromAngle(Math.PI / -2 - 0.5 + Math.random()).scale(0.007)
            particles.push(particle)
        }
    }

    let running = true
    let player = new Player()
    let particles = []
    let randomSeed = Math.floor(Math.random() * 1000000)
    let selectedUpload = false

    const groundStartX = -20
    const groundWidth = 60

    function drawParticles() {
        for (let particle of particles) {
            particle.draw()
        }
        particles = particles.filter(p => !p.readyToDie)
    }

    function updateParticles() {
        for (let particle of particles) {
            particle.update()
        }
    }

    function drawGround() {
        drawRect(
            new Vector2d(groundStartX, groundHeight),
            new Vector2d(groundWidth, 10),
        )

        let randomGrassHeight = mulberry32(randomSeed + 100)
        for (let x = groundStartX; x < groundStartX + groundWidth;) {
            let grassHeight = randomGrassHeight() * 0.07 + 0.03
            drawLine(
                new Vector2d(x, groundHeight - grassHeight),
                new Vector2d(x, groundHeight),
                {color: "#7ae34d"}
            )

            if (randomGrassHeight() < 0.05) {
                // draw flower
                drawRect(
                    new Vector2d(x - 0.015, groundHeight - grassHeight - 0.015),
                    new Vector2d(0.03, 0.03),
                    [
                        "#ff0000",
                        "#ff00ff",
                        "#ffff00",
                        "#00ffff",
                        "#0000ff",
                        "#ff7f00"
                    ][Math.floor(randomGrassHeight() * 6)]
                )
            }

            x += randomGrassHeight() * 0.03 + 0.01
        }

        for (let x = groundStartX; x < groundStartX + groundWidth; x += 1) {
            drawText(
                new Vector2d(x, groundHeight + 0.1),
                `${x * 10}m`,
                {
                    color: "black"
                }
            )
        }

        let prevScore = -1
        for (let highscore of allHighscores) {
            if (highscore.score === prevScore) continue

            let x = highscore.score / 10
            drawText(
                new Vector2d(x, groundHeight + 0.15),
                `- ${highscore.name} (${highscore.score}m)`,
                {
                    color: "black",
                    rotation: Math.PI / 2,
                    size: 0.05,
                    align: "left"
                }
            )
            prevScore = highscore.score
        }
    }

    function drawSky() {
        let random = mulberry32(randomSeed)
        for (let x = groundStartX; x < groundStartX + groundWidth;) {
            x += random() * 2 + 1
            let cloudPosY = random() * -3
            drawCloud(new Vector2d(x, cloudPosY), "rgba(255, 255, 255, 0.5)")
        }
    }

    function drawSwing() {
        drawLine(new Vector2d(0, 0), new Vector2d(0.4, groundHeight + 0.1), {
            width: 0.02
        })

        drawLine(new Vector2d(0, 0), new Vector2d(-0.4, groundHeight + 0.1), {
            width: 0.02
        })

        drawCircle(new Vector2d(0, 0), 0.03)

        drawText(new Vector2d(0, -0.7), "Press Space to jump", { color: "yellow", bold: true })
    }

    addEventListener("keydown", function(event) {
        if (!running) return

        if (event.key == " " && player.canJump) {
            player.isSwinging = false
            player.jump()
        }

        if (event.key == " " && player.landed) {
            player = new Player()
            zoomSpeed = 0.05
            desiredOffset = new Vector2d(0, 0)
        }

        if (event.key == "Enter" && player.landed) {
            selectedUpload = true
            running = false
        }
    })

    let touchStartPos = null

    addEventListener("touchstart", function(event) {
        if (!running) return

        let touch = event.touches[0] || event.changedTouches[0]
        touchStartPos = new Vector2d(
            touch.pageX,
            touch.pageY
        )

        touchModeActive = true

        if (player.canJump) {
            player.isSwinging = false
            player.jump()
        }
    })

    addEventListener("touchend", function(event) {
        if (touchStartPos == null || !player.landed) return

        let touch = event.touches[0] || event.changedTouches[0]
        let touchEndPos = new Vector2d(
            touch.pageX,
            touch.pageY
        )

        let delta = touchStartPos.sub(touchEndPos).length
        if (delta < 50) {
            if (player.landed) {
                player = new Player()
                zoomSpeed = 0.05
                desiredOffset = new Vector2d(0, 0)
            }
        } else {
            selectedUpload = true
            running = false
        }
    })

    function gameLoop() {
        context.clearRect(0, 0, canvas.width, canvas.height)

        drawSky()
        updateParticles()
        drawParticles()
        drawGround()
        drawSwing()
        player.update()
        player.draw()

        updateViewOffset()

        if (running) {
            requestAnimationFrame(gameLoop)
        }
    }

    gameLoop()

    terminal.onInterrupt(() => {
        running = false
        terminalWindow.close()
    })

    while (running) {
        await sleep(100)
    }

    terminalWindow.close()

    if (selectedUpload) {
        await HighscoreApi.registerProcess("longjump", {ask: false})
        await HighscoreApi.uploadScore(player.score)
    }
}, {
    description: "Play a game of longjump",
    isGame: true,
    args: {
        "?f=fullscreen:b": "Play in fullscreen"
    }
})

// ------------------- js/commands/lorem.js --------------------
const loremText = "Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Sed aliquam, nisi quis porttitor congue, elit erat euismod orci, ac placerat dolor lectus quis orci. Phasellus consectetuer vestibulum elit. Aenean tellus metus, bibendum sed, posuere ac, mattis non, nunc. Vestibulum fringilla pede sit amet augue. In turpis. Pellentesque posuere. Praesent turpis. Aenean posuere, tortor sed cursus feugiat, nunc augue blandit nunc, eu sollicitudin urna dolor sagittis lacus. Donec elit libero, sodales nec, volutpat a, suscipit non, turpis. Nullam sagittis. Suspendisse pulvinar, augue ac venenatis condimentum, sem libero volutpat nibh, nec pellentesque velit pede quis nunc. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Fusce id purus. Ut varius tincidunt libero. Phasellus dolor. Maecenas vestibulum mollis diam. Pellentesque ut neque. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. In dui magna, posuere eget, vestibulum et, tempor auctor, justo. In ac felis quis tortor malesuada pretium. Pellentesque auctor neque nec urna. Proin sapien ipsum, porta a, auctor quis, euismod ut, mi. Aenean viverra rhoncus pede. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Ut non enim eleifend felis pretium feugiat. Vivamus quis mi. Phasellus a est. Phasellus magna. In hac habitasse platea dictumst. Curabitur at lacus ac velit ornare lobortis. Curabitur a felis in nunc fringilla tristique. Morbi mattis ullamcorper velit. Phasellus gravida semper nisi. Nullam vel sem. Pellentesque libero tortor, tincidunt et, tincidunt eget, semper nec, quam. Sed hendrerit. Morbi ac felis. Nunc egestas, augue at pellentesque laoreet, felis eros vehicula leo, at malesuada velit leo quis pede. Donec interdum, metus et hendrerit aliquet, dolor diam sagittis ligula, eget egestas libero turpis vel mi. Nunc nulla. Fusce risus nisl, viverra et, tempor et, pretium in, sapien. Donec venenatis vulputate lorem. Morbi nec metus. Phasellus blandit leo ut odio. Maecenas ullamcorper, dui et placerat feugiat, eros pede varius nisi, condimentum viverra felis nunc et lorem. Sed magna purus, fermentum eu, tincidunt eu, varius ut, felis. In auctor lobortis lacus. Quisque libero metus, condimentum nec, tempor a, commodo mollis, magna. Vestibulum ullamcorper mauris at ligula. Fusce fermentum. Nullam cursus lacinia erat. Praesent blandit laoreet nibh. Fusce convallis metus id felis luctus adipiscing. Pellentesque egestas, neque sit amet convallis pulvinar, justo nulla eleifend augue, ac auctor orci leo non est. Quisque id mi. Ut tincidunt tincidunt erat. Etiam feugiat lorem non metus. Vestibulum dapibus nunc ac augue. Curabitur vestibulum aliquam leo. Praesent egestas neque eu enim. In hac habitasse platea dictumst. Fusce a quam. Etiam ut purus mattis mauris sodales aliquam. Curabitur nisi. Quisque malesuada placerat nisl. Nam ipsum risus, rutrum vitae, vestibulum eu, molestie vel, lacus. Sed augue ipsum, egestas nec, vestibulum et, malesuada adipiscing, dui. Vestibulum facilisis, purus nec pulvinar iaculis, ligula mi congue nunc, vitae euismod ligula urna in dolor. Mauris sollicitudin fermentum libero. Praesent nonummy mi in odio. Nunc interdum lacus sit amet orci. Vestibulum rutrum, mi nec elementum vehicula, eros quam gravida nisl, id fringilla neque ante vel mi. Morbi mollis tellus ac sapien. Phasellus volutpat, metus eget egestas mollis, lacus lacus blandit dui, id egestas quam mauris ut lacus. Fusce vel dui. Sed in libero ut nibh placerat accumsan. Proin faucibus arcu quis ante. In consectetuer turpis ut velit. Nulla sit amet est. Praesent metus tellus, elementum eu, semper a, adipiscing nec, purus. Cras risus ipsum, faucibus ut, ullamcorper id, varius ac, leo. Suspendisse feugiat. Suspendisse enim turpis, dictum sed, iaculis a, condimentum nec, nisi. Praesent nec nisl a purus blandit viverra. Praesent ac massa at ligula laoreet iaculis. Nulla neque dolor, sagittis eget, iaculis quis, molestie non, velit. Mauris turpis nunc, blandit et, volutpat molestie, porta ut, ligula. Fusce pharetra convallis urna. Quisque ut nisi. Donec mi odio, faucibus at, scelerisque quis, convallis in, nisi. Suspendisse non nisl sit amet velit hendrerit rutrum. Ut leo. Ut a nisl id ante tempus hendrerit. Proin pretium, leo ac pellentesque mollis, felis nunc ultrices eros, sed gravida augue augue mollis justo. Suspendisse eu ligula. Nulla facilisi. Donec id justo. Praesent porttitor, nulla vitae posuere iaculis, arcu nisl dignissim dolor, a pretium mi sem ut ipsum. Curabitur suscipit suscipit tellus. Praesent vestibulum dapibus nibh. Etiam iaculis nunc ac metus. Ut id nisl quis enim dignissim sagittis. Etiam sollicitudin, ipsum eu pulvinar rutrum, tellus ipsum laoreet sapien, quis venenatis ante odio sit amet eros. Proin magna. Duis vel nibh at velit scelerisque suscipit. Curabitur turpis. Vestibulum suscipit nulla quis orci. Fusce ac felis sit amet ligula pharetra condimentum. Maecenas egestas arcu quis ligula mattis placerat. Duis lobortis massa imperdiet quam. Suspendisse potenti. Pellentesque commodo eros a enim. Vestibulum turpis sem, aliquet eget, lobortis pellentesque, rutrum eu, nisl. Sed libero. Aliquam erat volutpat. Etiam vitae tortor. Morbi vestibulum volutpat enim. Aliquam eu nunc. Nunc sed turpis. Sed mollis, eros et ultrices tempus, mauris ipsum aliquam libero, non adipiscing dolor urna a orci. Nulla porta dolor. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos hymenaeos. Pellentesque dapibus hendrerit tortor. Praesent egestas tristique nibh. Sed a libero. Cras varius. Donec vitae orci sed dolor rutrum auctor. Fusce egestas elit eget lorem. Suspendisse nisl elit, rhoncus eget, elementum ac, condimentum eget, diam. Nam at tortor in tellus interdum sagittis. Aliquam lobortis. Donec orci lectus, aliquam ut, faucibus non, euismod id, nulla. Curabitur blandit mollis lacus. Nam adipiscing. Vestibulum eu odio. Vivamus laoreet. Nullam tincidunt adipiscing enim. Phasellus tempus. Proin viverra, ligula sit amet ultrices semper, ligula arcu tristique sapien, a accumsan nisi mauris ac eros. Fusce neque. Suspendisse faucibus, nunc et pellentesque egestas, lacus ante convallis tellus, vitae iaculis lacus elit id tortor. Vivamus aliquet elit ac nisl. Fusce fermentum odio nec arcu. Vivamus euismod mauris. In ut quam vitae odio lacinia tincidunt. Praesent ut ligula non mi varius sagittis. Cras sagittis. Praesent ac sem eget est egestas volutpat. Vivamus consectetuer hendrerit lacus. Cras non dolor. Vivamus in erat ut urna cursus vestibulum. Fusce commodo aliquam arcu. Nam commodo suscipit quam. Quisque id odio. Praesent venenatis metus at tortor pulvinar varius.Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis, sem. Nulla consequat massa quis enim. Donec pede justo, fringilla vel, aliquet nec, vulputate eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis vitae, justo. Nullam dictum felis eu pede mollis pretium. Integer tincidunt. Cras dapibus. Vivamus elementum semper nisi. Aenean vulputate eleifend tellus. Aenean leo ligula, porttitor eu, consequat vitae, eleifend ac, enim. Aliquam lorem ante, dapibus in, viverra quis, feugiat a, tellus. Phasellus viverra nulla ut metus varius laoreet. Quisque rutrum. Aenean imperdiet. Etiam ultricies nisi vel augue. Curabitur ullamcorper ultricies nisi. Nam eget dui. Etiam rhoncus. Maecenas tempus, tellus eget condimentum rhoncus, sem quam semper libero, sit amet adipiscing sem neque sed ipsum. Nam quam nunc, blandit vel, luctus pulvinar, hendrerit id, lorem. Maecenas nec odio et ante tincidunt tempus. Donec vitae sapien ut libero venenatis faucibus. Nullam quis ante. Etiam sit amet orci eget eros faucibus tincidunt. Duis leo. Sed fringilla mauris sit amet nibh. Donec sodales sagittis magna. Sed consequat, leo eget bibendum sodales, augue velit cursus nunc, quis gravida magna mi a libero. Fusce vulputate eleifend sapien. Vestibulum purus quam, scelerisque ut, mollis sed, nonummy id, metus. Nullam accumsan lorem in dui. Cras ultricies mi eu turpis hendrerit fringilla. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; In ac dui quis mi consectetuer lacinia. Nam pretium turpis et arcu. Duis arcu tortor, suscipit eget, imperdiet nec, imperdiet iaculis, ipsum. Sed aliquam ultrices mauris. Integer ante arcu, accumsan a, consectetuer eget, posuere ut, mauris. Praesent adipiscing. Phasellus ullamcorper ipsum rutrum nunc. Nunc nonummy metus. Vestibulum volutpat pretium libero. Cras id dui. Aenean ut eros et nisl sagittis vestibulum. Nullam nulla eros, ultricies sit amet, nonummy id, imperdiet feugiat, pede. Sed lectus. Donec mollis hendrerit risus. Phasellus nec sem in justo pellentesque facilisis. Etiam imperdiet imperdiet orci. Nunc nec neque. Phasellus leo dolor, tempus non, auctor et, hendrerit quis, nisi. Curabitur ligula sapien, tincidunt non, euismod vitae, posuere imperdiet, leo. Maecenas malesuada. Praesent congue erat at massa. Sed cursus turpis vitae tortor. Donec posuere vulputate arcu. Phasellus accumsan cursus velit. Vestibulum ante ipsum primis in"
const loremWords = loremText.split(" ")

terminal.addCommand("lorem", async function(args) {
    let wordCount = args.l
    if (wordCount < 1) {
        throw new Error("word count must be greater than 0")
    }

    let output = ""
    let copyOutput = ""
    let line = ""
    for (let i = 0; i < wordCount; i++) {
        line += loremWords[i % loremWords.length]
        if (i < wordCount - 1) {
            line += " "
        }

        if (line.length > 80) {
            output += line + "\n"
            copyOutput += line
            line = ""
        }
    }

    if (line.length > 0) {
        output += line
        copyOutput += line
    }

    terminal.printLine(output)

    if (args.c) {
        terminal.addLineBreak()
        await terminal.copy(output, {printMessage: true})
    }
}, {
    description: "generate lorem ipsum text",
    args: {
        "?l=length:i": "number of words to generate",
        "?c=copy:b": "copy to clipboard"
    },
    defaultValues: {
        l: 100
    }
})

// ------------------- js/commands/ls.js --------------------
terminal.addCommand("ls", function(args) {
    let targetFolder = terminal.getFile(args.folder || "", FileType.DIRECTORY)

    const CHARS = {
        LINE: "│",
        T: "├",
        L: "└",
        DASH: "─",
    }

    function listFolder(directory, indentation="") {
        let i = 0
        let printedL = false
        for (let file of directory.children) {
            i++
            if (indentation.length > 0) {
                terminal.print(indentation)
            }
            if (i == directory.children.length) {
                terminal.print(CHARS.L)
                printedL = true
            } else {
                terminal.print(CHARS.T)
            }
            terminal.print(CHARS.DASH.repeat(2) + " ")
            if (file.isDirectory) {
                terminal.printCommand(`${file.name}/`, `cd ${file.path}`)
                if (args.recursive) {
                    let indentAddition = `${CHARS.LINE}   `
                    if (printedL) {
                        indentAddition = "    "
                    }
                    listFolder(file, indentation + indentAddition)
                }
            } else {
                terminal.printLine(file.name)
            }
        }
    }

    listFolder(targetFolder)

    if (targetFolder.children.length == 0)
        terminal.printLine(`this directory is empty`)

}, {
    helpVisible: true,
    description: "list all files of current directory",
    args: {
        "?folder:f": "folder to list",
        "?r=recursive:b": "list recursively",
    },
    standardVals: {
        folder: ""
    }
})



// ------------------- js/commands/lscmds.js --------------------
terminal.addCommand("lscmds", async function(args) {
    let functions = [...terminal.visibleFunctions]
        .sort((a, b) => a.name.localeCompare(b.name))
        .sort((a, b) => a.name.length - b.name.length)
    if (args.m) {
        functions.sort((a, b) => a.name.localeCompare(b.name))
        let maxFuncLength = terminal.visibleFunctions.reduce((p, c) => Math.max(p, c.name.length), 0)
        const allDescriptions = functions.map(f => f.description ? f.description : "undefined")
        let maxDescLength = allDescriptions.reduce((p, c) => Math.max(p, c.length), 0)
        let text = ""
        for (let i = 0; i < functions.length; i++) {
            let func = functions[i]
            let description = allDescriptions[i]
            let funcPart = stringPadBack("\`" + func.name + "\`", maxFuncLength + 2)
            let descpart = stringPadBack(description, maxDescLength)
            text += `| ${funcPart} | ${descpart} |\n` 
        }
        terminal.printLine(text)
        await terminal.copy(text)
        terminal.printLine("Copied to Clipboard ✓")
        return
    }

    function createTableData(columns) {
        let columnHeight = Math.ceil(functions.length / columns)
        let tableData = Array.from({length: columnHeight}, () => Array.from({length: columns}, () => ""))
        let columnIndex = 0
        let functionIndex = 0
        while (true) {
            let func = functions[functionIndex]
            if (!func) break
            tableData[functionIndex % columnHeight][columnIndex] = func.name
            if (functionIndex % columnHeight == columnHeight - 1) columnIndex++
            functionIndex++
        }
        return tableData
    }

    function printTable(tableData) {
        let columnWidths = []
        for (let i = 0; i < tableData[0].length; i++) {
            let column = tableData.map(row => row[i])
            columnWidths.push(Math.max(...column.map(c => c === undefined ? 0 : c.length)))
        }

        for (let row of tableData) {
            for (let i = 0; i < row.length; i++) {
                let cell = row[i]
                let width = columnWidths[i]
                terminal.printCommand(stringPadBack(cell, width + 2), cell, undefined, false)
            }
            terminal.addLineBreak()
        }
    }

    function calculateTableWidth(tableData) {
        let columnWidths = []
        for (let i = 0; i < tableData[0].length; i++) {
            let column = tableData.map(row => row[i])
            columnWidths.push(Math.max(...column.map(c => c === undefined ? 0 : c.length)))
        }

        return columnWidths.reduce((p, c) => p + c + 2, 0)
    }

    for (let tableWidth = 20; tableWidth >= 1; tableWidth--) {
        let tableData = createTableData(tableWidth)

        let width = calculateTableWidth(tableData)

        if (width <= 90 || tableWidth == 1) {
            printTable(tableData)
            break
        }
    }

    terminal.addLineBreak()
    terminal.printLine(`- in total, ${terminal.functions.length} commands have been implemented`)
    terminal.print("- use ")
    terminal.printCommand("man", "man", undefined, false)
    terminal.printLine(" <cmd> to get more information about a command")
    terminal.print("- use ")
    terminal.printCommand("whatis *", "whatis *", undefined, false)
    terminal.printLine(" to see all commands including their description")

}, {
    description: "list all available commands",
    helpVisible: true,
    args: {
        "?m:b": "format output as markdown table"
    }
})



// ------------------- js/commands/lscpu.js --------------------
terminal.addCommand("lscpu", function() {
    const runs = 150000000
    const start = performance.now()
    for (let i = runs; i > 0; i--) {}
    const end = performance.now()
    const ms = end - start
    const cyclesPerRun = 2
    const speed = (runs / ms / 1000000) * cyclesPerRun
    const ghz = Math.round(speed * 10) / 10

    let vendor = "unknown"
    let renderer = "unknown"

    try {
        const canvas = document.createElement("canvas")
        const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl")
        if (gl) {
            const debugInfo = gl.getExtension("WEBGL_debug_renderer_info")
            vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
            renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
        } else {
            throw new Error()
        }
    } catch {
        terminal.printError("Couldn't access gpu info")
    }

    terminal.printTable([
        ["logical cpu cores", navigator.hardwareConcurrency],
        ["platform (guess)", navigator.platform],
        ["cpu clockspeed (guess)", `${ghz} ghz`],
        ["gpu vendor", vendor],
        ["gpu renderer", renderer]
    ])
}, {
    description: "get some helpful info about your cpu"         
})



// ------------------- js/commands/lunar-lander.js --------------------
terminal.window.secretShip = null
terminal.addCommand("lunar-lander", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({name: "Lunar Lander", fullscreen: args.f})
    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT
    const clearWindow = () => context.clearRect(0, 0, canvas.width, canvas.height)

    const KEY = {
        UP_ARROW: "ArrowUp",
        LEFT_ARROW: "ArrowLeft",
        RIGHT_ARROW: "ArrowRight",
        UP: "up",
        DOWN: "down",
    }

    let levelFuels = [1000, 800, 600, 400, 200, 100]

    function getLevelFuel(level) {
        return levelFuels[Math.min(level, levelFuels.length - 1)]
    }

    const startTime = Date.now()

    const gravityConstant = 0.00001
    const gravity = new Vector2d(0, gravityConstant)

    class KeyListener {

        constructor() {
            this.keys = {}
            this.onCtrlCCallback = null
            this.onTouchStartCallback = null
            this.onTouchMoveCallback = null
            this.onTouchEndCallback = null

            function pos(event) {
                let rect = canvas.getBoundingClientRect()
                return new Vector2d(event.clientX - rect.left, event.clientY - rect.top)
            }

            function addListener(evt, callback) {
                addEventListener(evt, event => {
                    if (!game.running) return
                    return callback(event)
                })
            }

            this.keyup = addListener("keyup", event => {
                this.keys[event.key] = false
            })

            this.keydown = addListener("keydown", event => {
                if (Object.values(KEY).includes(event.key))
                    event.preventDefault()

                this.keys[event.key] = true

                if (event.key == "c" && event.ctrlKey) {
                    if (this.onCtrlCCallback != null)
                        this.onCtrlCCallback(event)
                }
            })

            this.touchDown = addListener("touchstart", event => {
                if (this.onTouchStartCallback != null) {
                    this.onTouchStartCallback(event, pos(event.touches[0]))
                }
            })

            this.touchMove = addListener("touchmove", event => {
                if (this.onTouchMoveCallback != null) {
                    this.onTouchMoveCallback(event, pos(event.touches[0]))
                }
            })

            this.touchUp = addListener("touchend", event => {
                if (this.onTouchEndCallback != null) {
                    this.onTouchEndCallback(event)
                    event.preventDefault()
                }
            })

            this.onContextMenu = addListener("contextmenu", event => {
                event.preventDefault()
            })

            this.upRules = {}
            this.downRules = {}
        }

        onCtrlC(callback) {
            this.onCtrlCCallback = callback
        }

        onTouchStart(callback) {
            this.onTouchStartCallback = callback
        }

        onTouchMove(callback) {
            this.onTouchMoveCallback = callback
        }

        onTouchEnd(callback) {
            this.onTouchEndCallback = callback
        }

        remove() {
            removeEventListener("keyup", this.keyup)
            removeEventListener("keydown", this.keydown)
            removeEventListener("touchstart", this.touchDown)
            removeEventListener("touchmove", this.touchMove)
            removeEventListener("touchend", this.touchUp)
            removeEventListener("contextmenu", this.onContextMenu)
        }

        isDown(key) {
            return this.keys[key] === true
        }

        isUp(key) {
            return !this.keys[key]
        }

        addRule(key, callback, type=undefined) {
            type ??= KEY.DOWN
            if (type == KEY.DOWN) {
                this.downRules[key] = callback
            } else if (type == KEY.UP) {
                this.upRules[key] = callback
            }
        }

        runRules() {
            for (let key in this.downRules) {
                if (this.isDown(key)) {
                    this.downRules[key]()
                }
            }
            for (let key in this.upRules) {
                if (this.isUp(key)) {
                    this.upRules[key]()
                }
            }
        }

        clearRules() {
            this.downRules = {}
            this.upRules = {}
        }

    }

    class Particle {

        constructor(x, y, ms=1000, color=null, vel) {
            this.pos = new Vector2d(x, y)
            this.velocity = vel ?? new Vector2d(0, 0)
            this.size = 2
            this.prevPos = this.pos.copy()

            this.ms = ms
            this.startTime = Date.now()
            this.c = color ?? {r: 255, g: 255, b: 255}
        }

        get alive() {
            return Date.now() - this.startTime < this.ms
        }

        get color() {
            let alpha = 1 - (Date.now() - this.startTime) / this.ms
            return `rgba(${this.c.r}, ${this.c.g}, ${this.c.b}, ${alpha})`
        }

        get realPos() {
            return this.pos.mul(new Vector2d(canvas.width, canvas.height))
        }

        update(deltaTime, landscape) {
            this.velocity.iadd(gravity.scale(deltaTime))
            this.pos.iadd(this.velocity.scale(deltaTime)
                .div(new Vector2d(canvas.width / canvas.height, 1)))

            if (landscape.checkCollision(this.realPos)) {
                let newAngle = this.velocity.angle + Math.PI
                let surfaceNormal = landscape.getSurfaceNormal(this.pos)
                let angleDiff = surfaceNormal.angle - newAngle
                this.velocity = Vector2d.fromAngle(newAngle)
                    .scale(this.velocity.length)
                    .rotate(-angleDiff * 2)
            } else {
                this.prevPos = this.pos.copy()
            }

        }

        draw(zoomPos) {
            context.fillStyle = this.color
            let pos = zoomPos(this.pos)
            let zoom = 1 / zoomPos("getZoomFactor")
            let size = this.size * zoom
            context.fillRect(pos.x - size / 2, pos.y - size / 2, size, size)
        }

    }

    class Player {

        constructor() {
            this.pos = new Vector2d(0.5, 0.1)
            let startXVelocity = Math.random() * 0.003 - 0.0015
            this.velocity = new Vector2d(startXVelocity, 0)
            this.startSize = 15
            this.size = this.startSize
            this.fuel = getLevelFuel(0)
            
            this.rotationSpeed = 0.1
            this.rotation = 0

            this.score = 0
            this.currLevel = 0
            this.crashed = false
            this.particles = []

            this.thrustIncrease = 0.03
            this.thrust = 0
            this.thrustAcceleration = gravityConstant * 2

            this.hasLanded = false
        }

        reset() {
            this.hasLanded = false
            this.crashed = false
            this.pos = new Vector2d(0.5, 0.1)
            this.velocity = new Vector2d(0, 0)
            this.rotation = 0
        }

        get canLand() {
            let landingMaxSpeed = 4
            let landingMaxAngle = Math.PI / 8

            while (this.rotation < 0) this.rotation += Math.PI * 2
            while (this.rotation > Math.PI * 2) this.rotation -= Math.PI * 2
            let angle = (this.rotation > Math.PI) ? (this.rotation - Math.PI * 2) : (this.rotation)
            return this.speedY <= landingMaxSpeed && Math.abs(angle) < landingMaxAngle
        }

        get midPoint() {
            return this.pos.mul(new Vector2d(canvas.width, canvas.height))
        }

        calcScreenPos(zoomPos) {
            return zoomPos(this.pos)
        }

        get speedX() {
            return Math.round(Math.abs(this.velocity.x) * 10000)
        }

        get speedY() {
            return Math.round(Math.abs(this.velocity.y) * 10000)
        }

        get speed() {
            return Math.sqrt(this.speedX ** 2 + this.speedY ** 2)
        }

        get points() {
            let points = [
                new Vector2d(0, -this.size),
                new Vector2d(this.size, this.size),
                new Vector2d(0, this.size / 2),
                new Vector2d(-this.size, this.size)
            ]
            for (let point of points) {
                point.irotate(this.rotation)
                point.iadd(this.midPoint)
            }
            return points
        }

        crash() {
            if (this.crashed)
                return
            this.crashed = true
            this.crashTime = Date.now()
            for (let i = 0; i < args.particles * 100; i++) {
                let particle = new Particle(this.pos.x, this.pos.y, 3000)
                particle.velocity = Vector2d.random().scale((this.speed + 0.1) * 0.0005 * Math.random())
                this.particles.push(particle)
            }
        }

        spawnThrustParticles() {
            const spawnParticle = () => {
                let angleDiff = (Math.random() - 0.5) * 2 * (Math.PI / 20)
                let particleDirection = Vector2d.fromAngle(
                    this.rotation + Math.PI / 2 + angleDiff)
                const normalSpeed = 0.003
                let particleSpeed = (1 + Math.random()) * normalSpeed + this.velocity.length
                let particle = new Particle(
                    this.pos.x,
                    this.pos.y,
                    Math.random() * 4000, {r: 192, g: 105, b: 64},
                    particleDirection.scale(particleSpeed)
                )
                particle.size = 5
                this.particles.push(particle)
            }

            for (let i = 0; i < args.particles; i++)
                if (Math.random() < this.thrust)
                    spawnParticle()
        }

        update(deltaTime, landscape) {
            if (!this.crashed) {
                if (this.thrust > 0) {
                    let direction = Vector2d.fromAngle(this.rotation - Math.PI / 2)
                    if (this.fuel > 0)
                        this.velocity.iadd(direction
                            .scale(this.thrustAcceleration)
                            .scale(this.thrust))
                    else
                        this.thrust = 0
                    this.fuel = Math.max(this.fuel - this.thrust * deltaTime, 0)

                    this.spawnThrustParticles()
                }
    
                this.velocity.iadd(gravity.scale(deltaTime))
                this.pos.iadd(this.velocity.scale(deltaTime)
                    .div(new Vector2d(canvas.width / canvas.height, 1)))
            }

            for (let point of this.points) {
                if (landscape.checkPlatform(point) && this.canLand) {
                    this.velocity.x = 0
                    this.velocity.y = -0.003
                    this.hasLanded = true
                    this.score += 10
                    this.currLevel++
                    this.fuel += getLevelFuel(this.currLevel)
                    break
                }
                if (landscape.checkCollision(point)) {
                    this.crash()
                    break
                }
            }

            if (this.pos.x < 0) {
                this.pos.x = 0
                this.velocity.x *= -1
            } else if (this.pos.x > 1) {
                this.pos.x = 1
                this.velocity.x *= -1
            } else if (this.pos.y < 0) {
                this.pos.y = 0
                this.velocity.y *= -1
            }

            for (let particle of this.particles) {
                particle.update(deltaTime, landscape)
            }
            this.particles = this.particles.filter(particle => particle.alive)
        }

        draw(zoomPos) {
            function drawPoints(points, color, method) {
                context.fillStyle = color
                context.strokeStyle = color
                context.beginPath()
                context.moveTo(points[0].x, points[0].y)
                for (let i = 0; i < points.length; i++) {
                    let pos = zoomPos(new Vector2d(
                        points[i].x,
                        points[i].y
                    ), true)
                    if (i == 0) context.moveTo(pos.x, pos.y)
                    else context.lineTo(pos.x, pos.y)
                }
                context.closePath()
                context[method]()
            }

            for (let particle of this.particles) {
                particle.draw(zoomPos)
            }

            if (this.crashed)
                return
            drawPoints(this.points, "white", "fill")
        }

        get screenPos() {
            return this.pos.mul(new Vector2d(canvas.width, canvas.height))
        }

    }

    class Platform {

        constructor(xStart, width) {
            this.xStart = xStart
            this.width = width
            this.height = 50
        }

        get xEnd() {
            return this.xStart + this.width
        }

        get pos() {
            return game.landscape.platformPos
        }

        draw(zoomPos) {
            let xStart = zoomPos(new Vector2d(this.xStart, 0)).x
            let xEnd = zoomPos(new Vector2d(this.xEnd, 0)).x
            let y = zoomPos(this.pos.sub({x: 0, y: this.height}), true).y
            context.fillStyle = "white"

            let barWidth = (xEnd - xStart) * 0.1

            context.fillRect(xStart, y, xEnd - xStart, barWidth)

            // supports
            context.fillRect(xStart + 10, y+2, barWidth/2, 10000)
            context.fillRect(xEnd - 10 - barWidth/2, y+2, barWidth/2, 10000)
        }

    }

    class Landscape {

        generateData() {
            let funcs = []
            const random = () => Math.random()
            for (let i = 0; i < 50; i++) {
                let a = random() * 0.04
                let b = random() * 2
                let c = random() * 2 * Math.PI
                funcs.push((x) => a * Math.sin(b * x + c))
            }

            let data = []
            for (let x = 0; x < canvas.width; x++) {
                let y = 0
                let adjustedX = x / canvas.width * Math.PI * 4
                for (let func of funcs) {
                    let tempY = func(adjustedX)
                    y += tempY
                }
                data.push(y + 0.25)
            }
            return data
        }

        async generatePlatform() {
            let blendData = (xStart, xEnd, height, direction) => {
                for (let x = xStart; x < xEnd; x++) {
                    let xBlend = (x - xStart) / (xEnd - xStart)
                    let yBlend = (Math.sin(xBlend * Math.PI + Math.PI / 2) + 1) / 2
                    let heightDiff = height - this.data[x]
                    this.data[x] += heightDiff * (direction == -1 ? yBlend : 1 - yBlend)
                }
            }

            let xStart = Math.random() * 0.7 + 0.15
            let width = 100 / canvas.width
            let platform = new Platform(xStart, width)
            let platformHeight = Math.max(...this.data.slice(
                Math.floor(platform.xStart * this.data.length),
                Math.floor(platform.xEnd * this.data.length))) + 0.03
            let coordStart = Math.round(xStart * this.data.length)
            let coordEnd = Math.round(platform.xEnd * this.data.length)
            for (let x = coordStart; x < coordEnd; x++) {
                this.data[x] = platformHeight
            }

            let blendDistance = 100
            blendData(coordStart - blendDistance, coordStart, platformHeight, 1)
            blendData(coordEnd, coordEnd + blendDistance, platformHeight, -1)

            this.platform = platform
        }

        async generateValidData() {
            return new Promise(async resolve => {
                let data = this.generateData()
                let generationTries = 0
                while (this.maxAltitude(data) > 0.5 || this.minAltitude(data) < 0) {
                    generationTries++
                    data = this.generateData()
                    if (generationTries % 1 == 0)
                        await sleep(0)
                }
                resolve(data)
            })
        }

        generateSurfaceNormals() {
            let normals = []
            for (let i = 1; i < this.data.length; i++) {
                let diff = this.data[i] - this.data[i - 1]
                let angle = Math.atan(diff * canvas.height)
                normals.push(angle - Math.PI / 2)
            }
            return normals
        }

        async generate() {
            this.data = await this.generateValidData()
            await this.generatePlatform()
            this.surfaceNormals = this.generateSurfaceNormals()
            this.generating = false
        }

        get platformPos() {
            let x = this.platform.xStart * canvas.width + this.platform.width * canvas.width / 2
            let y = (1 - this.data[Math.floor(this.platform.xStart * this.data.length)]) * canvas.height
            return new Vector2d(x, y)
        }

        maxAltitude(data) {
            return Math.max(...(data ?? this.data))
        }

        minAltitude(data) {
            return Math.min(...(data ?? this.data))
        }

        constructor() {
            this.generating = true
            this.platform = null
            this.generate()
        }

        checkCollision(point) {
            let x = point.x / canvas.width * this.data.length
            let y = point.y / canvas.height
            let terrainHeight = 1 - this.data[Math.floor(x)]

            let relevantHeight = terrainHeight

            x /= this.data.length

            if (x > this.platform.xStart && x < this.platform.xEnd) {
                relevantHeight = (this.platform.pos.y - this.platform.height) / canvas.height
            }

            return y > relevantHeight
        }

        getSurfaceNormal(point) {
            let x = point.x * this.data.length
            let angle = this.surfaceNormals[Math.floor(x)]
            return Vector2d.fromAngle(angle)
        }

        checkPlatform(point) {
            let x = point.x / canvas.width
            let y = point.y / canvas.height
            let platform = this.platform
            return (
                x > platform.xStart &&
                x < platform.xEnd &&
                y > (platform.pos.y - platform.height) / canvas.height
            )
        }

        get platformHeight() {
            return this.data[Math.floor(this.platform.xStart * this.data.length)]
        }

        draw(zoomPos) {
            context.fillStyle = "white"
            context.beginPath()
            context.moveTo(0, canvas.height)
            for (let i = 0; i < this.data.length; i++) {
                let pos = zoomPos(new Vector2d(
                    i / this.data.length,
                    1 - this.data[i]
                ))
                context.lineTo(pos.x, pos.y)
            }
            context.lineTo(canvas.width, canvas.height)
            context.closePath()
            context.fill()
            if (this.platform)
                this.platform.draw(zoomPos)
        }

    }

    class Game {

        FPS = 30
        running = true

        get deltaMs() {
            return 1000 / this.FPS
        }

        registerKeyEvents() {
            this.keyListener.addRule(KEY.UP_ARROW, () => {
                this.player.thrust = Math.min(this.player.thrust + this.player.thrustIncrease, 1)
            }, KEY.DOWN)

            this.keyListener.addRule(KEY.LEFT_ARROW, () => {
                this.player.rotation -= this.player.rotationSpeed
            }, KEY.DOWN)

            this.keyListener.addRule(KEY.RIGHT_ARROW, () => {
                this.player.rotation += this.player.rotationSpeed
            }, KEY.DOWN)

            this.keyListener.addRule(KEY.UP_ARROW, () => {
                this.player.thrust = 0
            }, KEY.UP)

            this.keyListener.onTouchStart((event, pos) => {
                this.currTouchPos = pos
                this.touchEnabled = true
            })

            this.keyListener.onTouchMove((event, pos) => {
                this.currTouchPos = pos
                this.touchEnabled = true
            })

            this.keyListener.onTouchEnd(() => {
                this.currTouchPos = null
                this.touchEnabled = true
            })
        }

        runTouchHandling() {
            if (this.player.crashed) return

            if (this.currTouchPos == null) {
                this.player.thrust = 0
                return
            }

            this.player.thrust = Math.min(this.player.thrust + this.player.thrustIncrease, 1)

            let playerPos = this.player.calcScreenPos(this.makeZoomPos())
            let angle = playerPos.angleTo(this.currTouchPos)
            this.player.rotation = angle - Math.PI / 2
        }

        drawStats() {
            context.fillStyle = "white"
            context.font = "20px Arial bold"
            context.textAlign = "left"
            let heightPointer = 30
            function drawText(msg) {
                context.fillText(msg, 10, heightPointer)
                heightPointer += 20
            }
            drawText(`use arrow keys or touch`)
            drawText(`score: ${this.player.score}`)
            drawText(`speed: ${Math.round(this.player.speed * 10) / 10}`)
            drawText(`fuel: ${Math.round(this.player.fuel)}`)
        }
        
        constructor() {
            this.currTouchPos = null
            this.touchEnabled = false
            this.keyListener = new KeyListener()

            this.keyListener.onCtrlC(() => {
                this.running = false
                this.keyListener.remove()
                terminalWindow.close()
            })

            this.player = new Player()
            terminal.window.secretShip = this.player
            this.landscape = new Landscape()
            this.registerKeyEvents()

            this.zoom = 1

            this.endAnimationLength = 3000
            this.newLandscape = null
        }
        
        makeZoomPos() {
            let zoomFactor = 1 / this.zoom
            let xWidth = zoomFactor
            let yWidth = zoomFactor

            let platformXPos = this.landscape.platform.xStart + this.landscape.platform.width / 2
            let xStart = Math.min(Math.max(0, platformXPos - xWidth / 2), 1 - xWidth)
            let yStart = Math.min(Math.max(0,  this.landscape.platformHeight - yWidth / 2 + 0.1), 1 - yWidth)

            yStart = 1 - yWidth - yStart

            function zoomPos(pos, canvasPos=false) {
                if (pos == "getZoomFactor")
                    return zoomFactor
                if (canvasPos) {
                    pos = new Vector2d(
                        pos.x / canvas.width,
                        pos.y / canvas.height
                    )
                }
                return new Vector2d(
                    (pos.x - xStart) / xWidth * canvas.width,
                    (pos.y - yStart) / yWidth * canvas.height
                )
            }

            return zoomPos
        }

        async update(timeDelta) {
            this.player.update(timeDelta / this.deltaMs, this.landscape)

            let playerPlatformDistance = this.player.screenPos.distance(this.landscape.platformPos)
            let tempZoom = 1 / (playerPlatformDistance / canvas.width * 4)
            let targetZoom = Math.min(Math.max(tempZoom, 1), 2)
            let zoomDiff = targetZoom - this.zoom
            this.zoom += zoomDiff * 0.02

            if (this.player.hasLanded) {
                if (this.newLandscape == null) {
                    this.newLandscape = new Landscape()
                } else if (this.newLandscape.generating == false) {
                    this.player.reset()
                    for (let i = 0; i < this.landscape.data.length; i++) {
                        this.landscape.data[i] = this.newLandscape.data[i]
                        this.zoom += (1 - this.zoom) * 0.01
                        if (i % 5 == 0)
                            await sleep(0)
                    }
                    this.landscape = this.newLandscape
                    this.newLandscape = null
                }
            }
        }

        redraw() {
            clearWindow()

            let zoomPos = this.makeZoomPos()

            this.drawStats()
            this.player.draw(zoomPos)
            this.landscape.draw(zoomPos)
        }

        drawMessage(msg) {
            context.fillStyle = "white"
            context.font = "50px Arial bold"
            context.textAlign = "center"
            context.fillText(msg, canvas.width / 2, canvas.height / 2)
        }

        async run() {
            let prevTime = Date.now()

            while (this.landscape.generating) {
                this.drawMessage("Generating landscape...")
                await sleep(100)
            }

            while (this.running) {
                if (this.touchEnabled) {
                    this.runTouchHandling()
                } else {
                    this.keyListener.runRules()
                }

                let timeDelta = Date.now() - prevTime
                prevTime = Date.now()
                this.update(timeDelta)
                this.redraw()

                if (this.player.crashed) {
                    this.drawMessage("Game Over")

                    if (Date.now() - this.player.crashTime > this.endAnimationLength) {
                        this.running = false
                    }
                }

                await sleep(this.deltaMs)
            }

            this.keyListener.remove()
        }

    }
    let game = new Game()
    await game.run()
    
    while (args.f) { // fullscreen mode
		game = new Game()
		await game.run()
	}

    terminalWindow.close()

    terminal.printLine(`Your score: ${game.player.score}`)
    
    await HighscoreApi.registerProcess("lunar-lander")
    await HighscoreApi.uploadScore(game.player.score)
    
}, {
    description: "play a classic game of moon-lander",
    args: {
        "?particles:n:1~1000": "number of particles to generate",
        "?f=fullscreen:b": "enable fullscreen application"
    },
    standardVals: {
        particles: 10,
    },
    isGame: true,
})


// ------------------- js/commands/man.js --------------------
terminal.addCommand("man", async function(args) {
    if (!terminal.commandExists(args.command))
        throw new Error(`No manual entry for ${args.command}`)
    let command = await terminal.loadCommand(args.command)
    if (args.command == "man") {
        terminal.printEasterEgg("manmanEgg")
        terminal.addLineBreak()
    }

    let infoTableData = [
        ["name", command.name],
        ["author", command.author],
        ["description", command.description],
        ["is a game", command.info.isGame ? "yes" : "no"],
        ["is secret", command.info.isSecret ? "yes" : "no"]
    ]

    const hasArgs = (command.args.length === undefined)
        ? !!Object.keys(command.args).length
        : !!command.args.length

    if (!hasArgs) {
        infoTableData.push(["arguments", "doesn't accept any arguments"])
    }

    terminal.printTable(infoTableData)

    if (hasArgs) {
        let argTableData = []
        const {argOptions} = TerminalParser.parseArguments([], command)
        for (let arg of argOptions) {
            argTableData.push([
                arg.forms.join(", "), arg.optional ? "yes" : "no",
                arg.description, arg.type,
                arg.default || "/"
            ])
        }

        terminal.addLineBreak()
        terminal.printTable(argTableData, ["Argument", "Optional", "Description", "Type", "Default"])
    }
}, {
    description: "show the manual page for a command",
    args: {"command:c": "the command to show the manual page for"},
    helpVisible: true
})



// ------------------- js/commands/mandelbrot.js --------------------
terminal.addCommand("mandelbrot", async function(args) {
    let gridSize = {x: 0, y: 0}
    gridSize.x = ~~(terminal.approxWidthInChars)
    gridSize.y = ~~(gridSize.x * 1 / 3)
    if (args.x) gridSize.x = ~~args.x
    if (args.y) gridSize.y = ~~args.y
    if (gridSize.y % 2 == 1) gridSize.y++

    let plotSize = {xmin: -1.85, xmax: 0.47, ymin: -0.95, ymax: 0.95}
    let grid = Array.from(Array(gridSize.y)).map(() => Array(gridSize.x).fill(" "))

    let maxIteration = 1000

    function getPixelCoords(px, py) {
        let xDiff = plotSize.xmax - plotSize.xmin
        let x = plotSize.xmin + (px / gridSize.x) * xDiff
        let yDiff = plotSize.ymax - plotSize.ymin
        let y = plotSize.ymin + (py / gridSize.y) * yDiff
        return [x, y]
    }

    function calcPixel(px, py) {
        let [x0, y0] = getPixelCoords(px, py)
        let [x, y] = [0.0, 0.0]
        let i = 0
        for (; i < maxIteration; i++) {
            let temp = x**2 - y**2 + x0
            y = 2*x*y + y0
            x = temp
            if ((x**2 + y**2) >= 4)
                break
        }
        if (i == maxIteration)
            return "#"
        return "."
    }

    async function drawGrid() {
        let output = ""
        for (let y = 0; y < gridSize.y; y++) {
            for (let x = 0; x < gridSize.x; x++) {
                output += grid[y][x]
            }
            output += "\n"
        }
        terminal.printLine(output)
    }

    for (let y = 0; y < gridSize.y; y++) {
        for (let x = 0; x < gridSize.x; x++) {
            grid[y][x] = calcPixel(x, y)
        }
    }
    drawGrid()
}, {
    description: "draws the mandelbrot set",
    args: {
        "?x:i:10~1000": "width of the plot",
        "?y:i:10~1000": "height of the plot"
    }
})



// ------------------- js/commands/matdet.js --------------------
terminal.addCommand("matdet", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrix = null
    if (args.A) {
        matrix = Matrix.fromArray(args.A)
    } else {
        matrix = await inputMatrix(await inputMatrixDimensions({matrixName: "A", square: true}))
        terminal.addLineBreak()
    }

    terminal.printLine(matrix.determinant().simplify().toSimplifiedString())

}, {
    description: "find the determinant of a matrix",
    args: {
        "?A:sm": "square matrix",
    }
})

// ------------------- js/commands/mateig.js --------------------
terminal.addCommand("mateig", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrix = null
    if (args.A) {
        matrix = Matrix.fromArray(args.A)
    } else {
        const dimensions = await inputMatrixDimensions({matrixName: "A", square: true})
        matrix = await inputMatrix(dimensions)
        terminal.addLineBreak()
    }

    // helpful for debugging
    terminal.window.m = matrix

    function powerIteration(matrix, basis, iterations=1_000) {
        let v = Matrix.vector(Array.from({length: matrix.n}).map(Math.random))
        for (let i = 0; i < iterations; i++) {
            let w = matrix.multiply(v)

            // project w orthogonal to each u in basis
            for (let u of basis) {
                const coeff = (
                    u.transpose().multiply(w).getCell(0,0).value
                    / u.transpose().multiply(u).getCell(0,0).value
                )
                w = w.add(u.scale(-coeff));
            }

            // normalize
            v = w.scale(1 / w.norm())
        }
        return v
    }

    const eigenVectors = []

    for (let i = 0; i < matrix.n; i++) {
        // find largest (in absolute terms) eigenvector and eigenvalue
        let eigenVector = powerIteration(matrix, eigenVectors)
        eigenVectors.push(eigenVector)
        
        // compute eigenvalue
        const eigenValue = (
            eigenVector.transpose().multiply(matrix.multiply(eigenVector)).getCell(0, 0).value
            / eigenVector.transpose().multiply(eigenVector).getCell(0, 0).value
        )

        eigenVector = eigenVector.scale(1 / eigenVector.getCell(0, 0).value)

        terminal.printLine(new MatrixCell(eigenValue).toSimplifiedString(), Color.COLOR_1)
        terminal.printLine(eigenVector.transpose().toString())
        terminal.addLineBreak()
    }

    // const unitMatrix = Matrix.unit(matrix.n)
    // const charPoly = x => matrix.add(unitMatrix.scale(-x)).determinant()
    // for (let x = -10; x < 10; x++) {
    //     terminal.printLine(`${x} -> ${charPoly(x)}`)
    // }
}, {
    description: "find the eigenvalues and eigenspaces of a given matrix",
    args: {
        "?A:sm": "square matrix",
    },
    isSecret: true
})

// ------------------- js/commands/matinv.js --------------------
terminal.addCommand("matinv", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrix = null
    if (args.A) {
        matrix = Matrix.fromArray(args.A)
    } else {
        matrix = await inputMatrix(await inputMatrixDimensions({matrixName: "A", square: true}))
        terminal.addLineBreak()
    }

    terminal.printLine(matrix.inverse().simplify())
}, {
    description: "find the inverse of a matrix",
    args: {
        "?A:sm": "matrix to invert",
    }
})

// ------------------- js/commands/matmin.js --------------------
terminal.addCommand("matmin", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrix = null
    if (args.A) {
        matrix = Matrix.fromArray(args.A)
    } else {
        matrix = await inputMatrix(await inputMatrixDimensions({matrixName: "A", square: true}))
        terminal.addLineBreak()
    }

    terminal.printLine(matrix.minors().simplify())
}, {
    description: "find the matrix of minors of a given matrix",
    args: {
        "?A:sm": "matrix to find minors of",
    }
})

// ------------------- js/commands/matmul.js --------------------
terminal.addCommand("matmul", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrixA = null
    let matrixB = null

    if (args.A) {
        matrixA = Matrix.fromArray(args.A)
    } else {
        matrixA = await inputMatrix(await inputMatrixDimensions({matrixName: "A"}))
        terminal.addLineBreak()
    }

    if (args.B) {
        matrixB = Matrix.fromArray(args.B)
    } else {
        matrixB = await inputMatrix(await inputMatrixDimensions({
            matrixName: "B", forcedRows: matrixA.dimensions.columns
        }))
        terminal.addLineBreak()
    }

    if (matrixA.nCols != matrixB.nRows) {
        throw new Error("Matrix dimensions are not compatible.")
    }

    const matrixC = matrixA.multiply(matrixB).simplify()

    terminal.printLine(`Resulting Matrix [${matrixC.dimensions}]:`)
    terminal.printLine(matrixC.toString())

}, {
    description: "multiply two matrices with each other",
    args: {
        "?A:m": "matrix A",
        "?B:m": "matrix B",
    }
})

// ------------------- js/commands/matred.js --------------------
terminal.addCommand("matred", async function(args) {
    await terminal.modules.import("matrix", window)

    let matrix = null
    if (args.A) {
        matrix = Matrix.fromArray(args.A)
        terminal.printLine(matrix)
    } else {
        matrix = await inputMatrix(await inputMatrixDimensions({matrixName: "A"}))
        terminal.addLineBreak()
    }

    if (!matrix.containsOnlyNumbers()) {
        throw new Error("Matrix to reduce may not include variables")
    }

    let stepNum = 1

    const swapRows = (r1, r2) => {
        terminal.addLineBreak()
        matrix.swapRows(r1, r2)
        terminal.print(`#${stepNum}: `)
        terminal.printLine(`r${r1 + 1} <-> r${r2 + 1}`, Color.COLOR_1)
        terminal.printLine(matrix)
        stepNum++
    }

    const scaleRow = (row, scalar) => {
        terminal.addLineBreak()
        matrix.scaleRow(row, scalar)
        terminal.print(`#${stepNum}: `)
        terminal.printLine(`r${row + 1} * ${scalar.toSimplifiedString()}`, Color.COLOR_1)
        terminal.printLine(matrix)
        stepNum++
    }

    const addScalarRow = (r1, r2, scalar) => {
        terminal.addLineBreak()
        matrix.addScalarRow(r1, r2, scalar)

        let operation = "+"
        if (scalar.value < 0) {
            scalar = scalar.mul(-1)
            operation = "-"    
        }

        let scalarText = scalar.toSimplifiedString()
        if (scalarText == "1") {
            scalarText = ""
        } else {
            scalarText += "("
        }

        terminal.print(`#${stepNum}: `)
        terminal.printLine(`r${r2 + 1} ${operation} ${scalarText}r${r1 + 1}${scalarText.endsWith("(") ? ")" : ""}`, Color.COLOR_1)
        terminal.printLine(matrix)

        stepNum++
    }

    if (matrix.isZeroMatrix()) {
        throw new Error("Cannot row reduce matrix with no nonzero entry.")
    }

    function isReducedColumn(columnIndex, pivotRow) {
        const values = matrix.getColumn(columnIndex).map(c => c.value)

        let zeroEntries = 0
        let foundOne = false
        for (let i = 0; i < values.length; i++) {
            const value = values[i]
            if (value == 1) {
                if (i > pivotRow) {
                    return false
                }

                if (foundOne) {
                    return false
                } else {
                    foundOne = true
                }
            } else if (value == 0) {
                zeroEntries++
            } else {
                return false
            }
        }

        return zeroEntries == values.length - 1
    }

    function isZeroColumnFromRow(columnIndex, rowIndex) {
        for (let i = rowIndex; i < matrix.nRows; i++) {
            if (matrix.get(i, columnIndex) != 0) {
                return false
            }
        }
        return true
    }

    reduction_loop:
    for (let it = 0; it < 1000; it++) {
        let currColumn = 0
        let pivotRow = 0

        while (matrix.isZeroColumn(currColumn) || isReducedColumn(currColumn, pivotRow) || isZeroColumnFromRow(currColumn, pivotRow)) {
            if (isReducedColumn(currColumn, pivotRow)) {
                pivotRow++
            }

            currColumn++

            if (pivotRow >= matrix.nRows || currColumn >= matrix.nCols) {
                break reduction_loop
            }
        }

        // get first non-zero-row
        let beforePivot = pivotRow
        while (matrix.get(pivotRow, currColumn) == 0) {
            pivotRow++

            if (pivotRow >= matrix.nRows) {
                break reduction_loop
            }
        }

        if (pivotRow != beforePivot) {
            swapRows(beforePivot, pivotRow)
            continue
        }

        if (matrix.get(pivotRow, currColumn) != 1) {
            scaleRow(pivotRow, new MatrixCell(1).div(matrix.getCell(pivotRow, currColumn)))
            continue
        }

        for (let otherRow = 0; otherRow < matrix.nRows; otherRow++) {
            if (otherRow == pivotRow) continue

            if (matrix.get(otherRow, currColumn) != 0) {
                addScalarRow(pivotRow, otherRow, matrix.getCell(otherRow, currColumn).mul(-1))
                continue reduction_loop
            }
        }

        break
    }

    if (stepNum == 1) {
        terminal.printError("Matrix is already in reduced row echelon form.")
    }
}, {
    description: "reduce a given matrix to reduced row echelon form",
    args: {
        "?A:m": "matrix to reduce",
    }
})

// ------------------- js/commands/matvisualize.js --------------------
terminal.addCommand("matvisualize", async function(args) {
    await terminal.modules.import("matrix", window)
    await terminal.modules.import("game", window)

    let matrix = null
    if (args.matrix) {
        matrix = Matrix.fromArray(args.matrix)
    } else {
        matrix = await inputMatrix(new MatrixDimensions(2, 2))
        terminal.addLineBreak()
    }

    if (!matrix.containsOnlyNumbers()) {
        throw new Error("Matrix may not contain any variables")
    }

    if (matrix.nRows != 2 || matrix.nCols != 2) {
        throw new Error("Matrix must be 2x2")
    }

    function makeCanvas({widthChars=30}={}) {
        const container = document.createElement("div")
        container.style.position = "relative"

        const canvas = document.createElement("canvas")
        canvas.style.width = `calc(var(--font-size) * ${widthChars})`
        canvas.style.height = `calc(var(--font-size) * ${widthChars})`

        container.appendChild(canvas)
        terminal.parentNode.appendChild(container)
        canvas.width = canvas.clientWidth
        canvas.height = canvas.clientHeight

        return {canvas, container}
    }

    const {canvas, container} = makeCanvas()
    const context = canvas.getContext("2d")

    function makeCornerButton(text, {
        left = undefined,
        right = undefined,
        top = undefined,
        bottom = undefined
    }={}) {
        const button = document.createElement("button")
        button.textContent = text

        button.style.position = "absolute"
        if (left   !== undefined) button.style.left = left
        if (right  !== undefined) button.style.right = right
        if (top    !== undefined) button.style.top = top
        if (bottom !== undefined) button.style.bottom = bottom

        container.appendChild(button)
        return button
    }

    context.fillStyle = "blue"
    context.fillRect(20, 20, 50, 50)

    const zoomInButton = makeCornerButton("+", {left: 0, top: 0})
    const zoomOutButton = makeCornerButton("-", {left: "30px", top: 0})

    const slider = document.createElement("input")
    slider.type = "range"
    slider.value = 0
    slider.min = 0
    slider.max = 500

    slider.style.display = "block"
    slider.style.width = canvas.style.width
    terminal.parentNode.appendChild(slider)

    let viewCenter = new Vector2d(args.x, args.y)
    let zoomFactor = args.zoom
    const pointSizeFactor = (zoomFactor / 5)

    let startPoints = []
    let startPointColors = []

    const minZoomFactor = 0.01
    const maxZoomFactor = 99999999

    function pointToScreenPos(point) {
        const normalisedPos = point.sub(viewCenter).scale(1 / zoomFactor)
        normalisedPos.y *= -1
        return new Vector2d(
            canvas.width / 2 + normalisedPos.x * canvas.width / 2,
            canvas.height / 2 + normalisedPos.y * canvas.height / 2
        )
    }

    function screenPosToPoint(pos) {
        const normalisedPos = pos.scale(1 / (canvas.width / 2)).sub(new Vector2d(1, 1))
        normalisedPos.y *= -1
        return normalisedPos.scale(zoomFactor).add(viewCenter)
    }

    function drawLine(p1, p2, {
        color = terminal.data.foreground.toString(),
        lineWidth = 2
    }={}) {
        context.beginPath()
        context.moveTo(p1.x, p1.y)
        context.lineTo(p2.x, p2.y)
        context.strokeStyle = color
        context.lineWidth = lineWidth
        context.stroke()
    }

    function drawText(point, text, {
        color = terminal.data.foreground.toString(),
        fontSize = 0.03,
        offset = new Vector2d(0.01, 0.01)
    }={}) {
        context.fillStyle = color
        context.font = `${fontSize * canvas.width}px monospace`
        context.textBaseline = "top"
        context.textAlign = "left"
        const textPos = point.add(offset.scale(canvas.width))
        context.fillText(text, textPos.x, textPos.y)
    }

    function drawGrid() {
        const minXY = screenPosToPoint(new Vector2d(0, canvas.height))
        const maxXY = screenPosToPoint(new Vector2d(canvas.width, 0))
        
        drawLine( // x axis
            pointToScreenPos(new Vector2d(0, minXY.y)),
            pointToScreenPos(new Vector2d(0, maxXY.y)))

        drawLine( // y axis
            pointToScreenPos(new Vector2d(minXY.x, 0)),
            pointToScreenPos(new Vector2d(maxXY.x, 0)))

        const xJumpSize = 10 ** Math.round(Math.log10((maxXY.x - minXY.x) / 10) + 0.2)
        const yJumpSize = 10 ** Math.round(Math.log10((maxXY.y - minXY.y) / 10))

        let currX = Math.floor(minXY.x) - Math.floor(minXY.x) % xJumpSize
        while (currX < Math.ceil(maxXY.x) + 1) {
            drawText(pointToScreenPos(new Vector2d(currX, 0)), Math.round(currX * 100) / 100)
            currX += xJumpSize
        }

        let currY = Math.floor(minXY.y) - Math.floor(minXY.y) % yJumpSize
        while (currY < Math.ceil(maxXY.y) + 1) {
            if (currY != 0) {
                // only draw it once (in the x loop)
                drawText(pointToScreenPos(new Vector2d(0, currY)), Math.round(currY * 10) / 10)
            }
            currY += yJumpSize
        }
    }

    function applyTransform(point, t) {
        const columnVector = Matrix.fromArray([[point.x], [point.y]])
        const resultMatrix = matrix.multiply(columnVector)
        const resultPoint = new Vector2d(resultMatrix.getCellValue(0, 0), resultMatrix.getCellValue(1, 0))
        return point.lerp(resultPoint, t)
    }

    function drawCirlce(pos, {
        radius = 0.05,
        color = terminal.data.accentColor1,
    }={}) {
        context.fillStyle = color
        context.beginPath()
        context.arc(pos.x, pos.y, Math.max(radius * canvas.width / zoomFactor * pointSizeFactor, 2), 0, 2 * Math.PI)
        context.fill()
    }

    function drawPoints(t) {
        for (let i = 0; i < startPoints.length; i++) {
            const transformedPoint = applyTransform(startPoints[i], t)
            drawCirlce(pointToScreenPos(transformedPoint),
                {color: startPointColors[i]})
        }
    }

    function updateDrawing() {
        const t = slider.value / slider.max
        canvas.width = canvas.clientWidth
        canvas.height = canvas.clientHeight

        context.clearRect(0, 0, canvas.width, canvas.height)
        context.fillStyle = terminal.data.background.toString()
        context.fillRect(0, 0, canvas.width, canvas.height)

        drawGrid()
        drawPoints(t)
    }

    function generateStartPoints(n) {
        const randomPoints = Array.from({length: n})
            .map(() => Vector2d.fromFunc(Math.random).scale(canvas.width))
            .map(v => screenPosToPoint(v))
        
        const linePoints = []

        const corner1 = screenPosToPoint(new Vector2d(0, 0))
        const corner2 = screenPosToPoint(new Vector2d(canvas.width, 0))
        const corner3 = screenPosToPoint(new Vector2d(canvas.width, canvas.height))
        const corner4 = screenPosToPoint(new Vector2d(0, canvas.height))
        for (let t = 0; t < 1; t += 0.01) {
            linePoints.push(corner1.lerp(corner2, t))
            linePoints.push(corner2.lerp(corner3, t))
            linePoints.push(corner3.lerp(corner4, t))
            linePoints.push(corner4.lerp(corner1, t))
        }

        return randomPoints.concat(linePoints)
    }

    function generateStartPointColors(points) {
        return points.map(p => {
            const normalisedPos = pointToScreenPos(p).scale(2 / canvas.width).add(new Vector2d(-1, -1))
            const angle = Math.atan2(normalisedPos.y, normalisedPos.x) / Math.PI * 180
            const hue = Math.round(angle)
            return Color.hsl(hue / 360, 1, 0.5)
        })
    }

    startPoints = generateStartPoints(500)
    startPointColors = generateStartPointColors(startPoints)

    function getEventPoint(event, {attrX="clientX", attrY="clientY"}={}) {
        let rect = canvas.getBoundingClientRect()
        return screenPosToPoint(new Vector2d(
            event[attrX] - rect.left,
            event[attrY] - rect.top
        ))
    }

    let dragStartPoint = null
    let dragStartViewOffset = null
    let dragEndViewOffset = null

    canvas.onmousedown = event => {
        dragStartPoint = getEventPoint(event, {
            attrX: "clientX", attrY: "clientY"
        })
        dragStartViewOffset = viewCenter.copy()
        dragEndViewOffset = dragStartViewOffset.copy()
    }

    canvas.onmousemove = event => {
        if (!dragStartPoint) {
            return
        }

        const point = getEventPoint(event, {
            attrX: "clientX", attrY: "clientY"
        })
        const diff = point.sub(dragStartPoint).scale(-1)
        dragEndViewOffset = dragStartViewOffset.add(diff)

        viewCenter = dragEndViewOffset
        updateDrawing()
        viewCenter = dragStartViewOffset
    }

    canvas.onmouseup = () => {
        viewCenter = dragEndViewOffset
        updateDrawing()
        dragStartPoint = null
    }

    canvas.onwheel = (event, steps=1) => {
        const delta = Math.sign(event.deltaY)
        for (let i = 0; i < steps; i++) {
            if (delta > 0) {
                zoomFactor /= 0.95
            } else if (delta < 0) {
                zoomFactor *= 0.95
            } else {
                return
            }
        }

        zoomFactor = Math.max(Math.min(zoomFactor, maxZoomFactor), minZoomFactor)
        if (event.preventDefault) {
            event.preventDefault()
        }
        updateDrawing()
    }

    zoomInButton.onclick = () => canvas.onwheel({deltaY: -1}, 6)
    zoomOutButton.onclick = () => canvas.onwheel({deltaY: 1}, 6)

    terminal.scroll()

    updateDrawing(0)

    function easeInOut(t) {
        if ((t /= 1 / 2) < 1) return 1 / 2 * t * t
        return -1 / 2 * ((--t) * (t - 2) - 1)
    }

    let endAnimationFlag = false
    slider.oninput = () => {
        updateDrawing()
        endAnimationFlag = true
    }

    async function playAnimation() {
        let animationProgress = 0
        while (animationProgress < 1 && !endAnimationFlag) {
            animationProgress = Math.min(animationProgress + 0.005, 1)
            const t = easeInOut(animationProgress)
            slider.value = Math.round(t * 500)
            updateDrawing()
            await sleep(1000 / 60)
        }
    }

    playAnimation()

    terminal.printLine("\n- Use the slider to go through the animation")
    terminal.printLine("- Use your mouse wheel / buttons to zoom in & out")

}, {
    description: "visualize a given 2x2 matrix transformation",
    args: {
        "?m=matrix:sm": "2x2 matrix to left-multiply by",
        "?x:n": "x coordinate of center",
        "?y:n": "y coordinate of center",
        "?z=zoom:n:0.01~99999": "zoom level"
    },
    defaultValues: {
        x: 0,
        y: 0,
        zoom: 5
    }
})

// ------------------- js/commands/mill2player.js --------------------
terminal.addCommand("mill2player", async function() {

    //     #-----------#-----------#
    //     |           |
    //     |   #-------#-------#
    //     |   |       |      
    //     |   |   #---#---#
    //     |   |   |       |
    //     #---#---#       #
    //     |   |   |       |
    //     |   |   #---#---#

    const N = "#", X = "X", O = "O"
    let fields = Array.from(Array(3)).map(() => Array.from(Array(8)).map(() => N))

    let PHASE = 1

    function nextPhase() {
        PHASE++
        terminal.printLine("the game enters the next phase.")
        if (PHASE == 2) {
            terminal.printLine("now you may move your points.")
        } else if (PHASE == 3) {
            terminal.printLine("a player has only 3 stones left: they may jump anywhere now!")
        }
    }

    const lookup = [
        [0, 0], [0, 1], [0, 2], [1, 0],
        [1, 1], [1, 2], [2, 0], [2, 1],
        [2, 2], [0, 7], [1, 7], [2, 7],
        [2, 3], [1, 3], [0, 3], [2, 6],
        [2, 5], [2, 4], [1, 6], [1, 5],
        [1, 4], [0, 6], [0, 5], [0, 4]
    ]

    function getField(n) {
        let [i, j] = lookup[n]
        return fields[i][j]
    }

    function doubleToSingle(a, b) {
        for (let i = 0; i < lookup.length; i++) {
            let look = lookup[i]
            if (look[0] == a && look[1] == b)
                return i
        }
        return -1
    }

    function printField() {
        let lines = "\n"
        lines += "#-----------#-----------#\n"
        lines += "|           |           |\n"
        lines += "|   #-------#-------#   |\n"
        lines += "|   |       |       |   |\n"
        lines += "|   |   #---#---#   |   |\n"
        lines += "|   |   |       |   |   |\n"
        lines += "#---#---#       #---#---#\n"
        lines += "|   |   |       |   |   |\n"
        lines += "|   |   #---#---#   |   |\n"
        lines += "|   |       |       |   |\n"
        lines += "|   #-------#-------#   |\n"
        lines += "|           |           |\n"
        lines += "#-----------#-----------#\n"

        let i = 0
        for (let char of lines) {
            if (char == "#") {
                let val = getField(i)
                if (val == X) terminal.print(X, Color.YELLOW)
                if (val == O) terminal.print(O, Color.BLUE)
                if (val == N) terminal.print(N, Color.rgb(100, 100, 100))
                i++
            } else {
                terminal.print(char)
            }
        }
    }

    function setField(n, val) {
        let [i, j] = lookup[n]
        fields[i][j] = val
    }

    let playerMills = {[X]: [], [O]: []}

    const possibleWins = [
        [[0, 0], [0, 1], [0, 2]],
        [[0, 2], [0, 3], [0, 4]],
        [[0, 4], [0, 5], [0, 6]],
        [[0, 6], [0, 7], [0, 0]],
        [[1, 0], [1, 1], [1, 2]],
        [[1, 2], [1, 3], [1, 4]],
        [[1, 4], [1, 5], [1, 6]],
        [[1, 6], [1, 7], [1, 0]],
        [[2, 0], [2, 1], [2, 2]],
        [[2, 2], [2, 3], [2, 4]],
        [[2, 4], [2, 5], [2, 6]],
        [[2, 6], [2, 7], [2, 0]],
        [[0, 1], [1, 1], [2, 1]],
        [[0, 3], [1, 3], [2, 3]],
        [[0, 5], [1, 5], [2, 5]],
        [[0, 7], [1, 7], [2, 7]],
    ]

    function getMills(player) {
        let mills = []
        for (let possibleWin of possibleWins) {
            let count = 0
            for (let i = 0; i < 3; i++) {
                let [j, k] = possibleWin[i]
                if (fields[j][k] == player)
                    count++
            }
            if (count == 3) {
                mills.push(possibleWin)
            }
        }
        return mills
    }

    function possibleMoves(pos) {
        let poses = []
        for (let possibleWin of possibleWins) {
            for (let i = 0; i < 3; i++) {
                let tempPos = doubleToSingle(possibleWin[i][0], possibleWin[i][1])
                if (tempPos == pos) {
                    if (i == 0)
                        poses = poses.concat([
                            doubleToSingle(possibleWin[0][0], possibleWin[0][1]),
                            doubleToSingle(possibleWin[1][0], possibleWin[1][1])
                        ])
                    if (i == 1) 
                        poses = poses.concat([
                            doubleToSingle(possibleWin[0][0], possibleWin[0][1]),
                            doubleToSingle(possibleWin[1][0], possibleWin[1][1]),
                            doubleToSingle(possibleWin[2][0], possibleWin[2][1])
                        ])
                    if (i == 2)
                        poses = poses.concat([
                            doubleToSingle(possibleWin[1][0], possibleWin[1][1]),
                            doubleToSingle(possibleWin[2][0], possibleWin[2][1])
                        ])
                }
            }
        }
        return poses
    }

    function oppositePlayer(player) {
        return (player == X) ? O : X
    }

    function countStones(player) {
        let count = 0
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 8; j++) {
                if (fields[i][j] == player)
                    count++
            }
        }
        return count
    }

    function stoneInMill(stone) {
        let allMills = getMills(X).concat(getMills(O))
            .map(m => m.map(e => doubleToSingle(e[0], e[1]))).flat()
        return allMills.includes(stone)
    }

    async function checkMillSituation(player) {
        let numMills = getMills(player).length
        if (numMills > playerMills[player]) {
            printField()
            let a = await terminal.promptNum(`${player} take one [1-24]: `, {min: 1, max: 24}) - 1
            while (getField(a) != oppositePlayer(player) || stoneInMill(a)) {
                terminal.printLine("field must be of opposite player and not in mill!")
                a = await terminal.promptNum(`${player} take one [1-24]: `, {min: 1, max: 24}) - 1
            }
            setField(a, N)
        }
        playerMills[player] = numMills
    }

    async function playerInput(player, phase=PHASE) {
        if (phase == 1) {
            let a = await terminal.promptNum(`${player} set [1-24]: `, {min: 1, max: 24}) - 1
            if (getField(a) != N) {
                terminal.printLine("field must be free!")
                return await playerInput(player)
            }
            setField(a, player)
            await checkMillSituation(player)
        } else if (countStones(player) <= 3) {
            let a = await terminal.promptNum(`${player} move from [1-24]: `, {min: 1, max: 24}) - 1
            let b = await terminal.promptNum(`${player} move to [1-24]: `, {min: 1, max: 24}) - 1
            if (getField(b) != N || getField(a) != player) {
                terminal.printLine("Invalid move!")
                return await playerInput(player)
            }
            let temp = getField(a)
            setField(a, N)
            playerMills[player] = getMills(player).length
            setField(b, temp)
            await checkMillSituation(player)
        } else if (phase > 1) {
            let a = await terminal.promptNum(`${player} move from [1-24]: `, {min: 1, max: 24}) - 1
            let moves = possibleMoves(a)
            if (moves.length == 1) {
                var b = moves[0]
            } else {
                var b = await terminal.promptNum(`${player} move to [1-24]: `, {min: 1, max: 24}) - 1
            }
            if (getField(b) != N || getField(a) != player || !moves.includes(b)) {
                terminal.printLine("Invalid move!")
                return await playerInput(player)
            }
            let temp = getField(a)
            setField(a, N)
            playerMills[player] = getMills(player).length
            setField(b, temp)
            await checkMillSituation(player)
        }
    }

    let playerDecks = {[X]: 9, [O]: 9}

    while (playerDecks[O] > 0) {
        for (let player of [X, O]) {
            printField()
            await playerInput(player)
            playerDecks[player]--
        }
    }

    nextPhase()

    while (countStones(X) >= 3 && countStones(O) >= 3) {
        for (let player of [X, O]) {
            printField()
            await playerInput(player)
        }
    }

    let winner = (countStones(X) > countStones(O)) ? X : O
    terminal.printLine(`the winner is: ${winner}`)

}, {
    description: "play a game of mill with a friend locally",
    isGame: true
})

// ------------------- js/commands/minesweeper.js --------------------
const defaultSettings = {
    width: 10,
    height: 10,
    bombs: 20
}

terminal.addCommand("minesweeper", async function(args) {
    await terminal.modules.import("game", window)

    let highscoreMode = true
    for (let settingKey of Object.keys(defaultSettings)) {
        if (args[settingKey] != defaultSettings[settingKey]) {
            highscoreMode = false
        }
    }

    if (!highscoreMode) {
        terminal.print("Info:", Color.COLOR_1)
        terminal.printLine(" You changed the default board. So you cannot")
        terminal.printLine("      upload your score. To upload a score, please")
        terminal.printLine("      use the default board (no arguments provided)")
        terminal.addLineBreak()
    }

    const neighborDirections = [
        [-1, -1], [0, -1], [1, -1], [-1, 0],
        [1, 0], [-1, 1], [0, 1], [1, 1]
    ].map(([x, y]) => new Vector2d(x, y))

    const CellState = {
        EMPTY: 0,
        BOMB: 9
    }

    class Board {

        constructor(width, height, bombPercentage) {
            this.selectionPos = new Vector2d(0, 0)
            this.width = width
            this.height = height
            this.bombs = Math.ceil(bombPercentage / 100 * this.area)
            
            this.uncoveredMap = Array.from({length: this.height}, () => {
                return Array.from({length: this.width}, () => false)
            })

            this.flagPositions = []

            this.generateBoard()

            this.uncoveredCount = 0
            this.lost = false
            this.won = false
        }

        _getValue(pos) {
            return this.data[pos.y][pos.x]
        }

        _setValue(pos, value) {
            this.data[pos.y][pos.x] = value
        }

        _isUncovered(pos) {
            return this.uncoveredMap[pos.y][pos.x]
        }

        prepareFirstUncover(pos) {
            let maxTries = 100

            for (let i = 0; i < maxTries; i++) {
                if (this._getValue(pos) == CellState.EMPTY) {
                    return
                }
                this.generateBoard()
            }

            for (let i = 0; i < maxTries; i++) {
                if (this._getValue(pos) != CellState.BOMB) {
                    return
                }
                this.generateBoard()
            }
        }

        lose() {
            this.lost = true

            for (let x = 0; x < this.width; x++) {
                for (let y = 0; y < this.height; y++) {
                    const pos = new Vector2d(x, y)
                    if (this._getValue(pos) == CellState.BOMB) {
                        this.uncoveredMap[y][x] = true
                    }
                }
            }            
        }

        win() {
            this.won = true
        }

        checkWin() {
            let bombsFlagged = 0
            for (let position of this.flagPositions) {
                if (this._getValue(position) == CellState.BOMB) {
                    bombsFlagged++
                }
            }
            return bombsFlagged == this.bombs
        }

        placeFlag(pos) {
            if (this._isUncovered(pos)) {
                return
            }

            if (this._isFlagged(pos)) {
                this.flagPositions = this.flagPositions.filter(p => !p.equals(pos))
                return
            }

            if (this.flagPositions.length >= this.bombs) {
                return
            }

            this.flagPositions.push(pos)

            if (this.checkWin()) {
                this.win()
            }
        }

        uncoverRecursive(pos) {
            if (!this.isInBounds(pos) || this._isUncovered(pos)) {
                return
            }
            
            if (this.uncoveredCount == 0) {
                this.prepareFirstUncover(pos)
            }

            if (this._getValue(pos) == CellState.BOMB) {
                this.lose()
            }

            this.uncoveredMap[pos.y][pos.x] = true
            this.uncoveredCount++

            if (this._getValue(pos) == CellState.EMPTY) {
                for (let direction of neighborDirections) {
                    let newPos = pos.add(direction)
                    this.uncoverRecursive(newPos)
                }
            }

            if (this.uncoveredCount == this.area) {
                this.win()
            }
        }

        resetBoard() {
            this.data = Array.from({length: this.height}, () => {
                return Array.from({length: this.width}, () => CellState.EMPTY)
            })
        }

        isInBounds(pos) {
            if (pos.x < 0 || pos.y < 0) return false
            if (pos.x >= this.width) return false
            if (pos.y >= this.height) return false
            return true
        }

        generateBoard() {
            this.resetBoard()

            const generateBomb = () => {
                let randomPos = new Vector2d(
                    Math.floor(Math.random() * this.width),
                    Math.floor(Math.random() * this.height)
                )

                let value = this._getValue(randomPos)
                if (value == CellState.EMPTY) {
                    this._setValue(randomPos, CellState.BOMB)
                } else {
                    generateBomb()
                }
            }

            for (let i = 0; i < this.bombs; i++) {
                generateBomb()
            }

            for (let x = 0; x < this.width; x++) {
                for (let y = 0; y < this.height; y++) {
                    let pos = new Vector2d(x, y)
                    if (this._getValue(pos) == CellState.BOMB)
                        continue

                    let bombsFound = 0
                    for (let direction of neighborDirections) {
                        let addedPos = pos.add(direction)
                        if (!this.isInBounds(addedPos)) {
                            continue
                        } else if (this._getValue(addedPos) == CellState.BOMB) {
                            bombsFound++
                        }
                    }

                    this._setValue(pos, bombsFound)
                }
            }
        }

        _getStateString(pos) {
            if (this._isFlagged(pos)) {
                return "F"
            } else if (this._isUncovered(pos)) {
                let value = this._getValue(pos)
                if (value == CellState.EMPTY) {
                    return " "
                } else if (value == CellState.BOMB) {
                    return "X"
                } else {
                    return value.toString()
                }
            } else {
                return "_"
            }
        }

        get area() {
            return this.width * this.height
        }

        _isFlagged(pos) {
            return this.flagPositions.some(p => p.equals(pos))
        }

        toString() {
            let output = ""

            let lineBetweenString = "|---" + "+---".repeat(this.width - 1) + "|\n"

            output += ".---" + "v---".repeat(this.width - 1) + ".\n"
            for (let y = 0; y < this.height; y++) {
                output += "|"
                for (let x = 0; x < this.width; x++) {
                    let stateString = this._getStateString(new Vector2d(x, y))

                    if (x == this.selectionPos.x && y == this.selectionPos.y) {
                        output += `>${stateString}<:`
                    } else {
                        output += ` ${stateString} :`
                    }
                }
                output = output.slice(0, -1) + "|\n"

                if (y != this.height - 1) {
                    output += lineBetweenString
                }
            }
            output += "`---" + "^---".repeat(this.width - 1) + "`\n"

            return output
        }

    }

    let startTime = Date.now()

    const board = new Board(args.width, args.height, args.bombs)

    let outputElement = terminal.print("", undefined, {forceElement: true})

    terminal.printLine("\nMove the cursor using the Arrow Keys, press Enter to")
    terminal.printLine(`Uncover, press F to place a flag. There are ${board.bombs} bombs.`)
    terminal.print("You have placed ")
    let flagOutput = terminal.print(0, undefined, {forceElement: true})
    terminal.printLine(`/${board.bombs} flags.`)
    
    const updateOutput = () => {
        outputElement.textContent = board.toString()
        flagOutput.textContent = board.flagPositions.length
    }

    updateOutput()
    terminal.scroll()

    let playing = true

    terminal.onInterrupt(() => {
        playing = false
    })

    const onkeydown = (eventkey, event) => {
        let timeElapsed = Date.now() - startTime
        if (!playing || timeElapsed < 100) return

        if (eventkey == "ArrowUp") {
            board.selectionPos.y = Math.max(board.selectionPos.y - 1, 0)
            event.preventDefault()
        } else if (eventkey == "ArrowDown") {
            board.selectionPos.y = Math.min(board.selectionPos.y + 1, board.height - 1)
            event.preventDefault()
        } else if (eventkey == "ArrowLeft") {
            board.selectionPos.x = Math.max(board.selectionPos.x - 1, 0)
            event.preventDefault()
        } else if (eventkey == "ArrowRight") {
            board.selectionPos.x = Math.min(board.selectionPos.x + 1, board.width - 1)
            event.preventDefault()
        }

        if (eventkey == "Enter") {
            board.uncoverRecursive(board.selectionPos)
            event.preventDefault()
        }

        if (eventkey.toUpperCase() == "F") {
            board.placeFlag(board.selectionPos.copy())
            event.preventDefault()
        }

        updateOutput()
    }

    addEventListener("keydown", event => onkeydown(event.key, event))

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout([
            [null, "↑", null],
            ["←", "↓", "→"],
            ["F", "Enter"],
            ["STRG+C"]
        ])

        terminal.mobileKeyboard.onkeydown = function(e, keycode) {
            onkeydown(keycode, e)
        }
    }

    while (playing) {
        await sleep(100)
        if (board.lost || board.won) {
            break
        }
    }

    playing = false
    let timeElapsed = Date.now() - startTime

    terminal.addLineBreak()

    if (board.won) {
        let seconds = Math.ceil(timeElapsed / 1000)
        terminal.print("You won!", undefined, {background: Color.LIGHT_GREEN})
        terminal.printLine(` It took you ${seconds} seconds.`)

        if (highscoreMode) {
            await HighscoreApi.registerProcess("minesweeper")
            await HighscoreApi.uploadScore(-seconds)
        }
    }

    if (board.lost) {
        let uncoveredPercent = Math.round(board.uncoveredCount / board.area * 100)
        terminal.print("You lost!", undefined, {background: Color.ERROR})
        terminal.printLine(` You uncovered ${uncoveredPercent}% of the board.`)
    }

}, {
    description: "play a game of minesweeper",
    args: {
        "?x=width:i:5~100": "width of the board",
        "?y=height:i:5~100": "height of the board",
        "?b=bombs:i:10~90": "percentage of bombs",
    },
    defaultValues: {
        width: 10,
        height: 10,
        bombs: 20
    },
    isGame: true
})

// ------------------- js/commands/minigolf.js --------------------
const courseData = [
    {
        name: "#1: The Basic",
        shapePoints: [
            { x: 20, y: 0 },
            { x: 80, y: 0 },
            { x: 80, y: 100 },
            { x: 20, y: 100 },
        ],
        ballStartPos: { x: 50, y: 90 },
        holePos: { x: 50, y: 20 },
    },

    {
        name: "#2: Arrow",
        shapePoints: [
            { x: 50, y: 0 },
            { x: 100, y: 0 },
            { x: 50, y: 50 },
            { x: 100, y: 100 },
            { x: 50, y: 100 },
            { x: 0, y: 50 },
        ],
        ballStartPos: { x: 75, y: 90 },
        holePos: { x: 75, y: 10 },
    },
    
    {
        name: "#3: Corner",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 100, y: 0 },
            { x: 100, y: 50 },
            { x: 50, y: 50 },
            { x: 50, y: 100 },
            { x: 0, y: 100 },
        ],
        ballStartPos: { x: 25, y: 85 },
        holePos: { x: 85, y: 25 },
    },

    {
        name: "#4: Hourglass",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 100, y: 0 },
            { x: 100, y: 20 },
            { x: 54, y: 50 },
            { x: 100, y: 80 },
            { x: 100, y: 100 },
            { x: 0, y: 100 },
            { x: 0, y: 80 },
            { x: 46, y: 50 },
            { x: 0, y: 20 },
        ],
        ballStartPos: { x: 50, y: 85 },
        holePos: { x: 50, y: 15 },
    },

    {
        name: "#5: Spiral",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 88, y: 0 },
            { x: 100, y: 10 },
            { x: 100, y: 90 },
            { x: 90, y: 100 },
            { x: 10, y: 100 },
            { x: 0, y: 90 },
            { x: 0, y: 35 },
            { x: 15, y: 25 },
            { x: 65, y: 25 },
            { x: 75, y: 35 },
            { x: 75, y: 75 },
            { x: 25, y: 75 },
            { x: 25, y: 55 },
            { x: 60, y: 55 },
            { x: 60, y: 50 },
            { x: 20, y: 50 },
            { x: 20, y: 80 },
            { x: 80, y: 80 },
            { x: 80, y: 20 },
            { x: 0, y: 20 },
        ],
        ballStartPos: { x: 10, y: 10 },
        holePos: { x: 35, y: 65 },
    },

    {
        name: "#6: Gravity",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 100, y: 0 },
            { x: 100, y: 100 },
            { x: 0, y: 100 },
        ],
        ballStartPos: { x: 50, y: 90 },
        holePos: { x: 90, y: 10 },
        boxes: [
            {
                type: "gravity",
                pos: { x: 20, y: 20 },
                size: { x: 80, y: 50 },
                angle: Math.PI
            },

            {
                type: "gravity",
                pos: { x: 0, y: 20 },
                size: { x: 18, y: 50 },
                angle: Math.PI / 2
            }
        ]
    },

    {
        name: "#7",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 15, y: 0 },
            { x: 15, y: 85 },
            { x: 25, y: 85 },
            { x: 25, y: 15 },
            { x: 40, y: 0 },
            { x: 45, y: 0 },
            { x: 60, y: 15 },
            { x: 60, y: 85 },
            { x: 65, y: 85 },
            { x: 65, y: 15 },
            { x: 80, y: 0 },
            { x: 85, y: 0 },
            { x: 100, y: 15 },
            { x: 100, y: 100 },
            { x: 85, y: 100 },
            { x: 85, y: 15 },
            { x: 80, y: 15 },
            { x: 80, y: 85 },
            { x: 65, y: 100 },
            { x: 60, y: 100 },
            { x: 45, y: 85 },
            { x: 45, y: 15 },
            { x: 40, y: 15 },
            { x: 40, y: 85 },
            { x: 25, y: 100 },
            { x: 15, y: 100 },
            { x: 0, y: 85 },
        ],
        ballStartPos: { x: 7.5, y: 7.5 },
        holePos: { x: 92.5, y: 92.5 }
    },

    {
        name: "#8",
        shapePoints: [
            { x: 0, y: 0 },
            { x: 25, y: 0 },
            { x: 25, y: 75 },
            { x: 35, y: 75 },
            { x: 35, y: 25 },
            { x: 75, y: 25 },
            { x: 75, y: 0 },
            { x: 85, y: 0 },
            { x: 85, y: 25 },
            { x: 100, y: 25 },
            { x: 100, y: 100 },
            { x: 0, y: 100 },
        ],
        ballStartPos: { x: 12.5, y: 12.5 },
        holePos: { x: 80, y: 5 },
        boxes: [
            {
                type: "gravity",
                pos: { x: 0, y: 23 },
                size: { x: 25, y: 50 },
                angle: -Math.PI / 2,
                force: 0.7
            },
            {
                type: "gravity",
                pos: { x: 35, y: 25 },
                size: { x: 65, y: 15 },
                angle: Math.PI / 2
            },
            {
                type: "gravity",
                pos: { x: 0, y: 75 },
                size: { x: 73, y: 25 },
                angle: 0
            },
            {
                type: "gravity",
                pos: { x: 75, y: 75 },
                size: { x: 25, y: 25 },
                angle: -Math.PI / 2
            }
        ]
    },

    {
        name: "#9: S",
        shapePoints: [
            { x: 30, y: 0 },
            { x: 90, y: 0 },
            { x: 90, y: 20 },
            { x: 55, y: 20 },
            { x: 60, y: 25 },
            { x: 90, y: 25 },
            { x: 90, y: 95 },
            { x: 30, y: 95 },
            { x: 10, y: 80 },
            { x: 10, y: 0 },
            { x: 25, y: 0 },
            { x: 25, y: 65 },
            { x: 65, y: 65 },
            { x: 60, y: 60 },
            { x: 30, y: 60 },
        ],
        ballStartPos: { x: 17.5, y: 7.5 },
        holePos: { x: 80, y: 10 },
        boxes: [
            {
                type: "gravity",
                pos: { x: 30, y: 0 },
                size: { x: 25, y: 60 },
                force: 0.1,
                angle: 0,
            },
            {
                type: "gravity",
                pos: { x: 65, y: 25 },
                size: { x: 25, y: 70 },
                force: 0.1,
                angle: 3.141592653589793,
            },
        ],
    },

    {
        name: "#10",
        shapePoints: [
            { x: 15, y: 0 },
            { x: 65, y: 0 },
            { x: 65, y: 20 },
            { x: 85, y: 20 },
            { x: 85, y: 30 },
            { x: 65, y: 30 },
            { x: 65, y: 100 },
            { x: 15, y: 100 },
        ],
        ballStartPos: { x: 50, y: 85 },
        holePos: { x: 80, y: 25 },
        boxes: [
            {
                type: "gravity",
                pos: { x: 15, y: 0 },
                size: { x: 50, y: 20 },
                force: 0.8,
                angle: 1.5707963267948966,
            },
            {
                type: "gravity",
                pos: { x: 15, y: 72 },
                size: { x: 20, y: 28 },
                force: 0.1,
                angle: 0,
            },
            {
                type: "gravity",
                pos: { x: 15, y: 30 },
                size: { x: 50, y: 40 },
                force: 0.3,
                angle: 1.5707963267948966,
            },
        ],
    },
]

terminal.addCommand("minigolf", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({
        name: "Minigolf Game", fullscreen: args.fullscreen
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const worldSize = new Vector2d(100, 100)
    let viewCentre = new Vector2d(canvas.width, canvas.height).scale(0.5)
    let zoomFactor = 1
    const DAMPENING_FACTOR = 0.98

    const pointToCanvas = p => p.sub(worldSize.scale(0.5)).scale(zoomFactor).add(viewCentre)
    const canvasToPoint = p => p.sub(viewCentre).scale(1 / zoomFactor).add(worldSize.scale(0.5))

    const GRAPHICS = {
        zoomSpeed: 0.1,
        backgroundColor: "#eee",
        trackColor: "lightgreen",
        wallColor: "black",
        wallWidth: 0.5,
        ballColor: "white",
        ballBorderWidth: 0.5,
        cursorLength: 3,
        cursorColor: "rgba(0, 0, 0, 0.5)",
        cursorLineWidth: 2,
        ballBorderColor: "black",
        holeColor: "#000",
        uiColor: "black",
        uiFont: "Arial",
        gridLineColor: "rgba(0, 0, 0, 0.5)",
        outerPadding: () => Math.max(Math.min(canvas.width, canvas.height) * 0.05, 20)
    }

    const cursorTurnSpeed = 0.025
    const touchMinDistance = 10
    const minShootStrength = 0.5
    const maxShootStrength = 10
    let totalShots = 0
    const editGridSizeStep = 5

    const drawBackground = () => {
        context.clearRect(0, 0, canvas.width, canvas.height)
        context.fillStyle = GRAPHICS.backgroundColor
        context.fillRect(0, 0, canvas.width, canvas.height)
    }

    class Wall {

        constructor(p1, p2) {
            this.p1 = p1
            this.p2 = p2
        }

        reflect(direction) {
            let angleDifference = direction.angle - this.normalDirection.angle
            return direction.rotate(-angleDifference * 2).scale(-1)
        }


        get points() {
            return [this.p1, this.p2]
        }

        get direction() {
            return this.p2.sub(this.p1)
        }

        get normalDirection() {
            let d = this.direction
            return new Vector2d(-d.y, d.x)
        }

        distanceToPoint(point) {
            let p2toP1 = this.p2.sub(this.p1)
            let p2toPoint = point.sub(this.p1)
            let d = p2toP1.dot(p2toPoint) / (p2toP1.length ** 2)

            if (d < 0) {
                return this.p1.distance(point)
            } else if (d > 1) {
                return this.p2.distance(point)
            } else {
                let closestPoint = this.p1.add(p2toP1.scale(d))
                return closestPoint.distance(point)
            }
        }

        touchesBall(ball) {
            return this.distanceToPoint(ball.pos) < ball.radius
        }

    }

    class MinigolfHole {

        constructor(course) {
            this.course = course
            this.pos = new Vector2d(0, 0)
            this.radius = 3
        }

        touchesBall(ball) {
            return this.pos.distance(ball.pos) < this.radius
        }

        draw() {
            context.fillStyle = GRAPHICS.holeColor
            context.beginPath()
            context.arc(...pointToCanvas(this.pos).array, this.radius * zoomFactor, 0, 2 * Math.PI)
            context.fill()
        }

    }

    class MinigolfBall {

        constructor(course) {
            this.pos = new Vector2d(0, 0)
            this.vel = new Vector2d(0, 0)
            this.radius = 2.5
            this.course = course
            
            this.canShoot = true
            this.cursorAngle = 0
            this.shootStrength = 3
            this.inHole = false
            this.holeZoomFactor = 1
        }

        get fullyInHole() {
            return this.inHole && this.holeZoomFactor == 0
        }

        drawCursor() {
            let cursorDirection = Vector2d.fromAngle(this.cursorAngle)
                .scale(zoomFactor * GRAPHICS.cursorLength)
                .scale(1 + this.shootStrength * 0.5)
                .scale(1 + Math.sin(performance.now() / 100) * 0.05)
            let cursorStart = pointToCanvas(this.pos)
            let cursorEnd = cursorStart.add(cursorDirection)
            
            context.strokeStyle = GRAPHICS.cursorColor
            context.lineWidth = GRAPHICS.cursorLineWidth * zoomFactor
            context.lineCap = "round"

            context.beginPath()
            context.moveTo(...cursorStart.array)
            context.lineTo(...cursorEnd.array)
            context.stroke()

            context.lineCap = "butt"
        }

        shoot() {
            if (!this.canShoot) return

            this.vel = Vector2d.fromAngle(this.cursorAngle).scale(this.shootStrength)
            this.canShoot = false
            totalShots++
        }

        draw() {
            if (this.canShoot) {
                this.drawCursor()
            }

            let ballZoomFactor = this.holeZoomFactor * zoomFactor

            context.fillStyle = GRAPHICS.ballColor
            context.strokeStyle = GRAPHICS.ballBorderColor
            context.lineWidth = GRAPHICS.ballBorderWidth * ballZoomFactor
            context.beginPath()
            context.arc(...pointToCanvas(this.pos).array, this.radius * ballZoomFactor, 0, 2 * Math.PI)
            context.fill()
            context.stroke()
        }

        update() {
            let gravityBox = this.inGravityBox()

            if (this.inHole) {
                let delta = this.course.hole.pos.sub(this.pos)
                this.pos.iadd(delta.scale(0.1))

                this.holeZoomFactor -= 0.01
                if (this.holeZoomFactor < 0.01) {
                    this.holeZoomFactor = 0
                }
                return
            } else if (this.vel.length < 0.1 && !gravityBox) {
                if (!this.canShoot) {
                    this.canShoot = true
                    this.cursorAngle = this.vel.angle
                }
                return
            }

            if (gravityBox) {
                this.vel.iadd(gravityBox.gravityForce)
            }

            let subSteps = Math.ceil(this.vel.length * 2)
            this.vel.iscale(1 / subSteps)
            for (let i = 0; i < subSteps; i++) {
                this.subupdate()
            }
            this.vel.iscale(subSteps)

            this.vel.iscale(DAMPENING_FACTOR)
        }

        inGravityBox() {
            for (let box of this.course.boxes) {
                if (box.ballInside(this)) {
                    if (box.type == "gravity") {
                        return box
                    }
                }
            }   
        }

        subupdate() {
            this.pos.iadd(this.vel)

            for (let wall of this.course.walls) {
                if (wall.touchesBall(this)) {
                    this.pos.isub(this.vel)
                    this.vel = wall.reflect(this.vel)
                    this.pos.iadd(this.vel)
                }
            }

            if (this.course.hole && this.course.hole.touchesBall(this)) {
                this.inHole = true
                this.canShoot = false
            }
        }

    }

    class MinigolfBox {

        constructor(course, type="normal") {
            this.course = course
            this.type = type
            this.pos = new Vector2d(0, 0)
            this.size = new Vector2d(0, 0)
        }

        static fromData(course, data) {
            if (data.type == "gravity")
                return MinigolfGravityBox.fromData(course, data)
            let box = new MinigolfBox(course)
            box.pos = new Vector2d(data.pos.x, data.pos.y)
            box.size = new Vector2d(data.size.x, data.size.y)
            return box
        }

        ballInside(ball) {
            let topLeft = this.pos
            let bottomRight = this.pos.add(this.size)
            let ballPos = ball.pos
            return (
                ballPos.x > topLeft.x - ball.radius &&
                ballPos.x < bottomRight.x + ball.radius &&
                ballPos.y > topLeft.y - ball.radius &&
                ballPos.y < bottomRight.y + ball.radius
            )
        }

        draw() {
            context.fillStyle = GRAPHICS.backgroundColor
            context.strokeStyle = GRAPHICS.wallColor
            context.lineWidth = GRAPHICS.wallWidth * zoomFactor

            let topLeft = pointToCanvas(this.pos)
            let bottomRight = pointToCanvas(this.pos.add(this.size))

            context.beginPath()
            context.rect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y)
            context.fill()
            context.stroke()
        }

    }

    class MinigolfGravityBox extends MinigolfBox {

        constructor(course) {
            super(course, "gravity")
            this.forceStrength = 0.1
            this.angle = 0
        }

        get gravityForce() {
            return Vector2d.fromAngle(this.angle).scale(this.forceStrength)
        }

        static fromData(course, data) {
            let box = new MinigolfGravityBox(course)
            box.pos = new Vector2d(data.pos.x, data.pos.y)
            box.size = new Vector2d(data.size.x, data.size.y)
            box.gravity = data.gravity
            if (data.angle) box.angle = data.angle
            if (data.force) box.forceStrength = data.force
            return box
        }

        draw() {
            const drawArrow = (pos, angle, length) => {
                angle += Math.PI
                context.save()
                context.translate(...pointToCanvas(pos).array)
                context.rotate(angle)
                context.beginPath()
                context.moveTo(length * zoomFactor, -length * zoomFactor)
                context.lineTo(-length * zoomFactor, 0)
                context.lineTo(length * zoomFactor, length * zoomFactor)
                context.fill()
                context.restore()
            }

            context.fillStyle = "rgba(0, 0, 0, 0.3)"
            context.lineWidth = GRAPHICS.wallWidth * zoomFactor

            let topLeft = pointToCanvas(this.pos)
            let bottomRight = pointToCanvas(this.pos.add(this.size))

            context.beginPath()
            context.rect(
                topLeft.x,
                topLeft.y,
                bottomRight.x - topLeft.x,
                bottomRight.y - topLeft.y
            )
            context.fill()

            let center = this.pos.add(this.size.scale(0.5))
            let arrowLength = 0.3 * Math.min(this.size.x, this.size.y)
            let arrowAngle = this.gravityForce.angle
            context.fillStyle = GRAPHICS.trackColor
            drawArrow(center, arrowAngle, arrowLength)
        }

    }

    class MinigolfCourse {

        getBoundingBox() {
            const bounding = {
                y: {
                    min: Infinity,
                    max: -Infinity
                },
                x: {
                    min: Infinity,
                    max: -Infinity
                }
            }

            for (let point of this.shapePoints) {
                if (point.x < bounding.x.min) bounding.x.min = point.x
                if (point.y < bounding.y.min) bounding.y.min = point.y
                if (point.x > bounding.x.max) bounding.x.max = point.x
                if (point.y > bounding.y.max) bounding.y.max = point.y
            }

            return {
                min: pointToCanvas(new Vector2d(bounding.x.min, bounding.y.min)),
                max: pointToCanvas(new Vector2d(bounding.x.max, bounding.y.max)),
            }
        }

        constructor() {
            this.name = "Unnamed Course"
            this.walls = []
            this.shapePoints = []
            this.ballStartPos = new Vector2d(0, 0)
            this.holePos = new Vector2d(0, 0)
            this.ball = undefined
            this.hole = undefined
            this.boxes = []
        }

        get completed() {
            return this.ball && this.ball.fullyInHole
        }

        setShape(points) {
            this.shapePoints = points
            this.walls = []

            for (let i = 0; i < points.length; i++) {
                this.walls.push(new Wall(points[i], points[(i + 1) % points.length]))
            }
        }

        addBall() {
            this.ball = new MinigolfBall(this)
            this.ball.pos = this.ballStartPos
        }

        addHole() {
            this.hole = new MinigolfHole(this)
            this.hole.pos = this.holePos
        }

        drawShape(editMode) {
            context.beginPath()
            let lastShapePoint = this.shapePoints[this.shapePoints.length - 1]
            context.moveTo(...pointToCanvas(lastShapePoint).array)
            for (let i = 0; i < this.shapePoints.length; i++) {
                context.lineTo(...pointToCanvas(this.shapePoints[i]).array)
            }
            context.closePath()

            context.fillStyle = GRAPHICS.trackColor
            context.fill()

            context.strokeStyle = GRAPHICS.wallColor
            context.lineWidth = GRAPHICS.wallWidth * zoomFactor
            context.stroke()
        }

        drawEditOverlay() {
            this.drawGrid()
            let squareSize = 20
            for (let i = 0; i < this.shapePoints.length; i++) {
                context.fillStyle = "rgba(0, 0, 0, 0.5)"
                if (i == this.selectedShapePointIndex) {
                    context.fillStyle = "rgba(255, 0, 0, 0.5)"
                }
                context.fillRect(
                    ...pointToCanvas(this.shapePoints[i]).sub(new Vector2d(squareSize / 2, squareSize / 2)).array,
                    squareSize, squareSize
                )
            }
        }

        drawUI() {
            context.fillStyle = GRAPHICS.uiColor
            context.font = GRAPHICS.uiFont
            context.textAlign = "left"
            context.textBaseline = "top"
            let textSize = 5 * zoomFactor
            context.font = textSize + "px " + GRAPHICS.uiFont
            let pos = pointToCanvas(this.shapePoints[0].add(new Vector2d(3, 3)))
            context.fillText(this.name, pos.x, pos.y)
        }

        addBox(box) {
            this.boxes.push(box)
        }

        drawGrid() {
            const drawGridLine = (p1, p2) => {
                context.strokeStyle = GRAPHICS.gridLineColor
                context.lineWidth = 1
                context.beginPath()
                context.moveTo(...pointToCanvas(p1).array)
                context.lineTo(...pointToCanvas(p2).array)
                context.stroke()
                context.closePath()
            }

            for (let x = 0; x <= worldSize.x; x += editGridSizeStep) {
                drawGridLine(
                    new Vector2d(x, 0),
                    new Vector2d(x, worldSize.y)
                )
            }

            for (let y = 0; y <= worldSize.y; y += editGridSizeStep) {
                drawGridLine(
                    new Vector2d(0, y),
                    new Vector2d(worldSize.x, y)
                )
            }
        }

        draw(editMode=false, drawBackgroundPlease=true) {
            if (drawBackgroundPlease) drawBackground()
            this.drawShape(editMode)

            for (let box of this.boxes) {
                box.draw()
            }

            if (editMode) {
                this.drawEditOverlay()
            }

            this.drawUI()

            if (this.hole !== undefined) {
                this.hole.draw()
            }

            if (this.ball !== undefined) {
                this.ball.draw()
            }
        }

        static fromData(data) {
            let course = new MinigolfCourse()
            course.name = data.name
            course.setShape(data.shapePoints.map(p => new Vector2d(p.x, p.y)))
            course.ballStartPos = new Vector2d(data.ballStartPos.x, data.ballStartPos.y)
            course.holePos = new Vector2d(data.holePos.x, data.holePos.y)
            course.addBall()
            course.addHole()

            let boxData = data.boxes || []
            for (let box of boxData) {
                course.addBox(MinigolfBox.fromData(course, box))
            }

            return course
        }

        toJSONString() {
            let data = {}
            data.name = this.name
            data.shapePoints = this.shapePoints.map(p => ({ x: p.x, y: p.y }))
            data.ballStartPos = { x: this.ballStartPos.x, y: this.ballStartPos.y }
            data.holePos = { x: this.holePos.x, y: this.holePos.y }
            data.boxes = this.boxes.map(b => {
                let boxData = {}
                boxData.type = b.type
                boxData.pos = { x: b.pos.x, y: b.pos.y }
                boxData.size = { x: b.size.x, y: b.size.y }
                boxData.angle = b.angle
                boxData.force = b.forceStrength
                return boxData
            })
            return JSON.stringify(data)
        }

    }

    const courses = courseData.map(MinigolfCourse.fromData)

    if (!courses[args.level - 1]) {
        terminalWindow.close()
        throw new Error(`Level ${args.level} doesn't exist (yet)`)
    }

    terminal.onInterrupt(() => {
        gameRunning = false
        terminalWindow.close()
    })

    function drawLines(lines, sizeFactor=1) {
        context.fillStyle = GRAPHICS.uiColor
        context.textAlign = "left"
        context.textBaseline = "top"
        let textSize = 5 * zoomFactor * sizeFactor
        context.font = textSize + "px " + "monospace"
        for (let i = 0; i < lines.length; i++) {
            context.fillText(lines[i], 10, 10 + i * textSize)
        }
    }

    let gameRunning = true

    let course = courses[args.level - 1]

    if (args.file) {

        terminal.printLine(`Loading course from file ${args.file}...`)

        try {

            let file = await terminal.getFile(args.file)
            if (file.type != FileType.READABLE) {
                throw new Error(`File ${args.file} is not readable`)
            }

            let fileData = JSON.parse(file.content)
            course = MinigolfCourse.fromData(fileData)

        } catch (e) {
            terminalWindow.close()
            throw e
        }

    }

    if (args.edit) {

        course.name = "New Course"

        const moveAllInDirection = (direction) => {
            for (let i = 0; i < course.shapePoints.length; i++) {
                course.shapePoints[i] = course.shapePoints[i].add(direction)
            }
            course.ballStartPos = course.ballStartPos.add(direction)
            course.holePos = course.holePos.add(direction)
            for (let box of course.boxes) {
                box.pos = box.pos.add(direction)
            }
            course.addBall()
            course.addHole()
        }

        course.selectedShapePointIndex = 0

        let fileData = ""
        zoomFactor = 4
        addEventListener("keydown", e => {
            if (!gameRunning) return

            let selectedPoint = course.shapePoints[course.selectedShapePointIndex]
        
            if (e.shiftKey || e.key == "Tab") {
                if (e.key == "ArrowRight" || (e.key == "Tab" && !e.shiftKey)) {
                    course.selectedShapePointIndex++
                    e.preventDefault()
                } else if (e.key == "ArrowLeft" || (e.key == "Tab" && e.shiftKey)) {
                    course.selectedShapePointIndex--
                    e.preventDefault()
                }
            } else {
                if (e.key == "ArrowUp") {
                    selectedPoint.y -= editGridSizeStep
                } else if (e.key == "ArrowDown") {
                    selectedPoint.y += editGridSizeStep
                } else if (e.key == "ArrowLeft") {
                    selectedPoint.x -= editGridSizeStep
                } else if (e.key == "ArrowRight") {
                    selectedPoint.x += editGridSizeStep
                }
            }

            if (e.key == "+") {
                zoomFactor += 0.2
            }
            
            else if (e.key == "-") {
                zoomFactor -= 0.2
            }

            else if (e.code == "Numpad8") {
                moveAllInDirection(new Vector2d(0, -editGridSizeStep))
            }

            else if (e.code == "Numpad2") {
                moveAllInDirection(new Vector2d(0, editGridSizeStep))
            }

            else if (e.code == "Numpad4") {
                moveAllInDirection(new Vector2d(-editGridSizeStep, 0))
            }

            else if (e.code == "Numpad6") {
                moveAllInDirection(new Vector2d(editGridSizeStep, 0))
            }

            else if (e.key == "Backspace") {
                if (course.shapePoints.length == 1) return
                course.shapePoints.splice(course.selectedShapePointIndex, 1)
                course.selectedShapePointIndex--
            }

            else if (e.key == " ") {
                course.shapePoints.splice(course.selectedShapePointIndex, 0,
                    selectedPoint.copy())
            }

            else if (e.key == "s") {
                gameRunning = false
            }

            else if (e.key == "h") {
                course.holePos = selectedPoint.copy()
                course.addHole()
            }

            else if (e.key == "b") {
                course.ballStartPos = selectedPoint.copy()
                course.addBall()
            }

            if (course.selectedShapePointIndex < 0)
                course.selectedShapePointIndex = course.shapePoints.length - 1
            if (course.selectedShapePointIndex >= course.shapePoints.length)
                course.selectedShapePointIndex = 0
        })

        function loop() {
            viewCentre = new Vector2d(canvas.width, canvas.height).scale(0.5)
            course.draw(true)
            drawLines([ 
                "+       Zoom in",
                "-       Zoom out",
                "↑       Move up",
                "↓       Move down",
                "←       Move left",
                "→       Move right",
                "TAB     Move selection",
                "SPACE   Add point",
                "BACKSP  Delete point",
                "S       Save",
                "H       Set hole pos",
                "B       Set ball pos",
                "CTRL+C  Stop Editor",
                "Numpad  Move in grid"
            ]) 

            if (gameRunning)
                terminal.window.requestAnimationFrame(loop)
        }

        loop()

        while (gameRunning) await sleep(100)

        terminalWindow.close()

        while (true) {
            try {
                let name = await terminal.prompt("How should the course be called? ")
                course.name = name
                fileData = course.toJSONString()
                let fileName = name.toLowerCase().replace(/ /g, "_") + ".mniglf"
                await terminal.createFile(fileName, TextFile, fileData)
                terminal.printSuccess("Course saved as " + fileName)
                await terminal.fileSystem.reload()
                let path = terminal.currFolder.path + "/" + fileName
                terminal.printCommand("Play the course", `minigolf -f ${path}`)
                break
            } catch (e) {
                terminal.printError(e.message)
            }
        }

    } else {

        let coursesFinished = 0
        let currCourseIndex = args.level - 1
        let currCourse = course

        let keysDown = new Set()
        let touchPos = null
        let touchDownPos = null
        let validKeys = new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "])

        addEventListener("keydown", e => {
            if (!gameRunning) return
            keysDown.add(e.key)
            if (validKeys.has(e.key)) e.preventDefault()
        })
        addEventListener("keyup", e => keysDown.delete(e.key))
        addEventListener("touchstart", e => {
            let rect = canvas.getBoundingClientRect()
            touchPos = new Vector2d(
                e.touches[0].clientX - rect.left,
                e.touches[0].clientY - rect.top
            )
            touchDownPos = touchPos.copy()
        })
        addEventListener("touchmove", e => {
            let rect = canvas.getBoundingClientRect()
            touchPos = new Vector2d(
                e.touches[0].clientX - rect.left,
                e.touches[0].clientY - rect.top
            )
        })
        addEventListener("touchend", e => {
            if (touchDownPos !== null && touchPos !== null) {
                let distance = touchPos.distance(touchDownPos)
                if (distance > touchMinDistance) {
                    currCourse.ball.shoot()
                }
            }

            touchDownPos = null
            touchPos = null
        })

        function handleInputs() {
            if (!currCourse.ball.canShoot)
                return

            if (keysDown.has("ArrowLeft"))
                currCourse.ball.cursorAngle -= cursorTurnSpeed
            if (keysDown.has("ArrowRight"))
                currCourse.ball.cursorAngle += cursorTurnSpeed
            if (keysDown.has("ArrowUp"))
                currCourse.ball.shootStrength += 0.25
            if (keysDown.has("ArrowDown"))
                currCourse.ball.shootStrength -= 0.25
            if (keysDown.has(" "))
                currCourse.ball.shoot()

            if (touchPos !== null) {
                let cursorPos = pointToCanvas(currCourse.ball.pos)
                currCourse.ball.cursorAngle = cursorPos.angleTo(touchPos) + Math.PI
                let maxDistance = Math.min(
                    Math.abs(cursorPos.x - canvas.width),
                    Math.abs(cursorPos.y - canvas.height),
                    Math.abs(cursorPos.x),
                    Math.abs(cursorPos.y)
                )
                currCourse.ball.shootStrength = cursorPos.distance(touchPos) / maxDistance * maxShootStrength
            }
            

            currCourse.ball.shootStrength = Math.max(minShootStrength, Math.min(maxShootStrength, currCourse.ball.shootStrength))
        }

        function adjustZoom() {
            let padding = GRAPHICS.outerPadding()
            let courseBounding = currCourse.getBoundingBox()

            if (courseBounding.min.x > padding && courseBounding.min.y > padding)
                zoomFactor += GRAPHICS.zoomSpeed

            padding -= 10
            if (courseBounding.min.x < padding || courseBounding.min.y < padding)
                zoomFactor -= GRAPHICS.zoomSpeed
            
            viewCentre = new Vector2d(canvas.width, canvas.height).scale(0.5)
        }

        function loop() {
            handleInputs()
            currCourse.ball.update(1)
            drawBackground()
            drawLines([
                "Arrow keys to move cursor",
                "Space to shoot",
                "Or use touch controls"
            ], 0.7)
            currCourse.draw(false, false)
            adjustZoom()

            if (currCourse.completed) {
                currCourseIndex = (currCourseIndex + 1)
                currCourse = courses[currCourseIndex]
                if (currCourse === undefined) {
                    gameRunning = false
                }
                coursesFinished++
                if (args.file) {
                    gameRunning = false
                }
            }

            if (gameRunning)
                terminal.window.requestAnimationFrame(loop)
        }

        loop()

        while (gameRunning) await sleep(100)

        terminalWindow.close()

        if (args.file) {
            terminal.printSuccess(`You completed the ${course.name} course!`)
            terminal.printLine(`Your score is ${Math.floor(100 / totalShots)}`)
        } else {
            terminal.printSuccess(`You completed ${coursesFinished} courses!`)
            terminal.printLine("I'm currently working on adding more, so stay tuned!")
    
            if (coursesFinished == courses.length) {
                let score = Math.floor(coursesFinished / totalShots * 100)
                terminal.printLine(`Your score is ${score}`)
                await HighscoreApi.registerProcess("minigolf")
                await HighscoreApi.uploadScore(score)
            } else {
                terminal.printLine("You didn't complete all courses, so no score was registered.")
            }
        }

    }

}, {
    description: "play a game of minigolf",
    args: {
        "?l=level:i": "open a specific level",
        "?e=edit:b": "open map editor",
        "?f=file:s": "open a specific file",
        "?fullscreen:b": "activate fullscreen mode"
    },
    defaultValues: {
        level: 1
    },
    isGame: true
})

// ------------------- js/commands/mkdir.js --------------------
terminal.addCommand("mkdir", async function(args) {
    if (!terminal.isValidFileName(args.name))
        throw new Error("Invalid filename")
    if (terminal.fileExists(args.name))
        throw new Error("File/Directory already exists")

    let newFolder = new DirectoryFile().setName(args.name)
    terminal.currDirectory.addChild(newFolder)
    terminal.printLine(`Created ${newFolder.path}`)
}, {
    description: "create a new directory",
    args: {
        "name:s": "name for your shiny new directory"
    }
})



// ------------------- js/commands/morse.js --------------------
terminal.addCommand("morse", async function(args) {
    function mostPopularChar(string) {
        string = string.toLowerCase().trim()
        let occurences = {}
        for (let char of string) {
            if (!"abcdefghijklmnopqrstuvwxyz.-".includes(char))
                continue
            if (char in occurences) {
                occurences[char]++
            } else {
                occurences[char] = 1
            }
        }
        let mostPopularC = null
        let mostOccurences = 0
        for (let [char, count] of Object.entries(occurences)) {
            if (count > mostOccurences) {
                mostOccurences = count
                mostPopularC = char
            }
        }
        return mostPopularC
    }
    
    MORSE = {
        A: ".-", B: "-...", C: "-.-.",
        D: "-..", E: ".", F: "..-.",
        G: "--.", H: "....", I: "..",
        J: ".---", K: "-.-", L: ".-..",
        M: "--", N: "-.", O: "---",
        P: ".--.", Q: "--.-", R: ".-.",
        S: "...", T: "-", U: "..-",
        V: "...-", W: ".--", X: "-..-",
        Y: "-.--", Z: "--..",
        "0": "----", "1": ".----",
        "2": "..---", "3": "...--",
        "4": "....-", "5": ".....",
        "6": "-....", "7": "--...",
        "8": "---..", "9": "----.",
        ".": ".-.-.-", ",": "--..--",
        "?": "..--..", "'": ".----.",
        "!": "-.-.--", "/": "-..-.",
        "(": "-.--.", ")": "-.--.-",
        "&": ".-...", ":": "---...",
        ";": "-.-.-.", "=": "-...-",
        "+": ".-.-.", "-": "-....-",
        "_": "..--.-", '"': ".-..-.",
        "$": "...-..-", "@": ".--.-."
    }
    let text = args.text.trim().toUpperCase()
    const noinput = () => terminal.printError("No input given.")
    try {
        playFrequency(0, 0)
    } catch {}
    let audioSpeed = 0.4
    if (text.length > 30) audioSpeed = 0.1
    if ([".", "-"].includes(mostPopularChar(text))) {
        text += " "
        let tempLine = "" 
        let tempChar = ""
        for (let char of text) {
            tempChar += char
            if (char == " ") {
                for (let [morseChar, morseCode] of Object.entries(MORSE)) {
                    if (tempChar.trim() == morseCode) {
                        tempLine += morseChar
                        tempChar = ""
                    }
                }
                tempLine += tempChar
                tempChar = ""
            }
            if (tempLine.length > 40) {
                terminal.printLine(tempLine)
                tempLine = ""
            }
        }
        if (tempLine) terminal.printLine(tempLine)
        if (!text) noinput()
    } else {
        for (let char of text) {
            if (char in MORSE) {
                let morseCode = `${MORSE[char].replaceAll(".", "•")}`
                for (let morseChar of morseCode) {
                    terminal.print(morseChar)
                    if (morseChar == "•") {
                        playFrequency(300, 300 * audioSpeed)
                        await sleep(600 * audioSpeed)
                    } else if (morseChar == "-") {
                        playFrequency(600, 600 * audioSpeed)
                        await sleep(900 * audioSpeed)
                    }
                }
                if (audioContext) {
                    await sleep(800 * audioSpeed)
                }
                terminal.print(" ")
            } else if (char == " ") {
                if (audioContext) {
                    await sleep(1000 * audioSpeed)
                }
                terminal.printLine()
            } else {
                terminal.print(char)
            }
        }
        terminal.printLine()
        if (!text) noinput()
    }
}, {
    description: "translate latin to morse or morse to latin",
    args: {
        "*text": "text to translate"
    }
})



// ------------------- js/commands/mv.js --------------------
terminal.addCommand("mv", async function(args) {
    let file = terminal.getFile(args.file)
    if (file == terminal.currDirectory) {
        throw new Error("Cannot move active directory")
    }

    let directory = terminal.getFile(args.directory, FileType.DIRECTORY)
    
    if (args.name) {
        if (!terminal.isValidFileName(args.name)) {
            throw new Error("Invalid Filename")
        } else if (directory.getFile(args.name)) {
            throw new Error("File with that name already exists in directory")
        } else {
            file.setName(args.name)
        }
    } else if (directory == file.parent || directory.fileExists(file.name)) {
        let nameFromNumber = undefined

        let nameStart = ""
        let nameEnding = ""
        let foundPoint = false
        for (let char of [...file.name].reverse()) {
            if (!foundPoint && char == ".") {
                foundPoint = true
            } else if (foundPoint) {
                nameStart = char + nameStart
            } else {
                nameEnding = char + nameEnding
            }
        }

        if (!foundPoint) {
            // swap them
            let temp = nameStart
            nameStart = nameEnding
            nameEnding = temp
        }

        let match = nameStart.match(/^(.+?)([0-9]+)$/)
        let dotQ = foundPoint ? "." : ""
        if (match) {
            nameFromNumber = n => `${match[1]}${(BigInt(match[2]) + BigInt(n))}${dotQ}${nameEnding}`
        } else {
            nameFromNumber = n => `${nameStart}${n}${dotQ}${nameEnding}`
        }

        const maxNumberingTries = 1000
        for (let i = 1; i <= maxNumberingTries; i++) {
            let fileName = nameFromNumber(i)
            if (terminal.isValidFileName(fileName) && !directory.fileExists(fileName)) {
                file.setName(fileName)
                break
            }
            
            if (i == maxNumberingTries) {
                throw new Error("Couldn't generate new unique filename. Provide one using the --name option")
            }
        }
    }

    file.parent.deleteChild(file)
    directory.addChild(file)
}, {
    description: "move a file",
    args: {
        "file:f": "file to move",
        "d=directory:f": "directory to move to",
        "?n=name:s": "new filename",
    }
})

// ------------------- js/commands/name-gen.js --------------------
terminal.addCommand("name-gen", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../names/",
        name: "AI Name Finder. Rate some and click 'done'",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "start a name generator",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/name.js --------------------
terminal.addCommand("name", async function(args) {
    await terminal.modules.import("game", window)

	const methods = {
		set: async () => {
			let newName = args.newname || ""
			while (!/^[a-zA-Z0-9_\-]{1,20}$/.test(newName)) {
				if (newName) {
            		terminal.printError("Name must be 1-20 characters long and only contain letters, numbers, dashes and underscores")
				}
				newName = await terminal.prompt("[highscores] username: ")
			}
			
			HighscoreApi.setUsername(newName)
			terminal.printSuccess("Set new username")
            terminal.print("Reset the username using ")
            terminal.printCommand("name reset", "name reset", Color.COLOR_1)
		},
		reset: async () => {
			if (HighscoreApi.username) {
				HighscoreApi.resetUsername()
				terminal.printSuccess("Reset username")
			} else {
				terminal.printError("No custom username found")
			}
		},
		get: async () => {
			let name = localStorage.getItem("highscore_username")
            if (name == null) {
                name = undefined
            }
			terminal.printLine(`Current username: "${name}"`)
		}
	}
	
	if (!Object.keys(methods).includes(args.method))
		throw new Error(`Unknown method "${args.method}"`)
		
	await methods[args.method]()
}, {
	description: "set a default name for the highscore system to use",
	args: {
		"method": "set | get | reset",
		"?newname": "the new name"
	},
})

// ------------------- js/commands/ncr.js --------------------
terminal.addCommand("ncr", async function(args) {
    const binom = (await terminal.modules.load("binom", terminal)).binom
    let n = ~~args.n
    let k = ~~args.k
    if (k > n) {
        throw new Error("k must be smaller than n")
    }
    terminal.printLine(binom(n, k))
}, {
    description: "calculate binomial distribution value",
    args: {
        "n:n:0~100": "the number of trials",
        "k:n:0~100": "the number of successes"
    }
})



// ------------------- js/commands/neural-car.js --------------------
const myNewGrid = {
    width: 256,
    height: 128,
    data: `                                                                                                                                
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXX                                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     XXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXX                                        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXX                                           XXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                             XXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                              XXXXXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                              XXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                               XXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                XXXXXXXXXXXXXXXXXXX                           XXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                XXXXXXXXXXXXXXXXXX                             XXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                 XXXXXXXXXXXXXXXX                              XXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                  XXXXXXXXXXXXXX                                XXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                   XXXXXXXXXXXX                                  XXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                                                                                                  XXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXX                                                                                                 XXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXX                                                                                                  XXXXXX 
XXXXXXXXXXXXXXXXXXXXXXX                                                                                                  XXXXXX 
XXXXXXXXXXXXXXXXXXXXXXX                                                                                                  XXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXX                                                                                                  XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXX                                                                                                XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXX                                                                                               XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXX               XXXXXX                                                                         XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     XXXXXXXXXXXXXXX                                                                       XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                                                      XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                            XXXXXXX                 XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                         XXXXXXXXXX                XXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                       XXXXXXXXXXXX                XXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                    XXXXXXXXXXXXX                XXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                XXXXXXXXXXXXXX                XXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                              XXXXXXXXXXXXXX                XXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                           XXXXXXXXXXXXXXX                XXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        XXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXXX                                         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXXX                                              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXXX                                                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXX 
XXXXXXXXXXXXX                                                         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXXXX                                                                           XXXXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXXX                                                                             XXXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXXX                                                                             XXXXXXXXXXXXXXXXXX                 XXX 
XXXXXXXXXXX                                                                               XXXXXXXXXXXXXXXXX                XXXX 
XXXXXXXXXXX                                                                               XXXXXXXXXXXXXXXX                 XXXX 
XXXXXXXXXXX                                                                              XXXXXXXXXXXXXXXXX                 XXXX 
XXXXXXXXXX                 XXXXXXXXXXXXX                                                XXXXXXXXXXXXXXXXX                  XXXX 
XXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXX 
XXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXX 
XXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXX 
XXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXX 
XXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXX 
XXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXXX 
XXXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXXX 
XXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXX 
XXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXXXX 
XXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXX 
XXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXX 
XXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXX 
XXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXX 
XXXXXXXXX        XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXX 
XXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXX 
XXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXX 
XXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXXX                    XXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXXXXX                    XXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                                            XXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                                            XXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                                              XXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                                                             XXXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXX                                        XXXXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX           XXXXXXXXXXX                                       XXXXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXX                                     XXXXXXXXXXXXXXXXX 
XXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXX                                   XXXXXXXXXXXXXXXXXX 
XXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXX 
XXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXX                             XXXXXXXXXXXXXXXXXXXXX 
XXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXX              X   XXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXXX                 XX     XXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXX           XXXXXXXXXXXXXXXXXXXXX                   X       XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXX                    XX        XXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXX                      XX          XXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXX                       XX            XXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX                   XXXX                     XXXX              XXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX                                             XX                XXXXXXXXXXXXXXX 
XXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX                                              X                 XXXXXXXXXXXXXX 
XXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXX                                                                XXXXXXXXXXXXXX 
XXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXX                                                                 XXXXXXXXXXXXX 
XXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX                                                                XXXXXXXXXXXXX 
XXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX                              XXXXX                              XXXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXX                              XXXXX                              XXXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXX                                X X                  X           XXXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXX                               XX                    XX           XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXX                              X                    XXX           XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXX                              X                   XXXXX          XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXX                             X                 XXXX             XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXX                            X                XX                XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXX                           X              XXX                 XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXX                          X  XXXXXXX   XXX                   XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXX                      XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        XXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXX 
XXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        X            XXXXXXXXXXX 
XXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        XXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        X            XXXXXXXXXXX 
XXXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXX 
XXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXX 
XXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                       XXXXXXXXXXX 
XXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXX 
XXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXX 
XXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXX 
XXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                          XXXXXXXXXXX 
XXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXX 
XXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXX                       XXXXXXXXXXX 
XXXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XXX                    XXXXXXXXXXXX 
XXXXXX          XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      XX                   XXXXXXXXXXXX 
XXXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        XX                 XXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXX            XXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX              XXX           XXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX               XX            XXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                X            XXXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                              XXXXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                               XXXXXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                               XXXXXXXXXXXXXXXXXX 
XXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                               XXXXXXXXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                              XXXXXXXXXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                              XXXXXXXXXXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                             XXXXXXXXXXXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXXXXXX   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                            XXXXXXXXXXXXXXXXXXXXXXXX 
XXXX           XXXXXXXXXXXXXXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXX                            XXXXXXXXXXXXXXXXXXXXXXXXX 
XXXX            XXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXXXXXXXXXX                          XXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXX            XXXXXXXXX                       XXXXXXXXXXXXXXXXXXXXXXXX                          XXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXX                                              XXXXXXXXXXXXXXXXXXXXXX              XX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXX                                              XXXXXXXXXXXXXXXXXXXXXX               XX      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX                                              XXXXXXXXXXXXXXXXXXXXX                X  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXX                                              XXXXXXXXXXXXXXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXX                                             XXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXX                                            XXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXX                                            XXXXXXXXXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                                           XXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX                   XXX                    XXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXX             XXXXXXXX                   XXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXX         XX XXXXXXXXXXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    XXXX   XXX   XXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XXX      XXX  XXXXXXXXXXXXXXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXXXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                 XXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXXXXXX                  XX     XXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXXXXXXXXXXX                          XXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                            XXXXXXXXXXXXXXXXXXXXXXXX                           XXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXX                             XXXXXXXXXXXXXXXXXXXXXXXXXX                           XXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXX                               XXXXXXXXXXXXXXXXXXXXXXXXXX                            XXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXX                                XXXXXXXXXXXXXXXXXXXXXXXXXXX                             XXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXXXX                              XXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXX                XXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXX                XXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX          XXXX               XXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXX                               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX        XX XX                XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX                               XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     XXX                    XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX                              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX    XX                       XXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                       XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  XX                        XXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                         XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX        XX     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX         XXX   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                    XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX          XX  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX           XX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX                XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXX             XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX             XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XXXX          XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX      XXX        XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX     XXX         XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX  XXX           XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX               XXXXXXXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX               XXXXXXXXXXXXXXXXXXX 
XXXXXXXXX               XXXXXXXXXXXXXXXXXXXX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXX               XXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX               XXXXXXXXXXXXXXXX                        XXXXXXXXXXXXXXXXXXXXXXXXXXXXX             XXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                XXXXXXXXXXXX                            XXXXXXXXXXXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXX                 XXXXXXXXXX                              XXXXXXXXXXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX                 XXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXX            XXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXX                  XXXXX                     X             XXXXXXXXXXXXXXXXXXXXXXXX           XXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXX                                           XX                 XX    XX     XXXX            XXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXX                                         XXX                  X   XX                     XXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXX                                       XX X                  X   X                     XXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXX                                     XX  X                   X  X                    XXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXX                                    X   X                   XX X                   XXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXX                                  XX   X                    XXX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXX                               XXXXX   X                   XX                  XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXX                            XXXXXXXXXXXX                                      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXX                          XXXXXXXXXXXXX                                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXX                      XXXXXXXXXXXXXXXXX                                   XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXX                   XXXXXXXXXXXXXXXXXXXX                                 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXX              XXXXXXXXXXXXXXXXXXXXXXX                     XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 
                                                                                                                                
`,
    checkpoints: [
        [30, 24],[29, 27],[29, 28],[28, 30],[28, 30],
        [27, 33],[26, 35],[26, 36],[26, 38],[26, 40],
        [26, 41],[26, 44],[26, 44],[26, 46],[26, 49],
        [27, 51],[28, 53],[29, 54],[30, 56],[31, 58],
        [32, 59],[32, 60],[32, 61],[33, 63],[34, 65],
        [34, 66],[35, 68],[36, 69],[37, 71],[38, 73],
        [38, 74],[38, 76],[38, 78],[38, 81],[39, 83],
        [38, 84],[37, 87],[36, 90],[35, 91],[34, 93],
        [33, 95],[33, 96],[32, 98],[32, 102],[31, 103],
        [31, 105],[33, 108],[34, 110],[36, 110],[39, 112],
        [38, 112],[40, 113],[42, 114],[44, 115],[45, 115],
        [46, 115],[49, 115],[50, 115],[51, 115],[54, 115],
        [56, 115],[59, 115],[62, 115],[63, 115],[65, 115],
        [67, 115],[69, 114],[70, 114],[72, 113],[74, 112],
        [75, 111],[76, 111],[78, 110],[81, 109],[82, 108],
        [84, 108],[85, 107],[87, 106],[88, 105],[89, 103],
        [90, 101],[91, 100],[92, 99],[93, 97],[94, 95],
        [94, 93],[94, 91],[95, 89],[95, 87],[95, 86],
        [95, 85],[95, 83],[93, 79],[93, 79],[91, 77],
        [90, 75],[89, 73],[88, 72],[87, 70],[87, 68],
        [87, 67],[88, 65],[88, 63],[89, 62],[91, 60],
        [92, 58],[93, 57],[95, 56],[96, 55],[97, 54],
        [99, 52],[100, 52],[103, 52],[104, 52],[106, 52],
        [110, 52],[111, 52],[112, 52],[115, 54],[116, 55],
        [117, 57],[120, 59],[121, 60],[122, 62],[123, 62],
        [123, 64],[124, 65],[124, 67],[124, 68],[124, 69],
        [123, 71],[122, 73],[122, 74],[121, 76],[120, 77],
        [120, 78],[119, 79],[119, 80],[118, 82],[118, 83],
        [118, 84],[118, 85],[118, 86],[119, 88],[120, 89],
        [120, 90],[120, 91],[120, 93],[121, 94],[121, 95],
        [121, 97],[120, 99],[120, 100],[120, 101],[120, 102],
        [121, 104],[122, 106],[124, 106],[125, 107],[126, 107],
        [128, 107],[129, 107],[131, 107],[131, 107],[133, 106],
        [134, 105],[135, 104],[136, 104],[137, 103],[137, 102],
        [139, 102],[140, 101],[142, 101],[144, 102],[146, 103],
        [147, 104],[148, 104],[150, 104],[152, 104],[153, 104],
        [155, 103],[156, 103],[158, 102],[159, 101],[160, 100],
        [161, 98],[162, 97],[163, 95],[164, 93],[164, 91],
        [165, 90],[166, 88],[167, 86],[168, 84],[170, 83],
        [171, 81],[172, 80],[174, 79],[176, 78],[177, 78],
        [180, 77],[180, 77],[182, 77],[183, 78],[185, 79],
        [186, 79],[188, 80],[188, 81],[190, 83],[192, 84],
        [193, 86],[194, 87],[195, 89],[197, 91],[198, 92],
        [199, 93],[201, 94],[202, 95],[204, 96],[206, 97],
        [208, 97],[209, 98],[211, 98],[213, 98],[215, 98],
        [217, 98],[219, 98],[221, 98],[223, 97],[225, 96],
        [226, 96],[228, 94],[230, 93],[231, 92],[233, 89],
        [234, 88],[234, 86],[235, 84],[235, 83],[235, 80],
        [235, 78],[235, 76],[234, 73],[234, 71],[233, 69],
        [233, 67],[232, 64],[231, 60],[231, 59],[230, 56],
        [229, 52],[229, 50],[230, 48],[231, 46],[232, 45],
        [233, 44],[234, 42],[235, 41],[235, 39],[235, 37],
        [235, 35],[235, 34],[235, 33],[235, 30],[235, 28],
        [234, 27],[234, 25],[233, 24],[231, 23],[230, 22],
        [228, 21],[225, 19],[224, 18],[222, 17],[220, 16],
        [217, 16],[215, 16],[214, 17],[211, 17],[209, 18],
        [208, 18],[207, 19],[205, 20],[204, 21],[203, 23],
        [203, 25],[202, 27],[201, 30],[201, 30],[201, 30],
        [200, 32],[199, 33],[199, 34],[197, 36],[197, 37],
        [196, 38],[195, 40],[195, 41],[194, 42],[192, 44],
        [192, 45],[191, 45],[189, 46],[188, 46],[187, 46],
        [183, 46],[182, 46],[181, 46],[180, 46],[178, 46],
        [177, 46],[176, 45],[176, 44],[175, 42],[175, 42],
        [174, 40],[174, 39],[174, 37],[174, 36],[173, 34],
        [173, 32],[173, 30],[174, 29],[175, 27],[175, 25],
        [175, 24],[175, 22],[175, 21],[175, 19],[174, 18],
        [174, 17],[172, 15],[172, 13],[170, 12],[169, 11],
        [168, 10],[167, 9],[165, 9],[164, 9],[163, 9],
        [161, 9],[160, 10],[158, 10],[156, 10],[155, 10],
        [153, 11],[151, 11],[149, 12],[148, 12],[146, 13],
        [146, 14],[144, 15],[144, 16],[143, 17],[141, 19],
        [140, 19],[139, 20],[137, 21],[135, 21],[133, 21],
        [131, 22],[129, 22],[128, 21],[125, 20],[122, 20],
        [120, 20],[118, 19],[116, 19],[115, 19],[113, 18],
        [111, 17],[110, 17],[107, 17],[105, 16],[104, 15],
        [102, 15],[99, 15],[96, 16],[94, 16],[93, 15],
        [91, 14],[90, 14],[87, 13],[82, 13],[81, 13],
        [78, 13],[76, 14],[74, 14],[72, 16],[70, 16],
        [68, 17],[67, 18],[66, 21],[66, 23],[65, 25],
        [64, 26],[64, 28],[64, 31],[65, 33],[65, 34],
        [65, 36],[64, 38],[64, 39],[64, 41],[65, 43],
        [65, 45],[65, 46],[65, 48],[66, 50],[66, 51],
        [66, 53],[66, 55],[66, 56],[67, 59],[67, 61],
        [67, 63],[67, 65],[67, 68],[67, 70],[67, 72],
        [67, 74],[67, 77],[67, 79],[67, 82],[67, 84],
        [68, 87],    ]
}

terminal.addCommand("neural-car", async function(args) {
    await terminal.modules.load("window", terminal)
    await terminal.modules.load("neural", terminal)
    await terminal.modules.import("game", window)

    let terminalWindow = terminal.modules.window.make({
        name: "Neural Car Simulation (Genetic Algorithm)"
    })

    terminal.onInterrupt(() => {
        terminalWindow.close()
        gameRunning = false
    })

    let gridSize = new Vector2d(256, 128)
    const raycastLines = 10
    const carFOV = Math.PI / 2
    const carTurnSpeed = Math.PI / 90
    const mutationRate = 0.05
    const maxTicks = 10000
    let totalBestScore = 0

    let activeZooming = false

    let currViewPos = new Vector2d(0, 0)
    let currViewGoal = currViewPos.copy()
    let currZoom = 1
    let currZoomGoal = currZoom

    function canvasPosToZoomPos(pos) {
        return pos.scale(currZoom).add(currViewPos)
    }

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    canvas.style.cursor = "none"

    let gameRunning = true

    let wallData = []
    let checkpoints = []

    function initWallData() {
        for (let x = 0; x < gridSize.x; x++) {
            wallData[x] = []
            for (let y = 0; y < gridSize.y; y++) {
                wallData[x][y] = false
            }
        }
    }

    function drawBestScore() {
        context.strokeStyle = "#fff"
        context.font = "20px monospace"
        context.lineWidth = 1
        context.strokeText("Best Score: " + totalBestScore, 10, 30)
    }

    function loadWallData(wallString) {
        const lines = wallString.split("\n")
        for (let x = 0; x < gridSize.x; x++) {
            for (let y = 0; y < gridSize.y; y++) {
                wallData[x][y] = lines[x][y] == "X"
            }
        }
    }

    function loadCompressedWallData(wallData) {
        // wallData is Uint8Array, each byte is 8 consecutive cells
        for (let x = 0; x < gridSize.x; x++) {
            for (let y = 0; y < gridSize.y; y++) {
                let byte = wallData[Math.floor(y / 8) * gridSize.x + x]
                let bit = y % 8
                wallData[x][y] = (byte & (1 << bit)) != 0
            }
        }
    }

    function clearCanvas() {
        context.clearRect(0, 0, canvas.width, canvas.height)
        context.fillStyle = "black"
        context.fillRect(0, 0, canvas.width, canvas.height)
    }

    function drawWalls() {
        const blockSize = new Vector2d(canvas.width / gridSize.x, canvas.height / gridSize.y)
        for (let x = 0; x < gridSize.x; x++) {
            let wallCount = 0
            let wallStartY = 0
            for (let y = 0; y < gridSize.y; y++) {
                if (!wallData[x][y] && wallCount == 0) {
                    wallCount++
                    wallStartY = y
                } else if (!wallData[x][y]) {
                    wallCount++
                } else {
                    if (wallCount > 0) {
                        context.fillStyle = "white"
                        let rectPos = new Vector2d(x * blockSize.x, wallStartY * blockSize.y)
                        let rectSize = new Vector2d(blockSize.x + 1, blockSize.y * wallCount)
                        rectPos = canvasPosToZoomPos(rectPos)
                        rectSize = rectSize.scale(currZoom)
                        if (rectPos.x + rectSize.x < 0 || rectPos.x > canvas.width || rectPos.y + rectSize.y < 0 || rectPos.y > canvas.height) {
                            wallCount = 0
                            continue
                        }
                        context.fillRect(rectPos.x, rectPos.y, rectSize.x, rectSize.y)
                    }
                    wallCount = 0
                }
            }
        }
    }

    function drawCheckpoints() {
        const blockSize = new Vector2d(canvas.width / gridSize.x, canvas.height / gridSize.y)
        for (let i = 0; i < checkpoints.length; i++) {
            context.fillStyle = "red"
            context.fillRect(checkpoints[i].x * blockSize.x, checkpoints[i].y * blockSize.y, blockSize.x, blockSize.y)
        }
    }

    function loadCheckpoints(checkpointData) {
        checkpoints = checkpointData.map((checkpoint) => new Vector2d(checkpoint[0], checkpoint[1]))
    }

    function loadGrid(grid) {
        gridSize.x = grid.width
        gridSize.y = grid.height
        initWallData()
        loadWallData(grid.data)
        loadCheckpoints(grid.checkpoints)
    }

    function nearestCheckpoint(pos) {
        let nearest = null
        let nearestIndex = -1
        let nearestDist = Infinity
        for (let i = 0; i < checkpoints.length; i++) {
            let dist = checkpoints[i].distance(pos)
            if (dist < nearestDist) {
                nearestDist = dist
                nearest = checkpoints[i]
                nearestIndex = i
            }
        }
        return [nearest, nearestIndex]
    }

    function canvasPosFromPos(pos) {
        return new Vector2d(
            pos.x / gridSize.x * canvas.width,
            pos.y / gridSize.y * canvas.height
        )
    }

    function posFromCanvasPos(canvasPos) {
        return new Vector2d(
            canvasPos.x / canvas.width * gridSize.x,
            canvasPos.y / canvas.height * gridSize.y
        )
    }

    function raycast(startPos, direction, maxDist) {
        let pos = startPos.copy()
        let dist = 0
        let directionLength = direction.length
        while (dist <= maxDist) {
            let x = Math.floor(pos.x)
            let y = Math.floor(pos.y)
            if (x < 0 || x >= gridSize.x || y < 0 || y >= gridSize.y) {
                return [Infinity, pos]
            }
            if (wallData[x][y]) {
                return [dist, pos]
            }
            pos.iadd(direction)
            dist += directionLength
        }
        return [Infinity, pos]
    }

    class Brain {

        constructor() {
            this.net = new terminal.modules.neural.Net([raycastLines + 3, 10, 2])
            this.signals = ["left", "right"]
        }

        mutate() {
            this.net.mutate(mutationRate)
        }

        copy() {
            let newBrain = new Brain()
            newBrain.net = this.net.copy()
            return newBrain
        }

        think(car) {
            let inputs = []
            inputs.push(car.pos.x / gridSize.x)
            inputs.push(car.pos.y / gridSize.y)
            inputs.push(car.angle % (Math.PI * 2))
            for (let i = 0; i < raycastLines; i++) {
                inputs.push(car.lastRaycastData[i] / gridSize.length * 20)
            }
            let outputs = this.net.input(inputs)
            let maxIndex = terminal.modules.neural.indexOfMax(outputs)
            return this.signals[maxIndex]
        }
    }

    let lastSound = Date.now()

    class Car {

        constructor() {
            this.pos = checkpoints[0].copy()
            this.speed = 0.3
            this.angle = Math.PI / 2
            this.color = "blue"
            this.alive = true
            this.lastRaycastData = null
            this.brain = new Brain()
            this.score = 0
            this.bestScore = 0
            this.waypoints = []
            this.ticks = 0
        }

        die() {
            if (this.alive) {
                if (Date.now() - lastSound > 20) {
                    playFrequency(
                        Math.random() * 300 + 800,
                        100,
                        0.1
                    )
                    lastSound = Date.now()
                }
            }
            this.alive = false
        }

        get reachedEnd() {
            return this.score >= checkpoints.length - 2
        }

        get vel() {
            return Vector2d.fromAngle(this.angle).scale(this.speed)
        }

        checkCollision() {
            let x = Math.floor(this.pos.x)
            let y = Math.floor(this.pos.y)
            if (x < 0 || x >= gridSize.x || y < 0 || y >= gridSize.y) {
                return true
            }
            return wallData[x][y]
        }

        update() {
            if (!this.alive) {
                return
            }

            this.ticks++

            let signal = this.brain.think(this)

            if (signal == "left") {
                this.angle -= carTurnSpeed
            } else if (signal == "right") {
                this.angle += carTurnSpeed
            }

            this.pos.iadd(this.vel)
            if (this.checkCollision()) {
                this.die()
            }

            this.score = this.calcScore()
            if (this.score > this.bestScore) {
                this.bestScore = this.score
            }

            if (this.bestScore - 1 > this.score)
                this.die()

            if (this.ticks % 5 == 0)
                this.waypoints.push(this.pos.copy())
        }

        get canvasPos() {
            return canvasPosToZoomPos(canvasPosFromPos(this.pos))
        }

        calcScore() {
            let [_, score] = nearestCheckpoint(this.pos)
            return score
        }

        raycast({draw=false}={}) {
            this.lastRaycastData = []
            let maxDist = Infinity
            for (let i = 0; i < raycastLines; i++) {
                let angle = this.angle - carFOV / 2 + carFOV / (raycastLines - 1) * i
                let direction = Vector2d.fromAngle(angle)
                let [dist, hitPos] = raycast(this.pos, direction, maxDist)
                this.lastRaycastData.push(dist)

                if (draw) {
                    let canvasPos = canvasPosToZoomPos(canvasPosFromPos(hitPos))
                    context.beginPath()
                    context.moveTo(this.canvasPos.x, this.canvasPos.y)
                    context.lineTo(canvasPos.x, canvasPos.y)
                    context.strokeStyle = "rgba(0, 0, 0, 0.2)"
                    context.lineWidth = 1
                    context.stroke()
                    context.closePath()
                }
            }
        }

        draw() {
            let size = new Vector2d(3.5, 2).scale(1 / gridSize.x * canvas.width).scale(currZoom)
            context.save()
            context.translate(this.canvasPos.x, this.canvasPos.y)
            context.rotate(this.angle)
            context.beginPath()
            let halfSize = size.scale(0.5)
            context.rect(-halfSize.x, -halfSize.y, size.x, size.y)
            context.strokeStyle = "black"
            context.lineWidth = 3
            context.fillStyle = this.alive ? this.color : "red"
            context.stroke()
            context.fill()
            context.closePath()

            context.fillStyle = "white"
            context.font = `${size.y}px monospace`
            context.textAlign = "center"
            context.textBaseline = "middle"
            context.fillText(this.score, 0, 0)

            context.restore()
        }

    }

    function getBestCar(cars, allowDead=false) {
        let bestCar = cars[0]
        let bestScore = cars[0].score
        for (let car of cars) {
            if ((car.alive || allowDead) && car.score > bestScore) {
                bestScore = car.score
                bestCar = car
            }
        }
        return [bestCar, bestScore]
    }

    initWallData()
    loadGrid(myNewGrid)

    async function initWallDrawer() {
        let mouseDown = false
        let leftMouseDown = false
        let currMousePos = null
        let mouseDownPos = null

        let currDrawMode = "paint"

        function redraw() {
            clearCanvas()
            drawWalls()
            drawCheckpoints()
        }

        function posFromEvent(event) {
            let rect = canvas.getBoundingClientRect()
            let xCanvasPos = event.clientX - rect.left
            let yCanvasPos = event.clientY - rect.top
            let x = Math.floor(xCanvasPos / canvas.width * gridSize.x)
            let y = Math.floor(yCanvasPos / canvas.height * gridSize.y)
            return new Vector2d(x, y)
        }

        canvas.addEventListener("mousedown", function(event) {
            if (event.button == 0) {
                mouseDown = true
            } else if (event.button == 2) {
                leftMouseDown = true
            }
            let pos = posFromEvent(event)
            mouseDownPos = pos
        })

        canvas.addEventListener("mouseup", function(event) {
            mouseDown = false
            leftMouseDown = false
        })

        canvas.addEventListener("mouseleave", function(event) {
            mouseDown = false
            leftMouseDown = false
            currMousePos = null
        })

        canvas.addEventListener("contextmenu", function(event) {
            event.preventDefault()
        })

        function fill(pos, val) {
            let queue = []
            queue.push(pos)
            while (queue.length > 0) {
                let pos = queue.shift()
                if (pos.x < 0 || pos.x >= gridSize.x || pos.y < 0 || pos.y >= gridSize.y) {
                    continue
                }
                if (wallData[pos.x][pos.y] == val) {
                    continue
                }
                wallData[pos.x][pos.y] = val
                queue.push(pos.add(new Vector2d(1, 0)))
                queue.push(pos.add(new Vector2d(-1, 0)))
                queue.push(pos.add(new Vector2d(0, 1)))
                queue.push(pos.add(new Vector2d(0, -1)))
            }
        } 

        function fillRect(start, end, val) {
            for (let x = start.x; x <= end.x; x++) {
                for (let y = start.y; y <= end.y; y++) {
                    wallData[x][y] = val
                }
            }
        }

        function fillLine(start, end, val) {
            let delta = end.sub(start)
            let direction = delta.normalized
            for (let i = 0; i < delta.length; i++) {
                let pos = start.add(direction.scale(i))
                wallData[Math.floor(pos.x)][Math.floor(pos.y)] = val
            }
        }

        function drawCircle(pos, radius, val) {
            radius = Math.floor(radius)
            for (let x = pos.x - radius; x <= pos.x + radius; x++) {
                for (let y = pos.y - radius; y <= pos.y + radius; y++) {
                    if (x < 0 || x >= gridSize.x || y < 0 || y >= gridSize.y) {
                        continue
                    }
                    let dist = new Vector2d(x, y).sub(pos).length
                    if (Math.floor(dist) <= Math.floor(radius)) {
                        wallData[x][y] = val
                    }
                }
            }
        }

        canvas.addEventListener("mousemove", function(event) {
            let pos = posFromEvent(event)

            if (currDrawMode == "paint") {
                if (mouseDown) {
                    wallData[pos.x][pos.y] = true
                } else if (leftMouseDown) {
                    wallData[pos.x][pos.y] = false
                }
            }

            if (currDrawMode == "fill") {
                if (mouseDown) {
                    fill(pos, true)
                } else if (leftMouseDown) {
                    fill(pos, false)
                }
            }

            if (currDrawMode == "rect" && mouseDownPos) {
                if (mouseDown) {
                    fillRect(mouseDownPos, pos, true)
                } else if (leftMouseDown) {
                    fillRect(mouseDownPos, pos, false)
                }
            }

            if (currDrawMode == "line" && mouseDownPos) {
                if (mouseDown) {
                    fillLine(mouseDownPos, pos, true)
                } else if (leftMouseDown) {
                    fillLine(mouseDownPos, pos, false)
                }
            }

            if (currDrawMode == "circle") {
                if (mouseDown) {
                    drawCircle(pos, 5, true)
                } else if (leftMouseDown) {
                    drawCircle(pos, 5, false)
                }
            }

            currMousePos = pos
            redraw()
        })

        terminal.window.addEventListener("resize", function(event) {
            redraw()
        })

        addEventListener("keydown", function(event) {
            if (event.key == "Enter") {
                if (gridSize.x * gridSize.y % 8 != 0) {
                    alert("Grid size must be a multiple of 8")
                    return
                }
                let dataString = ""
                for (let x = 0; x < gridSize.x; x++) {
                    for (let y = 0; y < gridSize.y; y++) {
                        dataString += wallData[x][y] ? "X" : " "
                    }
                    dataString += "\n"
                }

                let outString = `const myNewGrid = {\n`
                outString += `    width: ${gridSize.x},\n`
                outString += `    height: ${gridSize.y},\n`
                outString += `    data: \`${dataString}\`,\n`
                outString += `    checkpoints: [\n        `

                for (let i = 0; i < checkpoints.length; i++) {
                    outString += `[${checkpoints[i].x}, ${checkpoints[i].y}],`
                    if (i % 5 == 4) {
                        outString += "\n        "
                    }
                }
                outString += "    ]\n}"

                terminal.copy(outString, {printMessage: false})
                console.log(outString)
            } else if (event.key == " " && currMousePos != null) {
                checkpoints.push(currMousePos)
            } else if (event.key == "Backspace") {
                let [nearest, nearestIndex] = nearestCheckpoint(currMousePos)
                if (nearest != null) {
                    checkpoints.splice(nearestIndex, 1)
                }
            } else if (event.key == "f") {
                currDrawMode = "fill"
                console.log("fill mode activated")
            } else if (event.key == "p") {
                currDrawMode = "paint"
                console.log("paint mode activated")
            } else if (event.key == "l") {
                currDrawMode = "line"
                console.log("line mode activated")
            } else if (event.key == "r") {
                currDrawMode = "rect"
                console.log("rect mode activated")
            } else if (event.key == "c") {
                currDrawMode = "circle"
                console.log("circle mode activated")
            }
            redraw()
        })

        redraw()

        while (gameRunning) {
            await sleep(100)
        }
    }

    async function initSimulation() {
        const cars = []
        let bestWaypoints = []

        for (let i = 0; i < args.cars; i++) {
            cars.push(new Car())
        }

        function drawBestway() {
            if (bestWaypoints.length == 0) return
            let bestwayColor = "rgba(0, 255, 0, 0.5)"
            context.lineWidth = 10
            context.lineCap = "round"
            context.beginPath()
            let firstCanvasPos = canvasPosFromPos(bestWaypoints[0])
            firstCanvasPos = canvasPosToZoomPos(firstCanvasPos)
            context.moveTo(firstCanvasPos.x, firstCanvasPos.y)
            for (let i = 0; i < bestWaypoints.length - 1; i++) {
                let pos = canvasPosFromPos(bestWaypoints[i + 1])
                pos = canvasPosToZoomPos(pos)
                context.lineTo(pos.x, pos.y)
            }
            context.strokeStyle = bestwayColor
            context.stroke()
            context.closePath()
        }

        function redraw() {
            clearCanvas()
            drawWalls()
            drawBestway()
            for (let i = 0; i < cars.length; i++) {
                cars[i].draw()
                cars[i].raycast({draw: true})
            }
            drawBestScore()
        }

        function update() {
            for (let i = 0; i < cars.length; i++) {
                cars[i].update()
            }
        }

        function geneticAlgorithm() {
            let [bestCar, bestScore] = getBestCar(cars, true)
            bestWaypoints = bestCar.waypoints.slice()

            if (bestScore > totalBestScore) {
                totalBestScore = bestScore
            }

            let newCars = []
            for (let i = 0; i < cars.length; i++) {
                let newCar = new Car()
                newCar.brain = bestCar.brain.copy()
                if (i != 0) {
                    newCar.brain.mutate(mutationRate)
                }
                newCars.push(newCar)
            }

            cars.splice(0, cars.length)
            for (let i = 0; i < newCars.length; i++) {
                cars.push(newCars[i])
            }
        }
        
        addEventListener("keydown", function(event) {
            if (event.key == "ArrowDown") {
                currZoomGoal *= 1.1
            } else if (event.key == "ArrowUp") {
                currZoomGoal /= 1.1
            }

            if (event.key == " ") {
                activeZooming = !activeZooming
                if (!activeZooming) {
                    currViewGoal = new Vector2d(0, 0)
                    currZoomGoal = 1
                } else {
                    currZoomGoal = 2
                }
            }
        })

        while (gameRunning) {
            let tick = 0

            while (tick < maxTicks) {
                redraw()
                update()
                await sleep(30)

                let aliveCars = 0
                for (let i = 0; i < cars.length; i++) {
                    if (cars[i].alive) {
                        aliveCars++
                    }
                }

                if (cars.every(car => !car.alive)) {
                    break
                }

                // if a car has reached the end of the track, stop the simulation
                if (cars.reduce((acc, car) => acc + (car.reachedEnd ? 1 : 0), 0) > 0) {
                    break
                }

                tick++

                if (tick % 1 == 0) {
                    let [bestCar, bestScore] = getBestCar(cars)
                    if (bestCar) {
                        bestWaypoints = bestCar.waypoints

                        if (activeZooming) {
                            // set viewOffset to the best car
                            currViewGoal = canvasPosFromPos(bestCar.pos).scale(-currZoom).add(
                                new Vector2d(canvas.width / 2, canvas.height / 2)
                            )
                        }
                    }

                    if (bestScore > totalBestScore) {
                        totalBestScore = bestScore
                    }
                }

                let delta = currViewGoal.sub(currViewPos)
                currViewPos = currViewPos.add(delta.scale(0.05))

                currZoom += (currZoomGoal - currZoom) * 0.05
            }

            geneticAlgorithm()
            playFrequency(
                1000, 100, 0.1
            )
        }
    }

    if (args.edit) {
        await initWallDrawer()
    } else {
        await initSimulation()
    }

    terminalWindow.close()
}, {
    description: "start a neural car simulation",
    args: {
        "?cars:i:1~9999": "number of cars to simulate",
        "?edit:b": "activate the wall editor",
    },
    defaultValues: {
        cars: 100,
    }
})

// ------------------- js/commands/neural-rocket.js --------------------
terminal.addCommand("neural-rocket", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("neural", terminal)
    await terminal.modules.load("window", terminal)

    let terminalWindow = terminal.modules.window.make({
        name: "Neural Rocket Simulation (Genetic Algorithm)"
    })

    terminal.onInterrupt(() => {
        terminalWindow.close()
        gameRunning = false
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const canvasSize = () => new Vector2d(canvas.width, canvas.height)

    const GRAVITY = new Vector2d(0, 0.05)
    const ALIVE_ROCKET_COLOR = "rgba(255, 255, 255, 0.5)"
    const DEAD_ROCKET_COLOR = "rgba(255, 0, 0, 0.5)"
    const THRUST_COLOR = "rgba(255, 255, 0, 0.5)"
    const THRUST_POWER = 0.5
    const TURN_SPEED = 0.05

    const TURN_LEFT = 1
    const TURN_RIGHT = 2
    const TURN_THRUST_OFF = 3
    const DONT_TURN = 4

    const TICK_SCORE = 1

    const BRAIN_OUTPUTS = [TURN_THRUST_OFF, DONT_TURN]
    const MUTATION_RATE = 0.1
    const CROSSOVER_RATE = 0.7
    const MAX_TICKS = 1000
    const bestRocketsPerGen = Math.max(5, Math.floor(args.population / 20))

    const ACTIONS = {
        [TURN_THRUST_OFF]: rocket => rocket.thrust = 0,
        [TURN_LEFT]: rocket => rocket.angle -= TURN_SPEED,
        [TURN_RIGHT]: rocket => rocket.angle += TURN_SPEED,
        [DONT_TURN]: rocket => {}
    }

    class RocketBrain {

        constructor() {
            this.net = new terminal.modules.neural.Net([
                8, // x, y, angle, distanceWallX, distanceWallY, velocityX, velocityY
                16,
                BRAIN_OUTPUTS.length
            ], {
                biasEnabled: true,
            })
        }

        static crossover(brain1, brain2) {
            let newBrain = new RocketBrain()
            newBrain.net = terminal.modules.neural.Net.crossover(brain1.net, brain2.net)
            return newBrain
        }

        copy() {
            let copy = new RocketBrain()
            copy.net = this.net.copy()
            return copy
        }

        mutate() {
            this.net.mutate(MUTATION_RATE)
        }

        think(rocket) {
            // x, y, angle, ticks, distanceWallX, distanceWallY, velocityX, velocityY
            let inputs = [
                rocket.pos.x / canvas.width,
                rocket.pos.y / canvas.height,
                (rocket.angle % (Math.PI * 2)) / (2 * Math.PI),
                rocket.survivedTicks / MAX_TICKS,
                canvas.width - rocket.pos.x,
                canvas.height - rocket.pos.y,
                rocket.vel.x,
                rocket.vel.y
            ]

            let outputs = this.net.input(inputs)
            let maxIndex = terminal.modules.neural.indexOfMax(outputs)
            let actionIndex = BRAIN_OUTPUTS[maxIndex]
            return ACTIONS[actionIndex]
        }

    }

    class Rocket {

        constructor() {
            this.pos = canvasSize().scale(0.5)
            this.angle = Math.PI / 2
            this.thrust = 0
            this.vel = new Vector2d(0, 0)
            this.size = 10
            this.alive = true
            this.brain = new RocketBrain()
            this.score = -Infinity
            this.currScore = 0
            this.survivedTicks = 0
        }

        calcScore() {
            this.currScore = TICK_SCORE * this.survivedTicks
            if (this.currScore > this.score) {
                this.score = this.currScore
            }
        }

        die() {
            if (!this.alive) return

            this.alive = false
        }

        get thrustVel() {
            return Vector2d.fromAngle(this.angle).scale(this.thrust)
        }

        isOutOfBounds() {
            return this.pos.x < 0 || this.pos.x > canvas.width ||
                this.pos.y < 0 || this.pos.y > canvas.height
        }

        update() {
            if (!this.alive) return

            this.survivedTicks++

            this.thrust = THRUST_POWER

            this.brain.think(this)(this)
            ACTIONS[TURN_LEFT](this)

            this.vel.iadd(GRAVITY)
            this.vel.iadd(this.thrustVel)
            let prevPos = this.pos.copy()
            this.pos.iadd(this.vel)

            if (this.isOutOfBounds()) {
                this.pos = prevPos
                this.vel = new Vector2d(0, 0)
                this.die()
            }

            this.calcScore()
        }

        _drawBody() {
            context.beginPath()
            context.moveTo(0, -this.size)
            context.lineTo(-this.size, this.size)
            context.lineTo(this.size, this.size)
            context.closePath()
            context.fillStyle = this.bodyColor
            context.fill()
        }

        _drawThrust() {
            context.beginPath()
            context.moveTo(-this.size / 2, this.size)
            context.lineTo(0, this.size + this.size / 2 * this.thrust * 30)
            context.lineTo(this.size / 2, this.size)
            context.closePath()
            context.strokeStyle = THRUST_COLOR
            context.stroke()
        }

        get bodyColor() {
            return this.alive ? ALIVE_ROCKET_COLOR : DEAD_ROCKET_COLOR
        }

        draw() {
            if (!this.alive)
                return
            
            context.save()
            context.translate(this.pos.x, this.pos.y)
            context.rotate(this.angle + Math.PI / 2)
            this._drawBody()
            this._drawThrust()
            context.restore()
        }

    }

    function clearCanvas() {
        context.clearRect(0, 0, canvas.width, canvas.height)
    }

    function getBestRockets(population, n=bestRocketsPerGen) {
        let sorted = population.slice().sort((a, b) => b.score - a.score)
        return sorted.slice(0, n)
    }

    function makePopulation(populationSize) {
        let population = []
        for (let i = 0; i < populationSize; i++) {
            population.push(new Rocket())
        }
        return population
    }

    function allDead() {
        for (let rocket of population) {
            if (rocket.alive) return false
        }
        return true
    }

    function populationFromParents(populationSize, bestRockets) {
        let population = []
        for (let i = 0; i < populationSize; i++) {
            population.push(new Rocket())
        }

        function twoParents() {
            let i1 = Math.floor(Math.random() * bestRockets.length)
            let i2 = Math.floor(Math.random() * bestRockets.length)
            return [bestRockets[i1], bestRockets[i2]]
        }

        let bestRocket = bestRockets[0]
        let isFirst = true
        for (let rocket of population) {
            if (isFirst) {
                isFirst = false
                rocket.brain = bestRocket.brain.copy()
            } else {
                if (Math.random() < MUTATION_RATE) {
                    rocket.brain = new RocketBrain()
                } else if (Math.random() < CROSSOVER_RATE) {
                    let [p1, p2] = twoParents()
                    rocket.brain = RocketBrain.crossover(p1.brain, p2.brain)
                } else {
                    rocket.brain = bestRocket.brain.copy()
                    rocket.brain.mutate()
                }
            }
        }

        return population
    }

    function mutatePopulation(population, bestRocket) {
        let isFirst = true
        for (let rocket of population) {
            if (isFirst) {
                isFirst = false
                rocket.brain = bestRocket.brain.copy()
            } else {
                if (Math.random() < MUTATION_RATE) {
                    rocket.brain = new RocketBrain()
                } else {
                    rocket.brain = bestRocket.brain.copy()
                    rocket.brain.mutate()
                }
            }
        }
    }

    function getBestRocket(population) {
        let bestRocket = population[0]
        for (let rocket of population) {
            if (rocket.score > bestRocket.score) {
                bestRocket = rocket
            }
        }
        return bestRocket
    }

    function geneticAlgorithm(population) {
        let bestRockets = getBestRockets(population)
        let bestRocket = bestRockets[0]
        population = populationFromParents(population.length, bestRockets)
        bestScore = bestRocket.score
        return population
    }

    function drawInfos(infos) {
        context.fillStyle = "white"
        context.font = "20px monospace"
        context.textAlign = "left"
        context.textBaseline = "top"

        let y = 5
        for (let info of infos) {
            context.fillText(info, 10, y)
            y += 20
        }
    }

    function aliveCount(population) {
        let count = 0
        for (let rocket of population) {
            if (rocket.alive) count++
        }
        return count
    }

    let population = makePopulation(args.population)
    let generationCount = 0
    let bestScore = 0
    let currTick = 0

    function gameLoop() {
        currTick++

        clearCanvas()
        for (let rocket of population) {
            rocket.update()
            rocket.draw()
        }
        drawInfos([
            `generation: ${generationCount}`,
            `alive: ${aliveCount(population)}`,
            `best score: ${bestScore}`,
            `tick: ${currTick}`
        ])

        if (currTick > MAX_TICKS || allDead()) {
            population = geneticAlgorithm(population)
            currTick = 0
            generationCount++
        }
        
        if (gameRunning) {
            requestAnimationFrame(gameLoop)
        }
    }

    let gameRunning = true
    let r = new Rocket()
    gameLoop()

}, {
    description: "trains neural networks to fly rockets",
    args: {
        "?population:i:10~99999": "number of rockets in the population",
    },
    defaultValues: {
        "population": 100,
    },
    isSecret: true
})


// ------------------- js/commands/np.js --------------------
terminal.addCommand("np", async function(args) {
    const np = await terminal.modules.load("np", terminal)
    terminal.window.np = np

    // const a = np.array([[[[1,2,3,4], [7,5,2,1], [1,2,3,0]]], [[[1,2,3,4], [7,5,2,1], [1,2,3,0]]]])
    const a = np.array([[1,2,3,4], [4,5,6,7], [8,9,10,11]])
    terminal.window.a = a

    terminal.printLine(a.toString())
}, {
    description: "start a noelpy interpreter for calculations",
    isSecret: false
})

// ------------------- js/commands/nsolve.js --------------------
terminal.addCommand("nsolve", async function(args) {
    function makeDerivative(f, h=0.0001) {
        return x => (f(x + h) - f(x)) / h
    }

    function newtonSolve(f, df, startX, n) {
        let x = startX
        for (let i = 0; i < n; i++) {
            const slope = df(x)
            const value = f(x)

            if (slope == 0) {
                throw new Error(`slope is zero (at x=${x})`)
            }

            if (Math.abs(value) == Infinity) {
                throw new Error(`value is infinite (at x=${x})`)
            }

            if (args.list) {
                terminal.printLine(`n(${i}) = ${x}`)
            }

            let prevX = x
            x -= f(x) / slope

            if (prevX == x) {
                break
            }
        }
        return x
    }

    if (!/^[0-9x\s\\\*\.a-z+-\^\(\)]+=[0-9x\s\\\*\.a-z+-\^\(\)]+$/.test(args.equation)) {
        terminal.printError("Invalid equation.")
        terminal.printLine("Only numbers, letters, *, +, -, ^, (, ), \\ and spaces are allowed")
        return
    }

    if (args.equation.split("=").length != 2) {
        throw new Error("More than one equation found.")
    }

    const [lhs, rhs] = args.equation.split("=")
    const f = Function("x", `return (${lhs})-(${rhs})`)
    const df = makeDerivative(f)

    const result = newtonSolve(f, df, args.startn, args.iterations)

    const error = Math.abs(f(result) - 0)
    if (error > 0.01) {
        terminal.printError("Method did not converge.", "Warning")
        terminal.printLine(`(wrong) result: ${result}`)
        terminal.printLine(`error: ${error}`)
    } else {
        terminal.printLine(result, Color.COLOR_1)
    }
}, {
    description: "solve an equation using the newton-raphson method",
    args: {
        "*e=equation:s": "the equation to solve",
        "?s=startn:n": "Starting number",
        "?i=iterations:i:1~999999": "number of iterations to perform",
        "?l=list:b": "list all intermediate values"
    },
    defaultValues: {
        startn: 0.71,
        iterations: 1000
    }
})

// ------------------- js/commands/number-guess.js --------------------
terminal.addCommand("number-guess", async function(args) {
    await terminal.modules.import("game", window)

    terminal.printLine("i'm thinking of a random number. can you guess it?")
    let number = Math.floor(Math.random() * 1000) + 1
    let tries = 0
    while (true) {
        let guess = await terminal.promptNum("guess: ", {lineEnd: false})
        tries++
        if (guess == number) {
            break
        }
        if (guess < number) {
            terminal.printLine(`too low! (n > ${guess})`)
        }
        if (guess > number) {
            terminal.printLine(`too high! (n < ${guess})`)
        }
    }
    terminal.printLine(`you got it! it took you ${tries} tries`)    

    await HighscoreApi.registerProcess("number-guess")
    await HighscoreApi.uploadScore(-tries)

}, {
    description: "guess a random number",
    isGame: true
})

// ------------------- js/commands/old-edit.js --------------------
const cssCode = {
    ".editor-parent": {
        "width": "100%",
        "resize": "both",
        "display": "grid",
        "grid-template-rows": "auto 1fr",
        "grid-template-columns": "1fr",
    },

    ".editor-header-title": {
        "width": "fit-content",
        "color": "var(--background)",
        "background": "var(--foreground)",
    },

    ".editor-body": {
        "display": "grid",
        "grid-template-rows": "1fr",
        "grid-template-columns": "auto 1fr",
    },

    ".editor-sidebar": {
        "color": "var(--background)",
        "background": "var(--foreground)",
        "padding-right": "0.1em",
        "padding-left": "0.1em",
    },

    ".editor-content": {
        "outline": "none",
        "padding-right": "0.5em",
        "padding-left": "0.5em",
    },

    ".editor-content > div:focus-visible": {
        "outline": "none",
        "background": "#1d1d1d",
    },
}

function createEditorHTML() {
    let parent = createElement("div", {className: "editor-parent"})
    let header = createElement("div", {className: "editor-header"}, parent)
    let headerTitle = createElement("div", {className: "editor-header-title"}, header)
    let body = createElement("div", {className: "editor-body"}, parent)
    let sidebar = createElement("div", {className: "editor-sidebar"}, body)
    let contentScroll = createElement("div", {className: "editor-content-scroll"}, body)
    let content = createElement("div", {
        className: "editor-content",
        contentEditable: true,
    }, contentScroll)

    return {
        parent, header, headerTitle, body, sidebar, content, contentScroll
    }
}

function implementCSS(code) {
    let style = document.createElement("style")
    for (const [selector, properties] of Object.entries(code)) {
        let css = selector + " {"
        for (const [property, value] of Object.entries(properties))
            css += property + ": " + value + ";"
        css += "}"
        style.innerHTML += css
    }
    terminal.document.head.appendChild(style)
}

let tempFileContent = null
let tempFileName = null
let elements = null
let lineCount = null
let prevLineCount = null
let currentlyEditing = false

function updateLineNums() {
    lineCount = elements.content.childNodes.length

    if (lineCount == 0) {
        elements.sidebar.textContent = "1"
        prevLineCount = lineCount
    } else if (prevLineCount !== lineCount) {
        elements.sidebar.textContent = ""
        for (let i = 0; i < lineCount; i++) {
            let line = createElement("div", {className: "editor-line-num"}, elements.sidebar)
            line.textContent = i + 1
        }
        prevLineCount = lineCount
    }
}

function createElement(tag, props, parent=null) {
    const element = document.createElement(tag)
    for (const [key, value] of Object.entries(props))
        element[key] = value
    if (parent)
        parent.appendChild(element)
    return element
}

function getText() {
    let text = ""
    for (let line of elements.content.querySelectorAll("div")) {
        text += line.textContent + "\n"
    }
    return text.slice(0, -1)
}

function loadContent() {
    let lastElement = null
    for (let line of tempFileContent.split("\n")) {
        let lineElement = createElement("div", {}, elements.content)
        lineElement.textContent = line
        if (lineElement.textContent.trim() == "")
            lineElement.appendChild(document.createElement("br"))
        lastElement = lineElement
    }
    if (lastElement)
        setTimeout(() => lastElement.focus(), 100)
    lineCount = tempFileContent.split("\n").length
    updateLineNums()
}

terminal.addCommand("old-edit", async function(args) {
    if (terminal.inTestMode) return

    tempFileContent = ""
    tempFileName = "Untitled File"
    currentlyEditing = true
    prevLineCount = null
    elements = createEditorHTML()
    
    if (args.file) {
        let file = terminal.getFile(args.file)
        if (file.type == FileType.FOLDER)
            throw new Error("cannot edit a folder")
        tempFileContent = file.content
        tempFileName = file.path
    }

    implementCSS(cssCode)
    terminal.parentNode.appendChild(elements.parent)

    elements.headerTitle.textContent = tempFileName
    elements.content.addEventListener("input", updateLineNums)
    loadContent()

    terminal.document.addEventListener("keydown", event => {
        // save
        if (event.ctrlKey && event.key == "s") {
            currentlyEditing = false
            event.preventDefault()
        }
    })

    while (currentlyEditing) {
        await sleep(100)
    }

    while (tempFileName == "" || tempFileName == "Untitled File") {
        tempFileName = await terminal.prompt("file name: ")
        while (!terminal.isValidFileName(tempFileName)) {
            terminal.printError("invalid file name")
            tempFileName = await terminal.prompt("file name: ")
        }
    }

    if (terminal.fileExists(tempFileName)) {
        let file = terminal.getFile(tempFileName)
        if (file.type == FileType.FOLDER)
            throw new Error("cannot edit a folder")
        file.content = getText()
    } else {
        terminal.currDirectory.addChild(
            new PlainTextFile(getText()).setName(tempFileName)
        )
    }
}, {
    description: "edit a file of the current directory (old version of editor)",
    args: {
        "?file:f": "the file to open",
    },
    isSecret: true,
})



// ------------------- js/commands/panik.js --------------------
terminal.addCommand("panik", async function(args) {
    await terminal.modules.import("game", window)

    terminal.printError("This command is in german.\n", "Warning")

    await terminal.animatePrint("Du hast eine Panikattacke oder fühlst, dass es", 20)
    await terminal.animatePrint("dir nicht gut geht?", 20)
    await sleep(200)
    await terminal.animatePrint("Dann bist du hier richtig!\n", 20)

    terminal.printLine("Wie geht es dir aktuell? Wähle eine option aus:\n")
    terminal.printLine("(a) ich habe eine panikattacke und brauche akut hilfe.")
    terminal.printLine("(b) ich merke dass es sich was aufbaut und will verhindern,")
    terminal.printLine("    dass sich eine Panikattacke aufbaut.\n")

    let answer = (await terminal.prompt("['a' oder 'b']: ")).toLowerCase().trim()
    while (!["a", "b"].includes(answer)) {
        terminal.printError("Die Antwort habe ich nicht verstanden.")
        terminal.printLine("Gib nur den Buchstaben 'a' oder 'b' ein, ohne Anführungszeichen.\n")
        answer = (await terminal.prompt("['a' oder 'b']: ")).toLowerCase().trim()
    }

    if (answer == "a") {

        terminal.print("\nOkay. ")
        terminal.print("Wir schaffen das.\n", undefined, {forceElement: true, element: "b"})
        await terminal.sleep(1000)
        await terminal.animatePrint("Ich starte jetzt einen timer, der die ganze zeit")
        await terminal.sleep(300)
        await terminal.animatePrint("zeigen wird, wie lange wir bisher hier machen:\n")
        await terminal.sleep(2000)
        terminal.scroll()

        let timeOutput = terminal.print("00:00:00:000", undefined, {forceElement: true})
        timeOutput.style.fontSize = "2em"
        const startTime = Date.now()

        function updateTime() {
            const timeDiff = Date.now() - startTime
            let [ms, s, m, h] = [
                (timeDiff % 1000),
                (Math.floor(timeDiff / 1000) % 60),
                (Math.floor(timeDiff / 60000) % 60),
                (Math.floor(timeDiff / 3600000) % 24),
            ].map(n => n.toString().padStart(2, "0"))
            ms = ms.padStart(3, "0")
            timeOutput.textContent = `${h}:${m}:${s}:${ms}`

            terminal.window.requestAnimationFrame(updateTime)
        }

        updateTime()

        await terminal.sleep(2000)
        terminal.printLine("\n\nOkay. Es geht jetzt nur ums Überleben.")
        await terminal.sleep(700)
        await terminal.animatePrint("In deinem Körper wurde gerade Adrenalin")
        await terminal.animatePrint("ausgeschüttet. Das ist nicht schlimm,")
        await terminal.animatePrint("aber verhindert dass du klar denken kannst.\n")
        
        terminal.scroll(); await terminal.sleep(2000)

        await terminal.animatePrint("Wenn du jemanden in deiner Nähe hast oder")
        await terminal.animatePrint("anrufen kannst, wäre jetzt ein guter Zeitpunkt.\n")
        await terminal.animatePrint("Wenn du es gerade nicht kannst oder keiner da ist,")
        await terminal.animatePrint("schaffen wir das jetzt auch zusammen.\n")
        
        terminal.scroll(); await terminal.sleep(2000)

        await terminal.animatePrint("Ab jetzt bitte auf Atemübungen fokussieren!")
        await terminal.animatePrint("Versuche dich auf deinen Atem zu konzentrieren.")
        await terminal.animatePrint("Du schaffst das. Alles ist gut. Du hast eine")
        await terminal.animatePrint("Panikattacke und du wirst *nicht* sterben.\n")
        terminal.scroll(); await terminal.sleep(1000)
        await terminal.animatePrint("Deine Sinne sind gerade völlig außer rand und band.")
        terminal.scroll(); await terminal.sleep(1000)
        await terminal.animatePrint("Das fühlt sich scheiße an, aber das geht weg.")
        terminal.scroll(); await terminal.sleep(1000)
        await terminal.animatePrint("Versuche so ruhig wie nur möglich zu atmen.\n")
        terminal.scroll(); await terminal.sleep(1000)

        await terminal.animatePrint("Ich habe hier eine Grafik für dich, mit der es")
        await terminal.animatePrint("dir vielleicht einfacher fällt, rythmisch zu atmen.")

        terminal.scroll(); await terminal.sleep(1000)

        const canvas = printSquareCanvas({widthChars: 30})
        const context = canvas.getContext("2d")

        function easeInOut(t) {
            if ((t /= 1 / 2) < 1) return 1 / 2 * t * t
            return -1 / 2 * ((--t) * (t - 2) - 1)
        }
        
        const startCanvasTime = Date.now()
        function redrawCanvas() {
            const middle = new Vector2d(canvas.width / 2, canvas.height / 2)
            const breathTime = (Date.now() - startCanvasTime) % 10000
            let t = 0
            if (breathTime < 5000) {
                t = breathTime / 5000
            } else {
                t = 1 - (breathTime - 5000) / 5000
            }

            const cirlceMaxRadius = Math.min(canvas.width, canvas.height) / 2.5

            context.clearRect(0, 0, canvas.width, canvas.height)
            const cirlceSize = easeInOut(t * 0.9 + 0.1)
            context.beginPath()
            context.arc(middle.x, middle.y, cirlceSize * cirlceMaxRadius, 0, Math.PI * 2)
            context.fillStyle = "rgba(255, 255, 255, 0.8)"
            context.fill()
            context.lineWidth = 3
            context.strokeStyle = "black"
            context.stroke()

            const timeDiff = Date.now() - startTime
            let [ms, s, m, h] = [
                (timeDiff % 1000),
                (Math.floor(timeDiff / 1000) % 60),
                (Math.floor(timeDiff / 60000) % 60),
                (Math.floor(timeDiff / 3600000) % 24),
            ].map(n => n.toString().padStart(2, "0"))
            ms = ms.padStart(3, "0")
            const timeString = `${h}:${m}:${s}:${ms}`
            context.textBaseline = "middle"
            context.textAlign = "center"
            context.font = "20px monospace"
            context.fillStyle = "blue"
            context.fillText(timeString, middle.x, middle.y)

            terminal.window.requestAnimationFrame(redrawCanvas)
        }

        terminal.window.requestAnimationFrame(redrawCanvas)

        terminal.scroll(); await terminal.sleep(1000)

        await terminal.animatePrint("\n\nDenk dran: in ein paar minuten ist das vorbei.")
        await terminal.animatePrint("Es *wird* besser, du wirst *nicht* sterben.")
        await terminal.animatePrint("Das Gefühl ist ganz normal. Nach ungefähr 5 Minuten")
        await terminal.animatePrint("Sollte die akute Panik weg sein. Du wirst wieder")
        await terminal.animatePrint("Denken können. Bis dahin: Atmen!")

        await terminal.animatePrint("\nIch melde mich wieder in 8 minuten. Bleib dran.")
        terminal.scroll()
        await sleep(1000 * 60 * 8)

        await terminal.animatePrint("\nOkay. Das waren 8 Minuten.\n")
        await sleep(1000)
        await terminal.animatePrint("Hier endet die Akuthilfe. Aber!:")
        await terminal.animatePrint("Die Panikattacke ist noch nicht ganz vorbei.")
        await terminal.animatePrint("Die Grafiken laufen weiter, ruf am besten")
        await terminal.animatePrint("Personen an, die die jetzt helfen können.\n")

        terminal.scroll(); await sleep(1000)
        await terminal.animatePrint("Wenn die Panik wieder kommt, mache weiter")
        await terminal.animatePrint("die Übungen. Du schaffst das.\n")

        terminal.scroll(); await sleep(1000)
        await terminal.animatePrint("Wenn du Tipps brauchst, was du jetzt tun kannst,")
        await terminal.animatePrint("tippe nochmal den Befehl ein und öffne Option (b).\n")
        terminal.scroll(); await sleep(1000)

        await terminal.animatePrint("Viel Erfolg (ruf Leute an!)")

        terminal.scroll()

    } else {

        terminal.print("\nOkay. ")
        terminal.print("Wir schaffen das!\n", undefined, {forceElement: true, element: "b"})
        terminal.scroll()
        await terminal.sleep(1000)

        await terminal.animatePrint("Das schwerste hast du gerade schon geschafft:")
        await terminal.animatePrint("Du hast erkannt, dass eine Panikattacke kommt")
        await terminal.animatePrint("und machst jetzt etwas dagegen. Perfekt!\n")

        terminal.scroll()
        await terminal.sleep(3000)
        await terminal.animatePrint("Wenn du merkst, dass es schlimm wird, lad")
        await terminal.animatePrint("die Website neu und führ den Befehl nochmal")
        await terminal.animatePrint("aus und öffne Option (a). Alles gut.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Hm. Jetzt musst du etwas machen, damit es dir")
        await terminal.animatePrint("besser geht. Am besten rufst du jemanden an")
        await terminal.animatePrint("oder frag jemanden in deiner Nähe, ob ihr")
        await terminal.animatePrint("quatschen wollt. Es hilft, zu erklären, dass")
        await terminal.animatePrint("es dir komisch geht. Alles gut.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Auch wenn du noch keine Panikattacke hast,")
        await terminal.animatePrint("lohnt es sich jetzt jemanden anzuschreiben.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Wenn du wirklich niemanden hast, z.b. weil")
        await terminal.animatePrint("es Nacht ist, dann machen wir jetzt hier weiter.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Was würde dir jetzt gut tun? Trink Wasser!")
        await terminal.animatePrint("Vielleicht hilft es, aufzustehen?")
        await terminal.animatePrint("Lauf ein paar Schritte, vielleicht kannst du")
        await terminal.animatePrint("sogar Sport machen? Das soll helfen? Glaube ich.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Mach nichts langweiliges zur Ablenkung. Instagram")
        await terminal.animatePrint("ist keine gute Idee. Dein Lieblingsfilm und")
        await terminal.animatePrint("Lieblingsmusik aber vielleicht schon?\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Mir hilft es, Schach auf ")
        terminal.printLink("chess.com", "https://chess.com", undefined, false)
        await terminal.animatePrint(" zu spielen.")
        await terminal.animatePrint("Oder einen Zauberwürfel zu lösen.")
        await terminal.animatePrint("Oder einfach nur jemanden anzuschreiben.\n")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Wahrscheinlich ist dein Körper gerade")
        await terminal.animatePrint("sehr angespannt. Mir hilft es sehr zu lachen!")
        await terminal.animatePrint("Hier eine auswahl an lustigen Videos (Playlist):")
        terminal.printLink("youtube.com/playlist?list=PLZX43-yn58b1WVAWo8TRpL1uJ5yFRioZ1",
            "https://www.youtube.com/playlist?list=PLZX43-yn58b1WVAWo8TRpL1uJ5yFRioZ1")

        terminal.scroll()
        await terminal.sleep(3000)
    
        await terminal.animatePrint("\nMehr Tipps habe ich gerade nicht.")
        await terminal.animatePrint("Bitte schreib jemanden an! Du schaffst das!")

        terminal.scroll()
        await terminal.sleep(3000)

        await terminal.animatePrint("Wenn es dir schlecht geht, führ den")
        await terminal.animatePrint("Befehl nochmal aus und wähle option (a).")
        await terminal.animatePrint("DU SCHAFFST DAS!")
    }
}, {
    description: "[german command] mäßige hilfe bei einer panikattacke",
    isSecret: true
})

// ------------------- js/commands/particle.js --------------------
terminal.addCommand("particle", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../particle/?p=" + encodeURIComponent(args.n),
        name: "Click to change gravity"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "start a particle simulation",
    args: {
        "?n:i:1000~10000000": "number of particles"
    },
    standardVals: {
        n: 100000
    },
    isSecret: true
})

// ------------------- js/commands/pascal.js --------------------
terminal.addCommand("pascal", async function(args) {
    function generate(depth) {
        let rows = []
        let prevRow = []
        for (let i = 0; i < depth; i++) {
            let row = Array(i + 1)
            row[0] = 1
            row[i] = 1
            for (let j = 1; j < i; j++)
                row[j] = prevRow[j - 1] + prevRow[j]
            rows.push(row)
            prevRow = row
        }
        return rows
    }

    args.depth = ~~args.depth

    let data = generate(args.depth)
    // highest number is the one at the bottom middle always
    let maxNumWidth = data[args.depth - 1][Math.floor(args.depth / 2)].toString().length
    let nums = data.map(row => row.map(n => stringPadMiddle(n, maxNumWidth)))
    let rows = nums.map(row => row.join(" "))

    if (args.f) {
        terminal.printLine(rows[rows.length - 1])
        return
    }

    for (let i = 0; i < rows.length; i++) {
        terminal.printLine(stringPadMiddle(rows[i], args.depth * (maxNumWidth + 1)))
    }

}, {
    description: "print a pascal triangle",
    args: {
        "?depth:n:1~100": "the depth of the triangle",
        "?f:b": "only show the final row"
    },
    standardVals: {
        depth: 10
    }
})



// ------------------- js/commands/password.js --------------------
terminal.addCommand("password", async function(args) {
    function generatePassword(length, characters, repeatChars) {
        let password = String()
        let tries = 0
        const maxTries = 10000
        while (password.length < length) {
            tries++
            if (tries > maxTries) {
                terminal.printError("Could not generate password!")
                return password
            }

            let char = characters[Math.floor(Math.random() * characters.length)]
            if (password.length > 0 && repeatChars) {
                let lastChar = password[password.length - 1]
                if (char == lastChar)
                    continue
            }
            password += char
        }
        return password
    }

    let password = generatePassword(args.l, args.c, args.norepeat)

    if (args.diverse) {
        let allLowerCaseLetters = "abcdefghijklmnopqrstuvwxyz"
        let allUpperCaseLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        let allNumbers = "0123456789"
        let allSpecialChars = "$#@%&!?.,;:[]{}()_-+=*"

        if (args.l < 4) {
            throw new Error("Password length must be at least 4 to use the diverse option!")
        }

        function isValidPassword(password) {
            return (
                allLowerCaseLetters.split("").some(char => password.includes(char)) &&
                allUpperCaseLetters.split("").some(char => password.includes(char)) &&
                allNumbers.split("").some(char => password.includes(char)) &&
                allSpecialChars.split("").some(char => password.includes(char))
            )
        }

        if (isValidPassword(args.c)) {
            let i = 0
            let maxTries = 1000
            for (; i < maxTries; i++) {
                password = generatePassword(args.l, args.c, args.norepeat)
                if (isValidPassword(password))
                    break
            }

            if (i == maxTries) {
                throw new Error("Failed to generate a diverse password! Try increasing the length.")
            }
        } else {
            throw new Error("Could not generate a diverse password!\nThe characters you provided are not diverse enough.")
        }
    }

    terminal.printLine(password)
    if (!args.nocopy) {
        await terminal.copy(password)
        terminal.printLine("Copied to Clipboard ✓")
    }
}, {
    description: "Generate a random password",
    args: {
        "?l=length:i:1~9999": "The length of the password",
        "?c=chars:s": "The characters to use in the password",
        "?norepeat:b": "If present, the password will not repeat characters",
        "?nocopy:b": "Do not copy the password to the clipboard",
        "?d=diverse:b": "Use at least one special character, number, and uppercase letter",
    },
    standardVals: {
        l: 20,
        c: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@%&!?.,;:[]{}()_-+=*",
    }
})



// ------------------- js/commands/pendulum.js --------------------
terminal.addCommand("pendulum", async function(args) {
    args.o /= args.n / 20
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../pendulum-wave/?n=" + encodeURIComponent(args.n) + "&o=" + encodeURIComponent(args.o),
        name: "Pendulum Wave Simulation",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "start a pendulum wave simulation",
    args: {
        "?n:i:1~10000": "number of pendulums",
        "?o:n:0~1": "offset of pendulums",
        "?f=fullscreen:b": "start in fullscreen mode"
    },
    standardVals: {
        n: 20,
        o: 0.025
    }
})

// ------------------- js/commands/perilious-path.js --------------------
terminal.addCommand("perilious-path", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../perilious-path/",
        name: "Perilious Path Game",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "play perilous path",
    isGame: true,
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/physics.js --------------------
terminal.addCommand("physics", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../cloth/",
        name: "Click to add points, Space to simulate",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "start a physics simulation",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/pi-blocks.js --------------------
terminal.addCommand("pi-blocks", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)

    function loadSound(url) {
        return new Promise((resolve, reject) => {
            const audio = terminal.document.createElement("audio")
            audio.src = url
            audio.style.display = "none"
            terminal.parentNode.appendChild(audio)
            audio.addEventListener('canplaythrough', () => resolve(audio), { once: true })
            audio.addEventListener('error', err => {
                reject(err)
            }, { once: true })
        })
    }

    const tickAudios = []
    const numTickAudios = 10
    try {
        for (let i = 0; i < numTickAudios; i++) {
            tickAudios.push(await loadSound("./res/sounds/tick.mp3"))
        }
        terminal.printLine("Loaded audios.")
    } catch (e) {
        console.error(e)
        terminal.printError("Couldn't load audios.")
    }

    let tickSoundIndex = 0
    function tickSound() {
        const audio = tickAudios[(tickSoundIndex++) % numTickAudios]
        if (audio) audio.play()
    }

    let terminalWindow = terminal.modules.window.make({
        name: "Simulathon Challenge Colliding Blocks", fullscreen: true
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const canvasSize = () => new Vector2d(canvas.width, canvas.height)

    let gameRunning = true
    let collisionCount = 0

    const updatesPerFrame = 1000

    terminal.onInterrupt(() => {
        gameRunning = false
        terminalWindow.close()
    })

    function drawBackground() {
        context.fillStyle = "white"
        const size = canvasSize()
        context.fillRect(0, 0, size.x, size.y)
    }

    function worldPosToScreenPos(pos) {
        pos = new Vector2d(pos.x, pos.y * -1)
        const screen = canvasSize()
        pos = pos.add(new Vector2d(0.1, 0.6))
        return new Vector2d(pos.x * screen.x, pos.y * screen.y)
    }

    function drawTextAt(text, pos, size) {
        const fontSize = canvasSize().y * size
        context.font = `${fontSize}px serif`
        const screenPos = worldPosToScreenPos(pos)
        context.textBaseline = "middle"
        context.textAlign = "left"
        context.fillStyle = "black"
        context.fillText(text, screenPos.x, screenPos.y)
    }

    const initialSpeed = 0.0015 * args.speed / updatesPerFrame

    const collisionPoints = []
    const collisionPointSpeeds = []

    class Cube {

        constructor(pos, vel, weight, size, color) {
            this.pos = pos
            this.vel = vel
            this.weight = weight
            this.size = size
            this.color = color
            this.hasCollided = false
        }

        get corners() {
            return [
                this.pos.add(new Vector2d(0, 0)),
                this.pos.add(new Vector2d(this.size.x, 0)),
                this.pos.add(new Vector2d(this.size.x, this.size.y)),
                this.pos.add(new Vector2d(0, this.size.y)),
                this.pos.add(new Vector2d(0, 0)),
            ]
        }

        render() {
            context.fillStyle = this.color
            context.strokeStyle = "black"
            
            context.beginPath()
            let i = 0
            for (const corner of this.corners) {
                const screenPos = worldPosToScreenPos(corner)
                if (i == 0) {
                    context.moveTo(screenPos.x, screenPos.y)
                } else {
                    context.lineTo(screenPos.x, screenPos.y)
                }
                i++
            }
            
            const lastScreenPos = worldPosToScreenPos(this.corners[3])
            context.lineTo(lastScreenPos.x, lastScreenPos.y)

            context.fill()
            context.stroke()
        }

        update(otherCubes) {
            this.pos.iadd(this.vel)
            if (this.pos.x < 0) {
                this.vel.x *= -1
                collisionCount++
                tickSound()
                collisionPoints.push(this.pos.x)
                collisionPointSpeeds.push(this.vel.length)
            }

            for (const cube of otherCubes) {
                if (this.collides(cube)) {
                    this.calcCollision(cube)
                }
            }
        }

        calcCollision(other, e=1.0) {
            if (this.hasCollided) {
                return
            }

            const velPrime = (this.vel.x * (this.weight - e * other.weight) + 2 * other.weight * other.vel.x) / (this.weight + other.weight)
            other.vel.x = (other.vel.x * (other.weight - e * this.weight) + 2 * this.weight * this.vel.x) / (this.weight + other.weight)
            this.vel.x = velPrime

            this.hasCollided = true
            other.hasCollided = true
            collisionCount++
            collisionPoints.push(this.pos.x)
            collisionPointSpeeds.push(this.vel.length)
            tickSound()
        }

        getMinX() {
            return this.pos.x
        }

        getMaxX() {
            return this.pos.x + this.size.x
        }

        collides(otherCube) {
            const minSelfX = this.getMinX()
            const maxSelfX = this.getMaxX()
            const minOtherX = otherCube.getMinX()
            const maxOtherX = otherCube.getMaxX()

            return (minOtherX >= minSelfX && minOtherX <= maxSelfX) || (maxOtherX >= minSelfX && maxOtherX <= maxSelfX) 
        }

    }

    const widthFactor = 1 / (canvasSize().x / canvasSize().y)

    const cubes = [
        new Cube(new Vector2d(0.1, 0), new Vector2d(0, 0), 1, new Vector2d(0.1 * widthFactor, 0.1), "red"),
        new Cube(new Vector2d(0.5, 0), new Vector2d(-initialSpeed, 0), args.factor, new Vector2d(0.2 * widthFactor, 0.2), "blue")
    ]

    const backgroundLines = [
        [new Vector2d(0, 0), new Vector2d(1, 0)],
        [new Vector2d(0, 0), new Vector2d(0, 0.35)]
    ]

    function update() {
        for (const cube of cubes) {
            cube.update(cubes.filter(c => c !== cube))
        }
        for (const cube of cubes) {
            cube.hasCollided = false
        }
    }

    function draw() {
        context.lineWidth = 1

        for (const [start, end] of backgroundLines) {
            const startScreen = worldPosToScreenPos(start)
            const endScreen = worldPosToScreenPos(end)
            context.beginPath()
            context.moveTo(startScreen.x, startScreen.y)
            context.lineTo(endScreen.x, endScreen.y)
            context.strokeStyle = "black"
            context.stroke()
        }

        for (const cube of cubes) {
            cube.render()
        }

        let i = 0
        for (const point of collisionPoints) {
            const start = new Vector2d(point, 0)
            const end = new Vector2d(point, - collisionPointSpeeds[i] * 3000)


            const startScreen = worldPosToScreenPos(start)
            const endScreen = worldPosToScreenPos(end)
            context.beginPath()
            context.moveTo(startScreen.x, startScreen.y)
            context.lineTo(endScreen.x, endScreen.y)
            context.strokeStyle = "red"
            context.stroke()

            i++
        }

        drawTextAt(`${collisionCount} collisions`, new Vector2d(0.015, 0.3), 0.05)
    }

    function loop() {
        drawBackground()
        draw()

        for (let i = 0; i < updatesPerFrame; i++) {
            update()
        }

        if (gameRunning)
            terminal.window.requestAnimationFrame(loop)
    }

    loop()
    while (gameRunning) {
        await terminal.sleep(100)
    }

}, {
    description: "simulate the bouncy blocks from 3b1b",
    args: {
        "f=factor:i": "the factor of the two blocks",
        "?s=speed:n:0~10": "the speed factor"
    },
    defaultValues: {
        speed: 1
    }
})

// ------------------- js/commands/pi.js --------------------
terminal.addCommand("pi", async function(args) {
    if (args.n < 0) {
        throw new Error("number of digits can't be negative")
    }

    if (!args.yes) {
        if (args.n > 100000) {
            await terminal.acceptPrompt("This will take very long to calculate. Continue? ", false)
        } else if (args.n > 10000) {
            await terminal.acceptPrompt("This will take a bit to calculate. Continue?")
        }
    }

    let i = 1n
    let x = 3n * (10n ** (BigInt(args.n - 2) + 20n))
    let pi = x

    while (x > 0) {
        x = x * i / ((i + 1n) * 4n)
        pi += x / (i + 2n)
        i += 2n
    }
    
    const piString = "3." + (pi / (10n ** 20n)).toString().slice(1)

    if (args.unwrap) {
        terminal.printLine(piString)
    } else {
        for (i = 0; i < piString.length; i += 100) {
            terminal.printLine(piString.slice(i, i + 100))
        }
    }

    if (args.copy) {
        await terminal.copy(piString)
        terminal.printLine("\nCopied digits to Clipboard ✓") 
    }
}, {
    description: "calculate pi to the n-th digit",
    args: {
        "?n:i": "the number of digits",
        "?w=unwrap:b": "don't split the digits into lines.",
        "?c=copy:b": "copy the digits to the clipboard",
        "?y=yes:b": "ignore any computation warnings"
    },
    standardVals: {
        n: 100
    }
})




// ------------------- js/commands/piano.js --------------------
const asciiPiano = `+-+---+---+-+-+---+---+---+-+-+---+---+-+
| | C | D | | | F | G | A | | | C | D | |
| | # | # | | | # | # | # | | | # | # | |
| |   |   | | |   |   |   | | |   |   | |
| | q | w | | | r | t | z | | | i | o | |
| +---+---+ | +---+---+---+ | +---+---+ |
|   |   |   |   |   |   |   |   |   |   |
| C | D | E | F | G | A | H | C | D | E |
|   |   |   |   |   |   |   |   |   |   |
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 |
+---+---+---+---+---+---+---+---+---+---+
      < Press keys to play notes. >      
      
Star Wars (Main Theme):   1 5 4-3-2 8 5 4-3-2 8 5 4-3-4-2
Star Wars (Force Theme):  36 7 8-9-8 3 3-6 7 8 3 8 6 0 9
Happy Birthday:           112143 112154 1186432 zz6454
Avengers Theme:           2 22 65 4 3 2, 22 67 5 6
Twinkle Twinkle:          1 1 5 5 6 6 5, 4 4 3 3 2 2 1
Harry Potter:             36 876 09 7 6 875 z3
Shrek Intro (All Star):   r i-zztrr 7-zzttrr izztrrtw
Country Roads:            123 312 321 356 6553 2123 211 121
Despacito:
  8 7 63 3333 6666 6564 4444 66667 8 5 5555 888 99 7 8 7 6 3
Disney's Up Theme:
  4643 4632 2421 265 265 4-2 4543 3531 8-0-8-7
USSR Anthem:
  8 58 567 336 545 11 2 234 456 789
  550 989 558 767 336 545 118 7650`

terminal.addCommand("piano", async function(args) {
    const notesToUrl = {
        "C": "https://carolinegabriel.com/demo/js-keyboard/sounds/040.wav",
        "C#": "https://carolinegabriel.com/demo/js-keyboard/sounds/041.wav",
        "D": "https://carolinegabriel.com/demo/js-keyboard/sounds/042.wav",
        "D#": "https://carolinegabriel.com/demo/js-keyboard/sounds/043.wav",
        "E": "https://carolinegabriel.com/demo/js-keyboard/sounds/044.wav",
        "F": "https://carolinegabriel.com/demo/js-keyboard/sounds/045.wav",
        "F#": "https://carolinegabriel.com/demo/js-keyboard/sounds/046.wav",
        "G": "https://carolinegabriel.com/demo/js-keyboard/sounds/047.wav",
        "G#": "https://carolinegabriel.com/demo/js-keyboard/sounds/048.wav",
        "A": "https://carolinegabriel.com/demo/js-keyboard/sounds/049.wav",
        "A#": "https://carolinegabriel.com/demo/js-keyboard/sounds/050.wav",
        "H": "https://carolinegabriel.com/demo/js-keyboard/sounds/051.wav",
        "C2": "https://carolinegabriel.com/demo/js-keyboard/sounds/052.wav",
        "C2#": "https://carolinegabriel.com/demo/js-keyboard/sounds/053.wav",
        "D2": "https://carolinegabriel.com/demo/js-keyboard/sounds/054.wav",
        "D2#": "https://carolinegabriel.com/demo/js-keyboard/sounds/055.wav",
        "E2": "https://carolinegabriel.com/demo/js-keyboard/sounds/056.wav",
        "F2": "https://carolinegabriel.com/demo/js-keyboard/sounds/057.wav",
    }

    const audioElements = {}
    for (let note in notesToUrl) {
        audioElements[note] = new Audio(notesToUrl[note])
        audioElements[note].preload = true
    }

    const keysToNotes = {
        "1": "C", "q": "C#", "2": "D", "w": "D#", "3": "E",
        "4": "F", "r": "F#", "5": "G", "t": "G#", "6": "A",
        "z": "A#", "7": "H", "8": "C2", "i": "C2#", "9": "D2",
        "o": "D2#", "0": "E2",
    }

    let running = true
    terminal.onInterrupt(() => running = false)

    terminal.printLine(asciiPiano)
    terminal.scroll()

    terminal.document.addEventListener("keydown", function(event) {
        if (!running) return
        if (event.repeat) return
        if (event.key in keysToNotes) {
            // play even if already playing
            let note = keysToNotes[event.key]
            let audioElement = audioElements[note]
            audioElement.currentTime = 0
            audioElement.play()
        }
    })

    while (running) {
        await sleep(100)
    }
}, {
    description: "play a piano with your keyboard"
})

// ------------------- js/commands/plane.js --------------------
terminal.addCommand("plane", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../flugzeug-spiel/",
        name: "Plane Game",
        fullscreen: args.fullscreen
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(100)
}, {
    description: "play the plane game",
    args: {
        "?f=fullscreen:b": "open in fullscreen mode"
    },
    isGame: true
})

// ------------------- js/commands/plot.js --------------------
terminal.addCommand("plot", async function(args) {
    await terminal.modules.load("mathenv", terminal)

    let equation = args.equation
    if (!/^[0-9x\s\\\*\.a-z+-\^\(\)]+$/.test(equation)) {
        terminal.printError("Invalid equation")
        terminal.printLine("Only numbers, x, *, +, -, ^, (, ), \\ and spaces are allowed")
        return
    }
    let gridSize = {
        x: 67,
        y: 30
    }
    while (/[0-9]x/g.test(equation))
        equation = equation.replace(/([0-9])x/g, "$1*x")
    while (/[0-9a-z\.]+\s*\^\s*[0-9a-z\.]+/g.test(equation))
        equation = equation.replace(/([0-9a-z\.]+)\s*\^\s*([0-9a-z\.]+)/g, "$1**$2")
    let jsEnv = await terminal.modules.load("mathenv", terminal)
    let grid = Array.from(Array(gridSize.y)).map(() => Array(gridSize.x).fill(" "))
    let viewBound = {
        x: {min: args.xmin, max: args.xmax},
        y: {min: args.ymin, max: args.ymax}
    }
    if (viewBound.x.min >= viewBound.x.max || viewBound.y.min >= viewBound.y.max) {
        terminal.printError("Invalid bounds!")
        return
    }

    function drawIntoGrid(x, y, v) {
        if (isNaN(x) || isNaN(y)) return
        let gridX = Math.round((x - viewBound.x.min) / (viewBound.x.max - viewBound.x.min) * (gridSize.x - 1))
        let gridY = Math.round((y - viewBound.y.min) / (viewBound.y.max - viewBound.y.min) * (gridSize.y - 1))
        if (gridX < 0 || gridX >= gridSize.x || gridY < 0 || gridY >= gridSize.y) {
            return
        }
        grid[gridSize.y - 1 - gridY][gridX] = v
    }
    async function drawGrid() {
        let tempText = ""
        let tempColor = new Color(-1, -1, -1)
        for (let y = 0; y < gridSize.y; y++) {
            for (let x = 0; x < gridSize.x; x++) {
                let color = Color.WHITE
                switch(grid[y][x]) {
                    case ".":
                        color = Color.rgb(100, 100, 100)
                        break
                    case "/":
                    case "#":
                    case "\\":
                    case "]":
                    case "[":
                        color = Color.COLOR_1
                }
                if (tempColor.eq(color)) {
                    tempText += grid[y][x]
                } else {
                    if (tempText) {
                        terminal.print(tempText, tempColor)
                    }
                    tempText = grid[y][x]
                    tempColor = color
                }
            }
            if (tempText) {
                terminal.print(tempText, tempColor)
                tempText = ""
            }
            terminal.printLine()
        }
    }
    for (let y = viewBound.y.min; y <= viewBound.y.max; y += (viewBound.y.max - viewBound.y.min) / (gridSize.y - 1)) {
        drawIntoGrid(0, y, "|")
    }
    for (let x = viewBound.x.min; x <= viewBound.x.max; x += (viewBound.x.max - viewBound.x.min) / (gridSize.x - 1)) {
        drawIntoGrid(x, 0, "~")
    }
    for (let x = ~~(viewBound.x.min); x < viewBound.x.max; x++) {
        let axisVal = (String(x).length > 1) ? String(x).slice(-1) : String(x)
        for (let y = viewBound.y.min; y <= viewBound.y.max; y += (viewBound.y.max - viewBound.y.min) / (gridSize.y - 1)) {
            if (x == 0) break
            drawIntoGrid(x, y, ".")
        }
        drawIntoGrid(x, 0, axisVal)
    }
    for (let y = ~~(viewBound.y.min); y < viewBound.y.max; y++) {
        let axisVal = (String(y).length > 1) ? String(y).slice(-1) : String(y)
        for (let x = viewBound.x.min; x <= viewBound.x.max; x += (viewBound.x.max - viewBound.x.min) / (gridSize.x - 1)) {
            if (y == 0) break
            drawIntoGrid(x, y, ".")
        }
        drawIntoGrid(0, y, axisVal)
    }
    drawIntoGrid(0, 0, "+")

    function f(x) {
        terminal.modules.mathenv.setValue("x", x)
        let [result, error] = terminal.modules.mathenv.eval(equation)
        if (error) {
            terminal.printError(error)
            return
        } else {
            return result
        }
    }

    function slope(f, x, accuracy=0.01) {
        let minY = f(x - accuracy)
        let maxY = f(x + accuracy)
        let diff = maxY - minY
        return diff / (accuracy * 2)
    }
    const symbols = [
        ["]", 10],
        ["/", 1.5],
        ["#", -1.5],
        ["\\", -10],
        ["[", -Infinity],
    ]
    let yValues = []
    for (let x = viewBound.x.min; x <= viewBound.x.max; x += (viewBound.x.max - viewBound.x.min) / (gridSize.x - 1) / 5) {
        terminal.modules.mathenv.setValue("x", x)
        let [y, error] = terminal.modules.mathenv.eval(equation)
        if (error) {
            throw new Error(error)
        } else {
            let printSymbol = null
            let slopeVal = slope(f, x)
            for (let [symbol, minVal] of symbols) {
                if (slopeVal > minVal) {
                    printSymbol = symbol
                    break
                }
            }
            if (!isNaN(y))
                yValues.push(y)
            if (printSymbol != null)
                drawIntoGrid(x, y, printSymbol)
        }
    }
    await drawGrid()
    terminal.scroll()
    let playTime = args.playtime * 2
    function calcFrequency(y) {
        let maxFreq = 1000
        let minFreq = 200
        let yDiffBound = viewBound.y.max - viewBound.y.min
        let yDiffMin = y - viewBound.y.min
        let freqDiff = maxFreq - minFreq
        let freq = freqDiff * (yDiffMin / yDiffBound)
        return freq
    }
    let frequencies = []
    for (let y of yValues) {
        let frequency = calcFrequency(y)
        frequency = Math.max(50, frequency)
        frequency = Math.min(20000, frequency)
        frequencies.push(frequency)
    }
    let noteTime = playTime / frequencies.length
    for (let note of frequencies) {
        playFrequency(note, noteTime)
        await sleep(noteTime * 0.5)
    }
}, {
    description: "plot a mathematical function within bounds",
    args: {
        "equation": "the equation to plot",
        "?xmin:n:-1000~1000": "the minimum x value",
        "?xmax:n:-1000~1000": "the maximum x value",
        "?ymin:n:-1000~1000": "the minimum y value",
        "?ymax:n:-1000~1000": "the maximum y value",
        "?playtime:i:0~10000": "the time to play the sound for in milliseconds"
    },
    standardVals: {
        xmin: -3, xmax: 3.1,
        ymin: -3, ymax: 3.1,
        playtime: 2500
    }
})

// ------------------- js/commands/plotter.js --------------------
terminal.addCommand("plotter", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../plot/",
        name: "Function Plotter",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
    while (1) await sleep(1000)
}, {
    description: "plot mathematical functions",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/polyrythm.js --------------------
terminal.addCommand("polyrythm", async function(args) {
    if (!args.numbers.match(/^(?:\d+\s)*\d+$/)) {
        terminal.printLine(`Example Use: "polyrythm 3 4 5"`)
        throw new Error("Invalid Numbers Format.")
    }

    let polyrythms = args.numbers.split(" ").map(s => parseInt(s))
    let polyrythmPrevSideProgress = polyrythms.map(() => 0)

    polyrythms.forEach(n => {
        if (n < 2) {
            throw new Error("Polyrythm cannot consist of numbers lower than 2")
        }
    })

    await terminal.modules.import("game", window)

    const canvas = printSquareCanvas({widthChars: 50})
    const context = canvas.getContext("2d")

    const canvasSize = new Vector2d(canvas.width, canvas.height)

    function circlePos(alpha, {
        radius=canvasSize.min * 0.4,
        offset=canvasSize.scale(0.5),
        applyOffset=true
    }={}) {
        alpha += Math.PI
        return new Vector2d(
            Math.sin(alpha) * radius + offset.x * applyOffset,
            Math.cos(alpha) * radius + offset.y * applyOffset
        )
    }

    function fillCircle(position, {
        radius=10,
    }={}) {
        context.beginPath()
        context.moveTo(...position.array)
        context.arc(...position.array, radius, 0, Math.PI * 2)
        context.fill()
    }

    function positionOnPolygon(numCorners, t) {
        let scaledT = t * numCorners
        let sideProgress = scaledT % 1
        let corner1Angle = Math.floor(scaledT) / numCorners * 2 * Math.PI
        let corner2Angle = Math.ceil(scaledT) / numCorners * 2 * Math.PI
        let corner1Pos = circlePos(corner1Angle)
        let corner2Pos = circlePos(corner2Angle)
        return [corner1Pos.lerp(corner2Pos, sideProgress), sideProgress]
    }

    function strokePolygon(numCorners) {
        context.beginPath()
        for (let i = 0; i <= numCorners; i++) {
            let alpha = i / numCorners * 2 * Math.PI
            let position = circlePos(alpha)
            if (i == 0) {
                context.moveTo(...position.array)
            } else {
                context.lineTo(...position.array)
            }
        }
        context.stroke()
    }

    context.strokeStyle = "white"
    context.fillStyle = "white"
    context.lineWidth = 2

    const startTime = Date.now()
    
    function frequencyFromNoteOffset(n) {
        return 220.0 * 2 ** (n / 12)
    }

    const notePlayers = polyrythms.map((_, index) => {
        const context = new AudioContext()
        const osc = context.createOscillator()
        const gain = context.createGain()

        osc.connect(gain)
        gain.connect(context.destination)

        osc.frequency.value = frequencyFromNoteOffset(index * 2 + 8)
        osc.start()
        terminal.onInterrupt(() => osc.stop())

        gain.gain.setValueAtTime(0, context.currentTime)

        return () => {
            gain.gain.setValueAtTime(1, context.currentTime)
            gain.gain.exponentialRampToValueAtTime(0.001, context.currentTime + 2)
        }
    })

    let running = true

    function redraw() {
        context.clearRect(0, 0, canvas.width, canvas.height)

        let t = ((Date.now() - startTime) % args.time) / args.time

        for (let i = 0; i < polyrythms.length; i++) {
            let corners = polyrythms[i]
            
            strokePolygon(corners)
            let [position, sideProgress] = positionOnPolygon(corners, t)
            let deltaSideProgress = Math.abs(sideProgress - polyrythmPrevSideProgress[i])
            fillCircle(position)

            if (deltaSideProgress > 0.5) {
                notePlayers[i]()
            }

            polyrythmPrevSideProgress[i] = sideProgress
        }

        if (running)
            requestAnimationFrame(redraw)
    }

    redraw()
    
    terminal.onInterrupt(() => running = false)

    terminal.scroll()

    while (running) {
        await sleep(1000)
    }
}, {
    description: "creates a polyrythm",
    args: {
        "*numbers": "numbers (e.g. \"3 4 5\")",
        "?t=time:n:10~99999": "time in miliseconds for full rotation",
    },
    defaultValues: {
        time: 4000
    }
})

// ------------------- js/commands/pong.js --------------------
terminal.addCommand("pong", async function(args) {
    await terminal.modules.import("game", window)

    let fieldSize = new Vector2d(35, 20)
    let elements = []
    terminal.printLine(" " + "_".repeat(fieldSize.x * 2 + 1) + " ")
    for (let y = 0; y < fieldSize.y; y++) {
        let elementRow = []
        terminal.print("| ")
        for (let x = 0; x < fieldSize.x; x++) {
            let element = terminal.print(" ", undefined, {forceElement: true})
            element.style.transition = "none"
            terminal.print(" ")
            elementRow.push(element)
        }
        terminal.print("|")
        terminal.addLineBreak()
        elements.push(elementRow)
    }

    terminal.printLine("+" + "-".repeat(fieldSize.x * 2 + 1) + "+")
    terminal.print("| Player-score: ")
    let playerScoreOutput = terminal.print("0")
    terminal.printLine(" | Move your paddle using the arrow keys! |")
    terminal.print("| Enemy-score:  ")
    let enemyScoreOutput = terminal.print("0")
    terminal.printLine(" |----------------------------------------+")
    terminal.printLine("+-----------------+")
    
    let paddleWidth = 5
    let playerPaddlePos = Math.floor(fieldSize.y / 2 - paddleWidth / 2)
    let enemyPaddlePos = 0
    
    let ballColor = "white"
    
    function drawPaddle(x, pos) {
        for (let y = 0; y < fieldSize.y; y++) {
            if (y >= pos && y <= pos + paddleWidth) {
                elements[y][x].textContent = "#"
                elements[y][x].style.color = Color.WHITE
            } else {
                elements[y][x].textContent = " "
            }
        }
    }
    
    function drawPaddles() {
        drawPaddle(0, playerPaddlePos)
        drawPaddle(fieldSize.x - 1, enemyPaddlePos)
    }
    
    let possibleBallRot = [
        Math.PI / 4 * 1,
        Math.PI / 4 * 3,
        Math.PI / 4 * 5,
        Math.PI / 4 * 7
    ]
    
    let ballPos = new Vector2d(fieldSize.x / 2, fieldSize.y / 2)
    let ballVel = Vector2d.fromAngle(possibleBallRot[Math.floor(Math.random() * possibleBallRot.length)])
    ballVel.iscale(0.5)
    
    function resetBall() {
        ballPos = new Vector2d(fieldSize.x / 2, fieldSize.y / 2)
        ballVel = Vector2d.fromAngle(possibleBallRot[Math.floor(Math.random() * possibleBallRot.length)])
        ballVel.iscale(0.5)
    }
    
    function touchesPaddle(x, y) {
        let playerPaddleEnd = playerPaddlePos + paddleWidth
        let enemyPaddleEnd = enemyPaddlePos + paddleWidth
        if (x == 0 && y >= playerPaddlePos && y <= playerPaddleEnd)
            return "player"
        if (x == fieldSize.x - 1 && y >= enemyPaddlePos && y <= enemyPaddleEnd)
            return "enemy"
        return false
    }
    
    let gameRunning = true
    
    let listener = addEventListener("keydown", event => {
        if (!gameRunning) return
        if (event.key == "c" && event.ctrlKey) {
            removeEventListener("keydown", listener)
            gameRunning = false
        }
        if (event.key == "ArrowUp") {
            playerPaddlePos = Math.max(0, playerPaddlePos - 1)
            event.preventDefault()
        } else if (event.key == "ArrowDown") {
            playerPaddlePos = Math.min(playerPaddlePos + 1, fieldSize.y - paddleWidth - 1)
            event.preventDefault()
        }
        drawPaddles()
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout([
            ["↑"],
            ["↓"],
            ["STRG+C"]
        ])

        let goingUp = false
        let goingDown = false

        terminal.mobileKeyboard.onkeydown = (e, keyCode) => {
            if (keyCode == "ArrowUp") {
                goingUp = true
            } else if (keyCode == "ArrowDown") {
                goingDown = true
            }
        }

        terminal.mobileKeyboard.onkeyup = (e, keyCode) => {
            if (keyCode == "ArrowUp") {
                goingUp = false
            } else if (keyCode == "ArrowDown") {
                goingDown = false
            }
        }

        function loop() {
            if (goingUp) {
                playerPaddlePos = Math.max(0, playerPaddlePos - 1)
            } else if (goingDown) {
                playerPaddlePos = Math.min(playerPaddlePos + 1, fieldSize.y - paddleWidth - 1)
            }
            drawPaddles()
        }

        setInterval(loop, 1000 / 30)
    }
    
    let playerScore = 0
    let enemyScore = 0
    
    function updateBall() {
        let x = Math.max(0, Math.min(Math.floor(ballPos.x), fieldSize.x - 1))
        let y = Math.max(0, Math.min(Math.floor(ballPos.y), fieldSize.y - 1))
        elements[y][x].textContent = " "
        elements[y][x].style.color = Color.WHITE
        ballPos.x += ballVel.x
        ballPos.y += ballVel.y
        x = Math.floor(ballPos.x)
        y = Math.floor(ballPos.y)
        
        if (y < 0 || y >= fieldSize.y) {
            ballVel.y *= -1
            ballPos.y += ballVel.y
        }
        
        x = Math.max(0, Math.min(x, fieldSize.x - 1))
        y = Math.max(0, Math.min(y, fieldSize.y - 1))
        
        if (touchesPaddle(x, y)) {
            ballVel.x *= -1
            ballPos.x += ballVel.x
            ballVel.iscale(1.1)
            ballColor = Color.random()
        } else if (x == 0) {
            enemyScore++
            resetBall()
            updateScoreBoard()
        } else if (x == fieldSize.x - 1) {
            playerScore++
            resetBall()
            updateScoreBoard()
        }
        
        elements[y][x].style.color = ballColor
        elements[y][x].textContent = "#"
    }
    
    function updateScoreBoard() {
        playerScoreOutput.textContent = stringPad(playerScore, 1, "0")
        enemyScoreOutput.textContent = stringPad(enemyScore, 1, "0")
    }
    
    function moveEnemy() {
        if (Math.random() < 0.5) return
        let diff = Math.floor(ballPos.y) - (enemyPaddlePos + Math.floor(paddleWidth / 2))
        if (diff < 0) {
            enemyPaddlePos -= 1
        } else if (diff > 0) {
            enemyPaddlePos += 1
        }
        enemyPaddlePos = Math.max(0, Math.min(enemyPaddlePos, fieldSize.y - paddleWidth - 1))
    }
    
    terminal.scroll()
    
    while (gameRunning) {
        let startIterationTime = Date.now()
        drawPaddles()
        updateBall()
        moveEnemy()
        let iterationTime = Date.now() - startIterationTime
        await sleep(30 - iterationTime)
        
        if (Math.max(enemyScore, playerScore) >= 3) {
            gameRunning = false
        }
    }
    
    removeEventListener("keydown", listener)
    terminal.addLineBreak()
    
    if (enemyScore > playerScore) {
        terminal.printLine("You lost to the enemy! Sorry!")
    } else {
        terminal.printLine("You won against the enemy! Congratulations!")
    }
    
}, {
    description: "play a game of pong against the computer",
    isGame: true
})

// ------------------- js/commands/primes.js --------------------
terminal.addCommand("primes", async function() {
    function newtonSqrtIteration(n, x0) {
        const x1 = ((n / x0) + x0) >> 1n;
        if (x0 === x1 || x0 === (x1 - 1n)) {
            return x0;
        }
        return newtonSqrtIteration(n, x1);
    }

    function fastSqrt(value) {
        if (value < 0n) {
            throw 'square root of negative numbers is not supported'
        }
    
        if (value < 2n) {
            return value;
        }
    
        return newtonSqrtIteration(value, 1n);
    }

    function isPrime(n) {
        if (n < 2n)
            return false
        if (n === 2n)
            return true
        if (n % 2n === 0n)
            return false
        const upperLimit = fastSqrt(n)
        for (let i = 3n; i <= upperLimit; i += 2n) {
            if (n % i === 0n)
                return false
        }
        return true
    }

    async function lucasLehmerTest(p, n) {
        let s = 4n
        for (let i = 0n; i < p - 2n; i++) {
            s = (s ** 2n - 2n) % n
        }
        return s === 0n
    }

    terminal.printLine("Press enter to generate the next mersenne prime.")

    for (let p = 0n; p < 10000n; p++) {
        if (!isPrime(p))
            continue
        const n = 2n ** p - 1n
        if (await lucasLehmerTest(p, n)) {
            terminal.print(`(2^${p}-1) ${n}`)
            await terminal.prompt("", {printInputAfter: false})
            terminal.addLineBreak()
        }
        await sleep(0)
    }
}, {
    description: "generate mersenne primes"
})

// ------------------- js/commands/pull.js --------------------
terminal.addCommand("pull", async function(args) {
    if (terminal.fileExists(args.file))
        throw new Error("file already exists in folder")

    if (!terminal.isValidFileName(args.file))
        throw new Error("invalid file name")
    await terminal.modules.load("cliapi", terminal)
    let content = await terminal.modules.cliapi.pullFile(args.file)
    if (content == "undefined") {
        throw new Error("file does not exist on server")
    }

    try {
        let file = TerminalFile.fromObject(JSON.parse(content)).setName(args.file)
        terminal.currDirectory.addChild(file)
        terminal.printSuccess("pulled file from server")
    } catch (e) {
        console.error(e)
        throw new Error("pulled file is not a valid file")
    }
}, {
    description: "pull a file from the server",
    args: {
        "file": "file to pull"
    }
})

// ------------------- js/commands/push.js --------------------
terminal.addCommand("push", async function(args) {
    if (!terminal.isValidFileName(args.file))
        throw new Error("invalid file name")
    let file = terminal.getFile(args.file)
    let content = JSON.stringify(file.toObject())

    await terminal.modules.load("cliapi", terminal)
    let result = await terminal.modules.cliapi.pushFile(file.name, content)
    if (result.ok) {
        terminal.printSuccess("pushed file to server")
    } else {
        throw new Error(result.error)
    }
}, {
    description: "push a file to the server",
    args: {
        "file:f": "file to push"
    }
})

// ------------------- js/commands/pv.js --------------------
terminal.addCommand("pv", async function(args) {
    await terminal.animatePrint(args.message)
}, {
    description: "print a message with a typing animation",
    args: ["*message"]
})



// ------------------- js/commands/pwd.js --------------------
terminal.addCommand("pwd", function() {
    terminal.printLine("/" + terminal.fileSystem.pathStr)
}, {
    description: "print the current working directory"
})



// ------------------- js/commands/python.js --------------------
terminal.addCommand("python", async function(args) {
    if (args.file)
        terminal.getFile(args.file)

    if (!terminal.modules.pyscript) {
        terminal.printLine("Initializing Python...")
        await terminal.modules.load("pyscript", terminal)
        await terminal.modules.pyscript.load()
        terminal.modules.pyscript.history = []
    }

    function escapeJsCodeToPythonCode(code) {
        return code
            .replaceAll("\"", "\\\"")
    }

    const runInterpreter = async () => {
        const pyodide = terminal.modules.pyscript.pyodide
        let version = pyodide.runPython("import sys; sys.version").split("[")
        terminal.printLine(`Python ${version[0]}`)

        let shiftPressed = false
        terminal.window.addEventListener("keydown", (e) => {
            if (e.key === "Shift") {
                shiftPressed = true
            }
        })
        terminal.window.addEventListener("keyup", (e) => {
            if (e.key === "Shift") {
                shiftPressed = false
            }
        })

        while (true) {
            try {
                let pythonPrompt = ""
                let result = null

                while (pythonPrompt === "" || shiftPressed) {
                    let promptStart = (pythonPrompt === "") ? ">>> " : "... "
                    pythonPrompt += await terminal.prompt(promptStart, {
                        addToHistory: item => terminal.modules.pyscript.history.push(item),
                        getHistory: () => terminal.modules.pyscript.history,
                        inputCleaning: false,
                        inputSuggestions: false
                    })
                }

                if (pythonPrompt.includes('"""')) {
                    terminal.printLine("SyntaxError: \"\"\" cannot be used in the interpreter. Try ''' instead.")
                    continue
                }

                if (pythonPrompt === "exit()" || pythonPrompt === "quit()" || pythonPrompt === "exit" || pythonPrompt === "quit")
                    break

                let injectedCode = escapeJsCodeToPythonCode(pythonPrompt)                

                let code = `
                try:
                    _ = eval("""${injectedCode}""")
                    if _ is not None:
                        print(repr(_))
                except Exception as e:
                    exec("""${injectedCode}""")
                    _ = None`

                console.log(code)

                pyodide.runPython(code)
            } catch (pythonError) {
                terminal.printLine(pythonError)
            }
        }
    }

    if (args.file) {
        let file = terminal.getFile(args.file)
        if (file.isDirectory) {
            throw new Error("Cannot run a directory")
        }
        let code = file.content
        terminal.modules.pyscript.pyodide.runPython(code)
        return
    }

    
    if (args.code) {
        terminal.modules.pyscript.pyodide.runPython(`
        _ = eval("""${escapeJsCodeToPythonCode(args.code)}""")
        if _ is not None:
            print(repr(_))
        `)
        return
    }

    await runInterpreter()

}, {
    description: "run a script or open a python shell",
    args: {
        "?f=file:f": "the script to run",
        "?c=code:s": "the code to run"
    },
    disableEqualsArgNotation: true
})

// ------------------- js/commands/qr.js --------------------
/**
 * @fileoverview
 * - Using the 'QRCode for Javascript library'
 * - Fixed dataset of 'QRCode for Javascript library' for support full-spec.
 * - this library has no dependencies.
 * 
 * @author davidshimjs
 * @see <a href="http://www.d-project.com/" target="_blank">http://www.d-project.com/</a>
 * @see <a href="http://jeromeetienne.github.com/jquery-qrcode/" target="_blank">http://jeromeetienne.github.com/jquery-qrcode/</a>
 */
var QRCode;

(function () {
	//---------------------------------------------------------------------
	// QRCode for JavaScript
	//
	// Copyright (c) 2009 Kazuhiko Arase
	//
	// URL: http://www.d-project.com/
	//
	// Licensed under the MIT license:
	//   http://www.opensource.org/licenses/mit-license.php
	//
	// The word "QR Code" is registered trademark of 
	// DENSO WAVE INCORPORATED
	//   http://www.denso-wave.com/qrcode/faqpatent-e.html
	//
	//---------------------------------------------------------------------
	function QR8bitByte(data) {
		this.mode = QRMode.MODE_8BIT_BYTE;
		this.data = data;
		this.parsedData = [];

		// Added to support UTF-8 Characters
		for (var i = 0, l = this.data.length; i < l; i++) {
			var byteArray = [];
			var code = this.data.charCodeAt(i);

			if (code > 0x10000) {
				byteArray[0] = 0xF0 | ((code & 0x1C0000) >>> 18);
				byteArray[1] = 0x80 | ((code & 0x3F000) >>> 12);
				byteArray[2] = 0x80 | ((code & 0xFC0) >>> 6);
				byteArray[3] = 0x80 | (code & 0x3F);
			} else if (code > 0x800) {
				byteArray[0] = 0xE0 | ((code & 0xF000) >>> 12);
				byteArray[1] = 0x80 | ((code & 0xFC0) >>> 6);
				byteArray[2] = 0x80 | (code & 0x3F);
			} else if (code > 0x80) {
				byteArray[0] = 0xC0 | ((code & 0x7C0) >>> 6);
				byteArray[1] = 0x80 | (code & 0x3F);
			} else {
				byteArray[0] = code;
			}

			this.parsedData.push(byteArray);
		}

		this.parsedData = Array.prototype.concat.apply([], this.parsedData);

		if (this.parsedData.length != this.data.length) {
			this.parsedData.unshift(191);
			this.parsedData.unshift(187);
			this.parsedData.unshift(239);
		}
	}

	QR8bitByte.prototype = {
		getLength: function (buffer) {
			return this.parsedData.length;
		},
		write: function (buffer) {
			for (var i = 0, l = this.parsedData.length; i < l; i++) {
				buffer.put(this.parsedData[i], 8);
			}
		}
	};

	function QRCodeModel(typeNumber, errorCorrectLevel) {
		this.typeNumber = typeNumber;
		this.errorCorrectLevel = errorCorrectLevel;
		this.modules = null;
		this.moduleCount = 0;
		this.dataCache = null;
		this.dataList = [];
	}

	QRCodeModel.prototype={addData:function(data){var newData=new QR8bitByte(data);this.dataList.push(newData);this.dataCache=null;},isDark:function(row,col){if(row<0||this.moduleCount<=row||col<0||this.moduleCount<=col){throw new Error(row+","+col);}
	return this.modules[row][col];},getModuleCount:function(){return this.moduleCount;},make:function(){this.makeImpl(false,this.getBestMaskPattern());},makeImpl:function(test,maskPattern){this.moduleCount=this.typeNumber*4+17;this.modules=new Array(this.moduleCount);for(var row=0;row<this.moduleCount;row++){this.modules[row]=new Array(this.moduleCount);for(var col=0;col<this.moduleCount;col++){this.modules[row][col]=null;}}
	this.setupPositionProbePattern(0,0);this.setupPositionProbePattern(this.moduleCount-7,0);this.setupPositionProbePattern(0,this.moduleCount-7);this.setupPositionAdjustPattern();this.setupTimingPattern();this.setupTypeInfo(test,maskPattern);if(this.typeNumber>=7){this.setupTypeNumber(test);}
	if(this.dataCache==null){this.dataCache=QRCodeModel.createData(this.typeNumber,this.errorCorrectLevel,this.dataList);}
	this.mapData(this.dataCache,maskPattern);},setupPositionProbePattern:function(row,col){for(var r=-1;r<=7;r++){if(row+r<=-1||this.moduleCount<=row+r)continue;for(var c=-1;c<=7;c++){if(col+c<=-1||this.moduleCount<=col+c)continue;if((0<=r&&r<=6&&(c==0||c==6))||(0<=c&&c<=6&&(r==0||r==6))||(2<=r&&r<=4&&2<=c&&c<=4)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}},getBestMaskPattern:function(){var minLostPoint=0;var pattern=0;for(var i=0;i<8;i++){this.makeImpl(true,i);var lostPoint=QRUtil.getLostPoint(this);if(i==0||minLostPoint>lostPoint){minLostPoint=lostPoint;pattern=i;}}
	return pattern;},createMovieClip:function(target_mc,instance_name,depth){var qr_mc=target_mc.createEmptyMovieClip(instance_name,depth);var cs=1;this.make();for(var row=0;row<this.modules.length;row++){var y=row*cs;for(var col=0;col<this.modules[row].length;col++){var x=col*cs;var dark=this.modules[row][col];if(dark){qr_mc.beginFill(0,100);qr_mc.moveTo(x,y);qr_mc.lineTo(x+cs,y);qr_mc.lineTo(x+cs,y+cs);qr_mc.lineTo(x,y+cs);qr_mc.endFill();}}}
	return qr_mc;},setupTimingPattern:function(){for(var r=8;r<this.moduleCount-8;r++){if(this.modules[r][6]!=null){continue;}
	this.modules[r][6]=(r%2==0);}
	for(var c=8;c<this.moduleCount-8;c++){if(this.modules[6][c]!=null){continue;}
	this.modules[6][c]=(c%2==0);}},setupPositionAdjustPattern:function(){var pos=QRUtil.getPatternPosition(this.typeNumber);for(var i=0;i<pos.length;i++){for(var j=0;j<pos.length;j++){var row=pos[i];var col=pos[j];if(this.modules[row][col]!=null){continue;}
	for(var r=-2;r<=2;r++){for(var c=-2;c<=2;c++){if(r==-2||r==2||c==-2||c==2||(r==0&&c==0)){this.modules[row+r][col+c]=true;}else{this.modules[row+r][col+c]=false;}}}}}},setupTypeNumber:function(test){var bits=QRUtil.getBCHTypeNumber(this.typeNumber);for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[Math.floor(i/3)][i%3+this.moduleCount-8-3]=mod;}
	for(var i=0;i<18;i++){var mod=(!test&&((bits>>i)&1)==1);this.modules[i%3+this.moduleCount-8-3][Math.floor(i/3)]=mod;}},setupTypeInfo:function(test,maskPattern){var data=(this.errorCorrectLevel<<3)|maskPattern;var bits=QRUtil.getBCHTypeInfo(data);for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<6){this.modules[i][8]=mod;}else if(i<8){this.modules[i+1][8]=mod;}else{this.modules[this.moduleCount-15+i][8]=mod;}}
	for(var i=0;i<15;i++){var mod=(!test&&((bits>>i)&1)==1);if(i<8){this.modules[8][this.moduleCount-i-1]=mod;}else if(i<9){this.modules[8][15-i-1+1]=mod;}else{this.modules[8][15-i-1]=mod;}}
	this.modules[this.moduleCount-8][8]=(!test);},mapData:function(data,maskPattern){var inc=-1;var row=this.moduleCount-1;var bitIndex=7;var byteIndex=0;for(var col=this.moduleCount-1;col>0;col-=2){if(col==6)col--;while(true){for(var c=0;c<2;c++){if(this.modules[row][col-c]==null){var dark=false;if(byteIndex<data.length){dark=(((data[byteIndex]>>>bitIndex)&1)==1);}
	var mask=QRUtil.getMask(maskPattern,row,col-c);if(mask){dark=!dark;}
	this.modules[row][col-c]=dark;bitIndex--;if(bitIndex==-1){byteIndex++;bitIndex=7;}}}
	row+=inc;if(row<0||this.moduleCount<=row){row-=inc;inc=-inc;break;}}}}};QRCodeModel.PAD0=0xEC;QRCodeModel.PAD1=0x11;QRCodeModel.createData=function(typeNumber,errorCorrectLevel,dataList){var rsBlocks=QRRSBlock.getRSBlocks(typeNumber,errorCorrectLevel);var buffer=new QRBitBuffer();for(var i=0;i<dataList.length;i++){var data=dataList[i];buffer.put(data.mode,4);buffer.put(data.getLength(),QRUtil.getLengthInBits(data.mode,typeNumber));data.write(buffer);}
	var totalDataCount=0;for(var i=0;i<rsBlocks.length;i++){totalDataCount+=rsBlocks[i].dataCount;}
	if(buffer.getLengthInBits()>totalDataCount*8){throw new Error("code length overflow. ("
	+buffer.getLengthInBits()
	+">"
	+totalDataCount*8
	+")");}
	if(buffer.getLengthInBits()+4<=totalDataCount*8){buffer.put(0,4);}
	while(buffer.getLengthInBits()%8!=0){buffer.putBit(false);}
	while(true){if(buffer.getLengthInBits()>=totalDataCount*8){break;}
	buffer.put(QRCodeModel.PAD0,8);if(buffer.getLengthInBits()>=totalDataCount*8){break;}
	buffer.put(QRCodeModel.PAD1,8);}
	return QRCodeModel.createBytes(buffer,rsBlocks);};QRCodeModel.createBytes=function(buffer,rsBlocks){var offset=0;var maxDcCount=0;var maxEcCount=0;var dcdata=new Array(rsBlocks.length);var ecdata=new Array(rsBlocks.length);for(var r=0;r<rsBlocks.length;r++){var dcCount=rsBlocks[r].dataCount;var ecCount=rsBlocks[r].totalCount-dcCount;maxDcCount=Math.max(maxDcCount,dcCount);maxEcCount=Math.max(maxEcCount,ecCount);dcdata[r]=new Array(dcCount);for(var i=0;i<dcdata[r].length;i++){dcdata[r][i]=0xff&buffer.buffer[i+offset];}
	offset+=dcCount;var rsPoly=QRUtil.getErrorCorrectPolynomial(ecCount);var rawPoly=new QRPolynomial(dcdata[r],rsPoly.getLength()-1);var modPoly=rawPoly.mod(rsPoly);ecdata[r]=new Array(rsPoly.getLength()-1);for(var i=0;i<ecdata[r].length;i++){var modIndex=i+modPoly.getLength()-ecdata[r].length;ecdata[r][i]=(modIndex>=0)?modPoly.get(modIndex):0;}}
	var totalCodeCount=0;for(var i=0;i<rsBlocks.length;i++){totalCodeCount+=rsBlocks[i].totalCount;}
	var data=new Array(totalCodeCount);var index=0;for(var i=0;i<maxDcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<dcdata[r].length){data[index++]=dcdata[r][i];}}}
	for(var i=0;i<maxEcCount;i++){for(var r=0;r<rsBlocks.length;r++){if(i<ecdata[r].length){data[index++]=ecdata[r][i];}}}
	return data;};var QRMode={MODE_NUMBER:1<<0,MODE_ALPHA_NUM:1<<1,MODE_8BIT_BYTE:1<<2,MODE_KANJI:1<<3};var QRErrorCorrectLevel={L:1,M:0,Q:3,H:2};var QRMaskPattern={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};var QRUtil={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:(1<<10)|(1<<8)|(1<<5)|(1<<4)|(1<<2)|(1<<1)|(1<<0),G18:(1<<12)|(1<<11)|(1<<10)|(1<<9)|(1<<8)|(1<<5)|(1<<2)|(1<<0),G15_MASK:(1<<14)|(1<<12)|(1<<10)|(1<<4)|(1<<1),getBCHTypeInfo:function(data){var d=data<<10;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)>=0){d^=(QRUtil.G15<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G15)));}
	return((data<<10)|d)^QRUtil.G15_MASK;},getBCHTypeNumber:function(data){var d=data<<12;while(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)>=0){d^=(QRUtil.G18<<(QRUtil.getBCHDigit(d)-QRUtil.getBCHDigit(QRUtil.G18)));}
	return(data<<12)|d;},getBCHDigit:function(data){var digit=0;while(data!=0){digit++;data>>>=1;}
	return digit;},getPatternPosition:function(typeNumber){return QRUtil.PATTERN_POSITION_TABLE[typeNumber-1];},getMask:function(maskPattern,i,j){switch(maskPattern){case QRMaskPattern.PATTERN000:return(i+j)%2==0;case QRMaskPattern.PATTERN001:return i%2==0;case QRMaskPattern.PATTERN010:return j%3==0;case QRMaskPattern.PATTERN011:return(i+j)%3==0;case QRMaskPattern.PATTERN100:return(Math.floor(i/2)+Math.floor(j/3))%2==0;case QRMaskPattern.PATTERN101:return(i*j)%2+(i*j)%3==0;case QRMaskPattern.PATTERN110:return((i*j)%2+(i*j)%3)%2==0;case QRMaskPattern.PATTERN111:return((i*j)%3+(i+j)%2)%2==0;default:throw new Error("bad maskPattern:"+maskPattern);}},getErrorCorrectPolynomial:function(errorCorrectLength){var a=new QRPolynomial([1],0);for(var i=0;i<errorCorrectLength;i++){a=a.multiply(new QRPolynomial([1,QRMath.gexp(i)],0));}
	return a;},getLengthInBits:function(mode,type){if(1<=type&&type<10){switch(mode){case QRMode.MODE_NUMBER:return 10;case QRMode.MODE_ALPHA_NUM:return 9;case QRMode.MODE_8BIT_BYTE:return 8;case QRMode.MODE_KANJI:return 8;default:throw new Error("mode:"+mode);}}else if(type<27){switch(mode){case QRMode.MODE_NUMBER:return 12;case QRMode.MODE_ALPHA_NUM:return 11;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 10;default:throw new Error("mode:"+mode);}}else if(type<41){switch(mode){case QRMode.MODE_NUMBER:return 14;case QRMode.MODE_ALPHA_NUM:return 13;case QRMode.MODE_8BIT_BYTE:return 16;case QRMode.MODE_KANJI:return 12;default:throw new Error("mode:"+mode);}}else{throw new Error("type:"+type);}},getLostPoint:function(qrCode){var moduleCount=qrCode.getModuleCount();var lostPoint=0;for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount;col++){var sameCount=0;var dark=qrCode.isDark(row,col);for(var r=-1;r<=1;r++){if(row+r<0||moduleCount<=row+r){continue;}
	for(var c=-1;c<=1;c++){if(col+c<0||moduleCount<=col+c){continue;}
	if(r==0&&c==0){continue;}
	if(dark==qrCode.isDark(row+r,col+c)){sameCount++;}}}
	if(sameCount>5){lostPoint+=(3+sameCount-5);}}}
	for(var row=0;row<moduleCount-1;row++){for(var col=0;col<moduleCount-1;col++){var count=0;if(qrCode.isDark(row,col))count++;if(qrCode.isDark(row+1,col))count++;if(qrCode.isDark(row,col+1))count++;if(qrCode.isDark(row+1,col+1))count++;if(count==0||count==4){lostPoint+=3;}}}
	for(var row=0;row<moduleCount;row++){for(var col=0;col<moduleCount-6;col++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row,col+1)&&qrCode.isDark(row,col+2)&&qrCode.isDark(row,col+3)&&qrCode.isDark(row,col+4)&&!qrCode.isDark(row,col+5)&&qrCode.isDark(row,col+6)){lostPoint+=40;}}}
	for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount-6;row++){if(qrCode.isDark(row,col)&&!qrCode.isDark(row+1,col)&&qrCode.isDark(row+2,col)&&qrCode.isDark(row+3,col)&&qrCode.isDark(row+4,col)&&!qrCode.isDark(row+5,col)&&qrCode.isDark(row+6,col)){lostPoint+=40;}}}
	var darkCount=0;for(var col=0;col<moduleCount;col++){for(var row=0;row<moduleCount;row++){if(qrCode.isDark(row,col)){darkCount++;}}}
	var ratio=Math.abs(100*darkCount/moduleCount/moduleCount-50)/5;lostPoint+=ratio*10;return lostPoint;}};var QRMath={glog:function(n){if(n<1){throw new Error("glog("+n+")");}
	return QRMath.LOG_TABLE[n];},gexp:function(n){while(n<0){n+=255;}
	while(n>=256){n-=255;}
	return QRMath.EXP_TABLE[n];},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)};for(var i=0;i<8;i++){QRMath.EXP_TABLE[i]=1<<i;}
	for(var i=8;i<256;i++){QRMath.EXP_TABLE[i]=QRMath.EXP_TABLE[i-4]^QRMath.EXP_TABLE[i-5]^QRMath.EXP_TABLE[i-6]^QRMath.EXP_TABLE[i-8];}
	for(var i=0;i<255;i++){QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]]=i;}
	function QRPolynomial(num,shift){if(num.length==undefined){throw new Error(num.length+"/"+shift);}
	var offset=0;while(offset<num.length&&num[offset]==0){offset++;}
	this.num=new Array(num.length-offset+shift);for(var i=0;i<num.length-offset;i++){this.num[i]=num[i+offset];}}
	QRPolynomial.prototype={get:function(index){return this.num[index];},getLength:function(){return this.num.length;},multiply:function(e){var num=new Array(this.getLength()+e.getLength()-1);for(var i=0;i<this.getLength();i++){for(var j=0;j<e.getLength();j++){num[i+j]^=QRMath.gexp(QRMath.glog(this.get(i))+QRMath.glog(e.get(j)));}}
	return new QRPolynomial(num,0);},mod:function(e){if(this.getLength()-e.getLength()<0){return this;}
	var ratio=QRMath.glog(this.get(0))-QRMath.glog(e.get(0));var num=new Array(this.getLength());for(var i=0;i<this.getLength();i++){num[i]=this.get(i);}
	for(var i=0;i<e.getLength();i++){num[i]^=QRMath.gexp(QRMath.glog(e.get(i))+ratio);}
	return new QRPolynomial(num,0).mod(e);}};function QRRSBlock(totalCount,dataCount){this.totalCount=totalCount;this.dataCount=dataCount;}
	QRRSBlock.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]];QRRSBlock.getRSBlocks=function(typeNumber,errorCorrectLevel){var rsBlock=QRRSBlock.getRsBlockTable(typeNumber,errorCorrectLevel);if(rsBlock==undefined){throw new Error("bad rs block @ typeNumber:"+typeNumber+"/errorCorrectLevel:"+errorCorrectLevel);}
	var length=rsBlock.length/3;var list=[];for(var i=0;i<length;i++){var count=rsBlock[i*3+0];var totalCount=rsBlock[i*3+1];var dataCount=rsBlock[i*3+2];for(var j=0;j<count;j++){list.push(new QRRSBlock(totalCount,dataCount));}}
	return list;};QRRSBlock.getRsBlockTable=function(typeNumber,errorCorrectLevel){switch(errorCorrectLevel){case QRErrorCorrectLevel.L:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+0];case QRErrorCorrectLevel.M:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+1];case QRErrorCorrectLevel.Q:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+2];case QRErrorCorrectLevel.H:return QRRSBlock.RS_BLOCK_TABLE[(typeNumber-1)*4+3];default:return undefined;}};function QRBitBuffer(){this.buffer=[];this.length=0;}
	QRBitBuffer.prototype={get:function(index){var bufIndex=Math.floor(index/8);return((this.buffer[bufIndex]>>>(7-index%8))&1)==1;},put:function(num,length){for(var i=0;i<length;i++){this.putBit(((num>>>(length-i-1))&1)==1);}},getLengthInBits:function(){return this.length;},putBit:function(bit){var bufIndex=Math.floor(this.length/8);if(this.buffer.length<=bufIndex){this.buffer.push(0);}
	if(bit){this.buffer[bufIndex]|=(0x80>>>(this.length%8));}
	this.length++;}};var QRCodeLimitLength=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]];
	
	function _isSupportCanvas() {
		return typeof CanvasRenderingContext2D != "undefined";
	}
	
	// android 2.x doesn't support Data-URI spec
	function _getAndroid() {
		var android = false;
		var sAgent = navigator.userAgent;
		
		if (/android/i.test(sAgent)) { // android
			android = true;
			var aMat = sAgent.toString().match(/android ([0-9]\.[0-9])/i);
			
			if (aMat && aMat[1]) {
				android = parseFloat(aMat[1]);
			}
		}
		
		return android;
	}
	
	var svgDrawer = (function() {

		var Drawing = function (el, htOption) {
			this._el = el;
			this._htOption = htOption;
		};

		Drawing.prototype.draw = function (oQRCode) {
			var _htOption = this._htOption;
			var _el = this._el;
			var nCount = oQRCode.getModuleCount();
			var nWidth = Math.floor(_htOption.width / nCount);
			var nHeight = Math.floor(_htOption.height / nCount);

			this.clear();

			function makeSVG(tag, attrs) {
				var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
				for (var k in attrs)
					if (attrs.hasOwnProperty(k)) el.setAttribute(k, attrs[k]);
				return el;
			}

			var svg = makeSVG("svg" , {'viewBox': '0 0 ' + String(nCount) + " " + String(nCount), 'width': '100%', 'height': '100%', 'fill': _htOption.colorLight});
			svg.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
			_el.appendChild(svg);

			svg.appendChild(makeSVG("rect", {"fill": _htOption.colorLight, "width": "100%", "height": "100%"}));
			svg.appendChild(makeSVG("rect", {"fill": _htOption.colorDark, "width": "1", "height": "1", "id": "template"}));

			for (var row = 0; row < nCount; row++) {
				for (var col = 0; col < nCount; col++) {
					if (oQRCode.isDark(row, col)) {
						var child = makeSVG("use", {"x": String(col), "y": String(row)});
						child.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#template")
						svg.appendChild(child);
					}
				}
			}
		};
		Drawing.prototype.clear = function () {
			while (this._el.hasChildNodes())
				this._el.removeChild(this._el.lastChild);
		};
		return Drawing;
	})();

	var useSVG = document.documentElement.tagName.toLowerCase() === "svg";

	// Drawing in DOM by using Table tag
	var Drawing = useSVG ? svgDrawer : !_isSupportCanvas() ? (function () {
		var Drawing = function (el, htOption) {
			this._el = el;
			this._htOption = htOption;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode
		 */
		Drawing.prototype.draw = function (oQRCode) {
            var _htOption = this._htOption;
            var _el = this._el;
			var nCount = oQRCode.getModuleCount();
			var nWidth = Math.floor(_htOption.width / nCount);
			var nHeight = Math.floor(_htOption.height / nCount);
			var aHTML = ['<table style="border:0;border-collapse:collapse;">'];
			
			for (var row = 0; row < nCount; row++) {
				aHTML.push('<tr>');
				
				for (var col = 0; col < nCount; col++) {
					aHTML.push('<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:' + nWidth + 'px;height:' + nHeight + 'px;background-color:' + (oQRCode.isDark(row, col) ? _htOption.colorDark : _htOption.colorLight) + ';"></td>');
				}
				
				aHTML.push('</tr>');
			}
			
			aHTML.push('</table>');
			_el.innerHTML = aHTML.join('');
			
			// Fix the margin values as real size.
			var elTable = _el.childNodes[0];
			var nLeftMarginTable = (_htOption.width - elTable.offsetWidth) / 2;
			var nTopMarginTable = (_htOption.height - elTable.offsetHeight) / 2;
			
			if (nLeftMarginTable > 0 && nTopMarginTable > 0) {
				elTable.style.margin = nTopMarginTable + "px " + nLeftMarginTable + "px";	
			}
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			this._el.innerHTML = '';
		};
		
		return Drawing;
	})() : (function () { // Drawing in Canvas
		function _onMakeImage() {
			this._elImage.src = this._elCanvas.toDataURL("image/png");
			this._elImage.style.display = "block";
			this._elCanvas.style.display = "none";			
		}
		
		// Android 2.1 bug workaround
		// http://code.google.com/p/android/issues/detail?id=5141
		if (this._android && this._android <= 2.1) {
	    	var factor = 1 / window.devicePixelRatio;
	        var drawImage = CanvasRenderingContext2D.prototype.drawImage; 
	    	CanvasRenderingContext2D.prototype.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
	    		if (("nodeName" in image) && /img/i.test(image.nodeName)) {
		        	for (var i = arguments.length - 1; i >= 1; i--) {
		            	arguments[i] = arguments[i] * factor;
		        	}
	    		} else if (typeof dw == "undefined") {
	    			arguments[1] *= factor;
	    			arguments[2] *= factor;
	    			arguments[3] *= factor;
	    			arguments[4] *= factor;
	    		}
	    		
	        	drawImage.apply(this, arguments); 
	    	};
		}
		
		/**
		 * Check whether the user's browser supports Data URI or not
		 * 
		 * @private
		 * @param {Function} fSuccess Occurs if it supports Data URI
		 * @param {Function} fFail Occurs if it doesn't support Data URI
		 */
		function _safeSetDataURI(fSuccess, fFail) {
            var self = this;
            self._fFail = fFail;
            self._fSuccess = fSuccess;

            // Check it just once
            if (self._bSupportDataURI === null) {
                var el = document.createElement("img");
                var fOnError = function() {
                    self._bSupportDataURI = false;

                    if (self._fFail) {
                        self._fFail.call(self);
                    }
                };
                var fOnSuccess = function() {
                    self._bSupportDataURI = true;

                    if (self._fSuccess) {
                        self._fSuccess.call(self);
                    }
                };

                el.onabort = fOnError;
                el.onerror = fOnError;
                el.onload = fOnSuccess;
                el.src = "data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg=="; // the Image contains 1px data.
                return;
            } else if (self._bSupportDataURI === true && self._fSuccess) {
                self._fSuccess.call(self);
            } else if (self._bSupportDataURI === false && self._fFail) {
                self._fFail.call(self);
            }
		};
		
		/**
		 * Drawing QRCode by using canvas
		 * 
		 * @constructor
		 * @param {HTMLElement} el
		 * @param {Object} htOption QRCode Options 
		 */
		var Drawing = function (el, htOption) {
    		this._bIsPainted = false;
    		this._android = _getAndroid();
		
			this._htOption = htOption;
			this._elCanvas = document.createElement("canvas");
			this._elCanvas.width = htOption.width;
			this._elCanvas.height = htOption.height;
			el.appendChild(this._elCanvas);
			this._el = el;
			this._oContext = this._elCanvas.getContext("2d");
			this._bIsPainted = false;
			this._elImage = document.createElement("img");
			this._elImage.alt = "Scan me!";
			this._elImage.style.display = "none";
			this._el.appendChild(this._elImage);
			this._bSupportDataURI = null;
		};
			
		/**
		 * Draw the QRCode
		 * 
		 * @param {QRCode} oQRCode 
		 */
		Drawing.prototype.draw = function (oQRCode) {
            var _elImage = this._elImage;
            var _oContext = this._oContext;
            var _htOption = this._htOption;
            
			var nCount = oQRCode.getModuleCount();
			var nWidth = _htOption.width / nCount;
			var nHeight = _htOption.height / nCount;
			var nRoundedWidth = Math.round(nWidth);
			var nRoundedHeight = Math.round(nHeight);

			_elImage.style.display = "none";
			this.clear();
			
			for (var row = 0; row < nCount; row++) {
				for (var col = 0; col < nCount; col++) {
					var bIsDark = oQRCode.isDark(row, col);
					var nLeft = col * nWidth;
					var nTop = row * nHeight;
					_oContext.strokeStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;
					_oContext.lineWidth = 1;
					_oContext.fillStyle = bIsDark ? _htOption.colorDark : _htOption.colorLight;					
					_oContext.fillRect(nLeft, nTop, nWidth, nHeight);
					
					// 안티 앨리어싱 방지 처리
					_oContext.strokeRect(
						Math.floor(nLeft) + 0.5,
						Math.floor(nTop) + 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
					
					_oContext.strokeRect(
						Math.ceil(nLeft) - 0.5,
						Math.ceil(nTop) - 0.5,
						nRoundedWidth,
						nRoundedHeight
					);
				}
			}
			
			this._bIsPainted = true;
		};
			
		/**
		 * Make the image from Canvas if the browser supports Data URI.
		 */
		Drawing.prototype.makeImage = function () {
			if (this._bIsPainted) {
				_safeSetDataURI.call(this, _onMakeImage);
			}
		};
			
		/**
		 * Return whether the QRCode is painted or not
		 * 
		 * @return {Boolean}
		 */
		Drawing.prototype.isPainted = function () {
			return this._bIsPainted;
		};
		
		/**
		 * Clear the QRCode
		 */
		Drawing.prototype.clear = function () {
			this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height);
			this._bIsPainted = false;
		};
		
		/**
		 * @private
		 * @param {Number} nNumber
		 */
		Drawing.prototype.round = function (nNumber) {
			if (!nNumber) {
				return nNumber;
			}
			
			return Math.floor(nNumber * 1000) / 1000;
		};
		
		return Drawing;
	})();
	
	/**
	 * Get the type by string length
	 * 
	 * @private
	 * @param {String} sText
	 * @param {Number} nCorrectLevel
	 * @return {Number} type
	 */
	function _getTypeNumber(sText, nCorrectLevel) {			
		var nType = 1;
		var length = _getUTF8Length(sText);
		
		for (var i = 0, len = QRCodeLimitLength.length; i <= len; i++) {
			var nLimit = 0;
			
			switch (nCorrectLevel) {
				case QRErrorCorrectLevel.L :
					nLimit = QRCodeLimitLength[i][0];
					break;
				case QRErrorCorrectLevel.M :
					nLimit = QRCodeLimitLength[i][1];
					break;
				case QRErrorCorrectLevel.Q :
					nLimit = QRCodeLimitLength[i][2];
					break;
				case QRErrorCorrectLevel.H :
					nLimit = QRCodeLimitLength[i][3];
					break;
			}
			
			if (length <= nLimit) {
				break;
			} else {
				nType++;
			}
		}
		
		if (nType > QRCodeLimitLength.length) {
			throw new Error("Too long data");
		}
		
		return nType;
	}

	function _getUTF8Length(sText) {
		var replacedText = encodeURI(sText).toString().replace(/\%[0-9a-fA-F]{2}/g, 'a');
		return replacedText.length + (replacedText.length != sText ? 3 : 0);
	}
	
	/**
	 * @class QRCode
	 * @constructor
	 * @example 
	 * new QRCode(document.getElementById("test"), "http://jindo.dev.naver.com/collie");
	 *
	 * @example
	 * var oQRCode = new QRCode("test", {
	 *    text : "http://naver.com",
	 *    width : 128,
	 *    height : 128
	 * });
	 * 
	 * oQRCode.clear(); // Clear the QRCode.
	 * oQRCode.makeCode("http://map.naver.com"); // Re-create the QRCode.
	 *
	 * @param {HTMLElement|String} el target element or 'id' attribute of element.
	 * @param {Object|String} vOption
	 * @param {String} vOption.text QRCode link data
	 * @param {Number} [vOption.width=256]
	 * @param {Number} [vOption.height=256]
	 * @param {String} [vOption.colorDark="#000000"]
	 * @param {String} [vOption.colorLight="#ffffff"]
	 * @param {QRCode.CorrectLevel} [vOption.correctLevel=QRCode.CorrectLevel.H] [L|M|Q|H] 
	 */
	QRCode = function (el, vOption) {
		this._htOption = {
			width : 256, 
			height : 256,
			typeNumber : 4,
			colorDark : "#000000",
			colorLight : "#ffffff",
			correctLevel : QRErrorCorrectLevel.H
		};
		
		if (typeof vOption === 'string') {
			vOption	= {
				text : vOption
			};
		}
		
		// Overwrites options
		if (vOption) {
			for (var i in vOption) {
				this._htOption[i] = vOption[i];
			}
		}
		
		if (typeof el == "string") {
			el = document.getElementById(el);
		}

		if (this._htOption.useSVG) {
			Drawing = svgDrawer;
		}
		
		this._android = _getAndroid();
		this._el = el;
		this._oQRCode = null;
		this._oDrawing = new Drawing(this._el, this._htOption);
		
		if (this._htOption.text) {
			this.makeCode(this._htOption.text);	
		}
	};
	
	/**
	 * Make the QRCode
	 * 
	 * @param {String} sText link data
	 */
	QRCode.prototype.makeCode = function (sText) {
		this._oQRCode = new QRCodeModel(_getTypeNumber(sText, this._htOption.correctLevel), this._htOption.correctLevel);
		this._oQRCode.addData(sText);
		this._oQRCode.make();
		this._el.title = sText;
		this._oDrawing.draw(this._oQRCode);			
		this.makeImage();
	};
	
	/**
	 * Make the Image from Canvas element
	 * - It occurs automatically
	 * - Android below 3 doesn't support Data-URI spec.
	 * 
	 * @private
	 */
	QRCode.prototype.makeImage = function () {
		if (typeof this._oDrawing.makeImage == "function" && (!this._android || this._android >= 3)) {
			this._oDrawing.makeImage();
		}
	};
	
	/**
	 * Clear the QRCode
	 */
	QRCode.prototype.clear = function () {
		this._oDrawing.clear();
	};
	
	/**
	 * @name QRCode.CorrectLevel
	 */
	QRCode.CorrectLevel = QRErrorCorrectLevel;
})();

terminal.addCommand("qr", async function(args) {
    terminal.addLineBreak()
    const div = document.createElement("div")
    new QRCode(div, args.text)
    terminal.parentNode.appendChild(div)
    terminal.addLineBreak()

    div.style.border = "10px solid white"
    div.style.width = "fit-content"
}, {
    description: "generate a qr code",
    args: {
        "*text": "the text to encode"
    }
})

// ------------------- js/commands/rate.js --------------------
terminal.addCommand("rate", function(args) {
    let languageEvaluations = {
        "py": "it's got everything: explicity, typing, great syntax, just speed is lacking",
        "python2": "who really uses python2 nowadays? just update to python3",
        "java": "not too fond of strict object oriented programming, but it's quite beginner friendly",
        "ruby": "let me introduce: a worse python",
        "html": "is this really supposed to be a programming language?",
        "css": "secretely a big fan but don't tell anyone",
        "js": "this one is just a mix of everything. it aged like milk",
        "javascript": "this one is just a mix of everything. it aged like milk",
        "jsx": "this one is just a mix of everything. it aged like milk",
        "php": "i hate myself for using this one",
        "lua": "i wish i could use lua more often - it's actually quite awesome",
        "go": "liked the 8 hour long tutorial but have yet to use it",
        "c": "i really want to hate it but its simplictiy and speed is just awesome",
        "c++": "use this instead of c when you want complexity",
        "c#": "java but better syntax - love it",
        "kotlin": "c# but not from microsoft lol",
        "swift": "what is this language? i don't know",
        "rust": "c but 2020 version. A person that doesn't love rust hasn't used rust",
        "hs": "functional programming requires so much brain power.\nyou automatically feel smarter when using it.\nLOVE IT!!",
    }
    
    languageEvaluations["python"] = languageEvaluations["py"]
    languageEvaluations["python3"] = languageEvaluations["py"]
    languageEvaluations["javascript"] = languageEvaluations["js"]
    languageEvaluations["jsx"] = languageEvaluations["js"]
    languageEvaluations["csharp"] = languageEvaluations["c#"]
    languageEvaluations["cpp"] = languageEvaluations["c++"]
    languageEvaluations["haskell"] = languageEvaluations["hs"]

    if (languageEvaluations[args.language]) {
        terminal.printLine(languageEvaluations[args.language])
    } else {
        terminal.printLine("i don't know that one")
    }
}, {
    description: "rate a programming language",
    args: ["language"]
})

// ------------------- js/commands/raycasting.js --------------------
terminal.addCommand("raycasting", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.baseUrl + "../raycasting/",
        name: "Raycasting Demo",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "play with raycasting",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/reboot.js --------------------
terminal.addCommand("reboot", () => terminal.reload(), {
    description: "reboot the website"
})



// ------------------- js/commands/reload.js --------------------
terminal.addCommand("reload", async function(args) {
    if (terminal.inTestMode)
        return
    const newLoadIndex = parseInt(loadIndex) + 1
    localStorage.setItem("loadIndex", newLoadIndex)
    terminal.reload()
}, {
    description: "Reloads the terminal",
})

// ------------------- js/commands/rename.js --------------------
terminal.addCommand("rename", async function(args) {
    if (!terminal.isValidFileName(args.name))
        throw new Error("invalid file name")

    if (terminal.fileExists(args.name))
        throw new Error("file already exists in folder")

    let file = terminal.getFile(args.file)
    if (terminal.rootDirectory.id == file.id)
        throw new Error("cannot rename root folder")

    file.setName(args.name)
}, {
    description: "rename a file or folder",
    args: {
        "file:f": "the file or folder to rename",
        "name:s": "the new name of the file or folder"
    }
})

// ------------------- js/commands/reset.js --------------------
terminal.addCommand("reset", async function(args) {
    async function animatedDo(action) {
        return new Promise(async resolve => {
            terminal.print(action)
            for (let i = 0; i < 6; i++) {
                await terminal.sleep(200)
                terminal.print(".")
            }
            await terminal.sleep(500)
            terminal.printLine("done")
            resolve()
        })
    }
    if (!args.now)
        await terminal.acceptPrompt("this will fully reset the terminal (including all files). are you sure?", false)
    return new Promise(async () => {
        if (!args.now) {
            await animatedDo("resetting")
        }
        terminal.reset()
        terminal.reload()
    })
}, {
    description: "reset the terminal",
    args: {
        "?n=now:b": "reset now"
    }
})

// ------------------- js/commands/reverse.js --------------------
terminal.addCommand("reverse", async function(args) {
    let reversed = args.message.split("").reverse().join("")
    terminal.printLine(reversed)
    if (args.c) {
        terminal.copy(reversed)
        terminal.printLine("Copied to Clipboard ✓", Color.COLOR_1)
    }
}, {
    description: "reverse a message",
    args: {
        "*message": "the message to reverse",
        "?c": "copy the reversed message to the clipboard"
    }
})



// ------------------- js/commands/rm.js --------------------
terminal.addCommand("rm", async function(args) {
    let file = terminal.getFile(args.file)
    if (file == terminal.rootDirectory) {
        throw new Error("Cannot remove root directory!")
    }

    file.parent.deleteChild(file)

    let filePath = FilePath.from(terminal.data.path)
    if (!terminal.fileExists(filePath)) {
        terminal.fileSystem.currDirectory = terminal.fileSystem.root
        terminal.updatePath()
        terminal.printLine("You just cut an active filetree and have been moved back to root/")
    }
}, {
    description: "remove a file",
    args: {
        "file:f": "file to remove"
    }
})

// ------------------- js/commands/rndm.js --------------------
terminal.addCommand("rndm", async function(args) {
    if (args.max - args.min <= 0)
        throw new Error("max value must be greater than min value")

    let randomNum = ""

    if (args.t && args.f) {
        throw new Error("cannot use both time and float options")
    }

    if (!args.f) {
        if (!Number.isInteger(args.min) || !Number.isInteger(args.max)) {
            throw new Error("min and max values must be integers in integer mode")
        }
    }

    if (args.t) {
        args.min = Math.floor(args.min)
        args.max = Math.floor(args.max + 1)

        let range = args.max - args.min
        randomNum = (Date.now() % range) + args.min
    } else if (args.f) {
        randomNum = Math.random() * (args.max - args.min) + args.min
    } else {
        args.min = Math.floor(args.min)
        args.max = Math.floor(args.max + 1)

        randomNum = Math.floor(Math.random() * (args.max - args.min) + args.min)
    }
    
    terminal.printLine(randomNum)
}, {
    description: "generate a random number based on the current time",
    args: {
        "?min:n:0~100000": "minimum value (inclusive)",
        "?max:n:0~100000": "maximum value (inclusive)",
        "?t=time:b": "use a time based random number generator",
        "?f=float:b": "generate a float instead of an integer",
    },
    standardVals: {
        min: 1,
        max: 100,
    }
})



// ------------------- js/commands/say.js --------------------
terminal.addCommand("say", async function({ text, pitch, language }) {
    return new Promise(async resolve => {
        if (window.speechSynthesis) {
    
            const message = new SpeechSynthesisUtterance();
    
            message.text = text;
            message.pitch = pitch;
            message.lang = language;

            let running = true;
            message.onend = () => {
                resolve();
                running = false;
            }

            terminal.onInterrupt(speechSynthesis.cancel.bind(speechSynthesis));
            
            window.speechSynthesis.speak(message);

            while (running) {
                await sleep(1000);
            }
    
        } else {
            terminal.printError("Sorry, your browser doesn't support text to speech!");
        }
    });
}, {
    author: "Colin Chadwick",
    description: "Say something",
    args: {
        "*text:s": "The text to say",
        "?pitch:n:0~2": "The pitch of the voice",
        "?language:s": "The language of the voice"
    },
    defaultValues: {
        pitch: 1,
        language: "en-US"
    }
})

// ------------------- js/commands/sc.js --------------------
terminal.addCommand("sc", async function(args) {
    if (args.command && args.mode == "add") {
        let tokens = TerminalParser.tokenize(args.command)
        if (tokens.length == 0)
            throw new Error("Command cannot be empty")
        let [commandToken, argTokens] = TerminalParser.extractCommandAndArgs(tokens)
        if (!terminal.commandExists(commandToken))
            throw new Error(`Command '${commandToken}' does not exist`)
    }

    const modeFuncs = {
        add: async function() {
            if (!args.command)
                throw new Error("Must specify a command to add")
            let commands = terminal.data.startupCommands
            if (commands.includes(args.command))
                throw new Error(`Command '${args.command}' is already in the startup commands`)
            commands.push(args.command)
            terminal.data.startupCommands = commands
            terminal.printSuccess(`Added '${args.command}' to startup commands`)
        },
        remove: async function() {
            if (!args.command)
                throw new Error("Must specify a command to remove")
            let commands = terminal.data.startupCommands

            if (/^[0-9]+$/.test(args.command)) {
                let index = parseInt(args.command)
                if (index < 1 || index > commands.length) {
                    throw new Error("Invalid Index: command not found")
                }
                args.command = commands[index - 1]
            }

            if (!commands.includes(args.command))
                throw new Error(`Command '${args.command}' is not in the startup commands`)
            commands.splice(commands.indexOf(args.command), 1)
            terminal.data.startupCommands = commands
            terminal.printSuccess(`Removed '${args.command}' from startup commands`)
        },
        reset: async function() {
            terminal.data.resetProperty("startupCommands")
            terminal.printSuccess("Reset startup commands")
        },
        list: async function() {
            if (args.command)
                throw new Error("Cannot specify a command when listing")
            let commands = terminal.data.startupCommands
            if (commands.length == 0)
                terminal.printLine("No startup commands found")
            else {
                terminal.printLine("Startup Commands:")
                for (let i = 0; i < commands.length; i++) {
                    terminal.printLine(`(${i + 1}): ${commands[i]}`)
                }
            }

            terminal.printLine()
            terminal.print("To add a command, use ")
            terminal.printLine("sc add <command>", Color.COLOR_1)
            terminal.print("To remove a command, use ")
            terminal.printLine("sc remove <index>", Color.COLOR_1)
        }
    }

    if (args.mode in modeFuncs) {
        await modeFuncs[args.mode]()
    } else {
        terminal.printError(`Unknown mode '${args.mode}'`)
    }
}, {
    description: "manage the startup commands",
    args: {
        "?mode": "'add', 'remove', 'reset' or 'list'",
        "?command": "the command to add or remove (or index)"
    },
    defaultValues: {
        mode: "list"
    }
})

// ------------------- js/commands/scarpet.js --------------------
terminal.addCommand("scarpet", async function(args) {
	await terminal.modules.import("game", window)

	function initDisplay() {
        let canvas = document.createElement("canvas")
        let context = canvas.getContext("2d")
        let widthPx = Math.floor(terminal.charWidth * args.size)
        let heightPx = widthPx
        canvas.width = widthPx
        canvas.height = heightPx
        canvas.style.width = widthPx + "px"
        canvas.style.height = heightPx + "px"
        terminal.parentNode.appendChild(canvas)
        context.fillStyle = "white"
        context.fillRect(0, 0, canvas.width, canvas.height)
        terminal.addLineBreak()
        return [context, canvas]
	}

	const [context2d, canvas] = initDisplay()

    const possibleGoals = [
        new Vector2d(0, 0),
        new Vector2d(0.5, 0),
        new Vector2d(1, 0),
        new Vector2d(1, 0.5),
        new Vector2d(1, 1),
        new Vector2d(0.5, 1),
        new Vector2d(0, 1),
        new Vector2d(0, 0.5)
    ]

    function drawDot(position) {
        context2d.fillStyle = "black"
        context2d.fillRect(
            position.x * canvas.width,
            position.y * canvas.height,
            1, 1
        )
    }

    let currPosition = Vector2d.fromFunc(Math.random)
    for (let i = 0; true; i++) {
        const randomGoal = possibleGoals[Math.floor(Math.random() * 8)]
        const delta = randomGoal.sub(currPosition)
        currPosition.iadd(delta.scale(2 / 3))

        drawDot(currPosition)

        if (i % args.speed == 0) {
            await sleep(0)
        }
    }

}, {
	description: "draws the Sierpinski carpet using the chaos game",
    args: {
        "?s=speed:i:1~99999": "the speed of dots placed. The higher the faster.",
        "?size:i:10~1000": "size of output canvas in characters",
    },
    defaultValues: {
        speed: 30,
        size: 50
    }
})

// ------------------- js/commands/search.js --------------------
terminal.addCommand("search", async function(args) {
    terminal.href(args.b + encodeURIComponent(args.query))
}, {
    description: "search something via google.com",
    args: {
        "*query": "the search query",
        "?b=baseUrl": "the base search-engine url"
    },
    standardVals: {
        b: "https://www.google.com/search?q="
    }
})



// ------------------- js/commands/session.js --------------------
terminal.window.addEventListener("beforeunload", function (e) {
    if (!terminal.fileSystem.inSessionMode) {
        return
    }

    e.preventDefault()
    return "You have an active terminal session. If you leave now, all unsaved changes will be gone"
})

terminal.addCommand("session", async function(args) {
    if (args.action == "begin") {
        if (terminal.fileSystem.inSessionMode) {
            throw new Error("Session already active")
        }

        terminal.fileSystem.beginSession()
        terminal.printSuccess("Successfully started a session.")
        terminal.printLine("All changes you make to the filesystem are now temporary")
        terminal.printLine("and will thus be gone when you reload the website. However,")
        terminal.printLine("this removes the necessary limit of very limited local storage.\n")
        terminal.print("- To end the session, use ")
        terminal.printCommand("session end")
    } else if (args.action == "reset") {
        if (!terminal.fileSystem.inSessionMode) {
            throw new Error("No active session found")
        }

        terminal.fileSystem.reset()
        terminal.printSuccess("Successfully reset the session filesystem")
    } else if (args.action == "save") {
        if (!terminal.fileSystem.inSessionMode) {
            throw new Error("No active session found")
        }

        const dateTime = new Date()
        let fileName = "session-"
        fileName += `${dateTime.getFullYear().toString().padStart(4, '0')}`
        fileName += `${(dateTime.getMonth() + 1).toString().padStart(2, '0')}`
        fileName += `${dateTime.getDate().toString().padStart(2, '0')}`
        fileName += "-"
        fileName += `${dateTime.getHours().toString().padStart(2, '0')}`
        fileName += `${dateTime.getMinutes().toString().padStart(2, '0')}`
        fileName += `${dateTime.getSeconds().toString().padStart(2, '0')}`
        fileName += ".json"

        let sessionFile = new PlainTextFile(terminal.fileSystem.toJSON())
        downloadFile(sessionFile.setName(fileName))

        terminal.printSuccess(`Successfully saved ${sessionFile.name}`)

    } else if (args.action == "load") {
        if (!terminal.fileSystem.inSessionMode) {
            throw new Error("No active session found")
        }

        await terminal.modules.load("upload", terminal)
        try {
            var [fileName, fileContent, isDataURL] = await terminal.modules.upload.file()
        } catch (e) {
            throw new Error("File Upload Failed")
        }

        try {
            terminal.fileSystem.loadJSON(fileContent)
        } catch (e) {
            throw new Error("Invalid session file")
        }

        terminal.printSuccess(`Successfully loaded ${fileName}`)

    } else if (args.action == "end") {
        if (!terminal.fileSystem.inSessionMode) {
            throw new Error("No active session found")
        }

        terminal.fileSystem.endSession()
        await terminal.fileSystem.load()
        terminal.printSuccess("Successfully ended the session.")
        terminal.print("The previous filesystem is restored. All session changes are gone.")
    }
}, {
    description: "manage a filesystem session",
    args: {
        "action:e:begin|reset|save|load|end": "<enum>"
    }
})  

// ------------------- js/commands/set.js --------------------
terminal.addCommand("set", async function(args) {
    await terminal.modules.load("cliapi", terminal)
    const CliApi = terminal.modules.cliapi
    if (!CliApi.KEY_REGEX.test(args.key)) {
        terminal.printError("Invalid key")
        return
    }
    if (args.value.length > 255) {
        terminal.printError("Value too big in size")
        return
    }
    await CliApi.set(args.key, args.value)
    terminal.printLine("Success", Color.LIGHT_GREEN)
}, {
    description: "set a value on the server",
    args: {
        key: "the key to set the value of",
        value: "the value to set"
    },
    disableEqualsArgNotation: true
})



// ------------------- js/commands/sha256.js --------------------
terminal.addCommand("sha256", async function(args) {
    if (!window.crypto || !window.crypto.subtle)
        throw new Error("crypto API not supported")

    let hash = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(args.text))
    let hashArray = Array.from(new Uint8Array(hash))
    let hashHex = hashArray.map(b => b.toString(16).padStart(2, "0")).join("")
    terminal.printLine(hashHex)
}, {
    description: "calculate the SHA-256 hash of a message",
    args: {
        "*text:s": "ascii text to calculate hash of"
    }
})

// ------------------- js/commands/shi.js --------------------
terminal.addCommand("shi", async function(args) {
    const SHI = args.s ** 2 / args.l
    await sleep(100)

    await terminal.printLine("Okay. I will begin the calculation now...")
    await sleep(1000)

    await terminal.animatePrint("Making progress...")
    await sleep(500)

    await terminal.animatePrint("Almost there...")
    await sleep(1000)

    await terminal.animatePrint("Okay I got it.")
    await sleep(500)

    await terminal.animatePrint("In general, a SHI below 10 is considered instable, a SHI")
    await terminal.animatePrint("below 9 is considered dangerous.")
    await sleep(300)

    await terminal.animatePrint("Everything above 11 is fine and 10-11 is maybe a bit wonky.")
    await sleep(700)

    await terminal.animatePrint("Your result is... ", 50, {newLine: false})
    await sleep(2000)

    terminal.printLine(SHI)
    await sleep(1000)

    const diagnoses = [
        {max: 0, diagnosis: "A negative SHI is quite the achievement. Do Kangaroos live in your place?"},
        {max: 1, diagnosis: "You should officially be considered a skyscraper"},
        {max: 5, diagnosis: "It's generally interesting that you're still alive. You should have fallen over."},
        {max: 6, diagnosis: "Well. You should avoid standing up (in general). Good Luck. You'll need it."},
        {max: 7, diagnosis: "Have you ever considered a wheelchair?"},
        {max: 8, diagnosis: "Are you sure you typed in everything correctly? It seems unlikely that you're alive."},
        {max: 8.5, diagnosis: "You're extremely likely to tip over if you go fast around any slight corner."},
        {max: 9, diagnosis: "You're very likely to tip over if you go fast around a corner. Be aware of that!"},
        {max: 9.25, diagnosis: "Ouch. That must have hurt (all the 9523 times you've fallen already). You're instable."},
        {max: 9.5, diagnosis: "Yikes. You're generally pretty instable and people should be afraid around you."},
        {max: 9.75, diagnosis: "It's not very bad but you should consider buying bigger shoes, please. You're instable around corners."},
        {max: 10, diagnosis: "You're almost stable. Drink more milk and maybe you'll not tip over around corners any more!"},
        {max: 10.33, diagnosis: "You should avoid tight corners at all costs, please. You're almost instable!"},
        {max: 10.66, diagnosis: "Okay. All corners that are sharper than 30° should interest you. But other than that, you're fine!"},
        {max: 11, diagnosis: "You're almost in the green zone. Buy a bigger shoe size and you wont tip over anymore."},
        {max: 11.5, diagnosis: "You're as steady as a rock. No chance of tipping over, ever. But still please avoid >80° corners."},
        {max: 12, diagnosis: "You're as steady as a mountain. Almost. But avoid 90° corners."},
        {max: 13, diagnosis: "Wow! You could be Hagrid! You're qualified to help those who need it (SHI under 9)"},
        {max: 14, diagnosis: "Uh-huh. You don't even need this test. You've never tipped over in your life, have you? You're so stable!"},
        {max: 15, diagnosis: "Have you ever considered a career as a structural beam in a skyscraper?"},
        {max: 18, diagnosis: "You're half human half pyramid."},
        {max: 20, diagnosis: "Quite impressive. Tipping you over is like tipping over a flat sheet of paper: impossible!"},
        {max: 100, diagnosis: "Nah. You're lying, right? If I were a life insurance, I'd invest in you!"},
        {max: Infinity, diagnosis: "Have you ever tried getting a negative SHI?"}
    ]

    await terminal.animatePrint("Your Diagnosis is also ready:")
    await sleep(1000)

    let diagnosis = diagnoses[0]
    for (let i = 0; i < diagnoses.length; i++) {
        if (SHI < diagnoses[i].max) {
            diagnosis = diagnoses[i].diagnosis
            break
        }
    }

    await terminal.animatePrint(diagnosis)
}, {
    description: "calculate your SHI (stability height index)",
    args: {
        "s=shoe-size:n:1~99999": "shoe size (european)",
        "l=height:n:1~999999": "body height in centimeters"
    }
})

// ------------------- js/commands/shoot.js --------------------
terminal.addCommand("shoot", async function(args) {
	const world1 = `
+--------------------------------------------------------------------+
|                             |                                      |
|                             |                                      |
|                             |                                      |
|                             |                                      |
|                             |                                      |
|                             |                                      |
|                  +----------+             +------------+           |
|                                                                    |
|                                                                    |
|                                                                    |
|                                                                    |
|         +-------------------+             +            +-----------|
|                                           |                        |
|                                           |                        |
|                                           |                        |
|                                           |                        |
+--------------------------------------------------------------------+`

    await terminal.modules.import("game", window)
		
	let fieldSize = null
	
	const N = " "
	const P1 = "A"
	const P2 = "Y"

	const isWall = textContent => [
		"|", "+", "-"
	].includes(textContent)
	
	let field = []
	
	let gravity = new Vector2d(0, 0.03)
	let jumpVel = new Vector2d(0, -0.5)
	
	const TOTAL_JUMPS = 1

	terminal.printLine("            CONTROLS                              OBJECTIVE          ")
	terminal.printLine("+------------------------------+      +------------------------------+")
	terminal.printLine("| Player | Action | Key        |      | Shoot the other player       |")
	terminal.printLine("|--------+--------+------------|      | without getting shot first.  |")
	terminal.printLine("| A      | Move   | A/D        |      | Escape the Bullet Hell by    |")
	terminal.printLine("| A      | Jump   | W 	       |      | using the environment to     |")
	terminal.printLine("| A      | Shoot  | Space      |      | jump around (there is also   |")
	terminal.printLine("| Y      | Move   | Left/Right |      | a double jump!).             |")
	terminal.printLine("| Y      | Jump   | Up 	       |      |                              |")
	terminal.printLine("| Y      | Shoot  | Enter      |      |           HAVE FUN!          |")
	terminal.printLine("+------------------------------+      +------------------------------+")
	terminal.printLine("")
	
	let lineBreaks = []
	function printField(world=world1) {
		let worldData = world.split("\n").map(row => row.split(""))
		worldData.shift()

		fieldSize = new Vector2d(worldData[0].length, worldData.length)

		for (let i = 0; i < fieldSize.y; i++) {
			let row = []
			for (let j = 0; j < fieldSize.x; j++) {
				let data = worldData[i][j]
				let fill = data
				
				let element = terminal.print(fill, undefined, {forceElement: true})
				row.push(element)
			}
			lineBreaks.push(terminal.printLine("", undefined, {forceElement: true}))
			field.push(row)
		}
	}

	function removeField() {
		for (let row of field) {
			for (let element of row) {
				element.remove()
			}
		}
		for (let lineBreak of lineBreaks) {
			lineBreak.remove()
		}
		field = []
	}
	
	printField()
	
	let projectiles = []
	let keysDown = {}
	
	class Player {

		printLivesDisplay() {
			terminal.print(`player#${this.name} lives: `)
			this.liveOutput = terminal.print(this.lives, undefined, {forceElement: true})
			terminal.printLine()
		}

		updateLiveDisplay() {
			if (this.liveOutput)
				this.liveOutput.textContent = this.lives
		}

		constructor(name, pos, char) {
			this.name = name
			this.pos = pos
			this.char = char
			this.vel = new Vector2d(0, 0)
			this.prevPos = null
			this.shootCooldown = 0
			
			this.inputVel = new Vector2d(0, 0)
			this.inputJump = false
			this.inputShoot = false
			
			this.goingLeft = false
			
			this.jumpsLeft = 0
			this.speed = 0.5

			this.lives = args.l

			this.dead = false

			this.printLivesDisplay()
		}

		hurt(projectile) {
			if (projectile.deleteReady) return
			if (this.dead) return
			if (!gameRunning) return

			this.lives--
			this.updateLiveDisplay()
			projectile.deleteReady = true

			if (this.lives == 0) {
				this.dead = true
				gameRunning = false
				terminal.printLine(`GAME OVER! ${this.name} has been shot and no lives left!`)
			}
		}
		
		projectileDirection({projectileSpeed=1}={}) {
			if (!this.goingLeft) return new Vector2d(projectileSpeed, 0)
			else return new Vector2d(-projectileSpeed, 0)
		}
		
		projectileChar() {
			if (this.char == P1) return "."
			if (this.char == P2) return ","
		}

		get canShoot() {
			return this.shootCooldown <= 0
		}
		
		shoot() {
			if (!this.canShoot) return

			let projectile = new Projectile(this.pos.copy(), this.projectileDirection(), this.projectileChar())
			projectile.update()
			projectile.update()
			projectiles.push(projectile)

			this.shootCooldown = args.s
		}
		
		draw() {
			if (this.prevPos) {
				let prevX = Math.floor(this.prevPos.x)
				let prevY = Math.floor(this.prevPos.y)
				let prevElement = field[prevY][prevX]
				prevElement.textContent = N
			}
			
			let xPos = Math.floor(this.pos.x)
			let yPos = Math.floor(this.pos.y)
			let element = field[yPos][xPos]
			if (!element) {
				throw new Error(`Player ${this.name} out of bounds`)
			}
			
			element.textContent = this.char
		}
		
		getElement(dir) {
			let xPos = Math.floor(this.pos.x)
			let yPos = Math.floor(this.pos.y)
			try {
				return field[yPos + dir.y][xPos + dir.x]
			} catch {
				return null
			}
		}
		
		update() {
			this.prevPos = this.pos.copy()
			this.shootCooldown--
			
			let underElement = this.getElement(new Vector2d(0, 1))
			let isOnGround = underElement.textContent == "-" || underElement.textContent == "+"
			
			if (!isOnGround) {
				this.vel.x += gravity.x
				this.vel.y += gravity.y
			}
			
			this.pos.x += this.inputVel.x * this.speed
			this.pos.y += this.inputVel.y * this.speed
			
			if (this.inputJump) {
				if (isOnGround) {
					this.jumpsLeft = TOTAL_JUMPS
					this.vel.y = jumpVel.y
					this.pos.y -= 1
				} else if (this.jumpsLeft > 0) {
					this.jumpsLeft--
					this.vel.y = jumpVel.y
				}
				this.inputJump = false
			}
			
			if (this.inputVel.x < 0) {
				this.goingLeft = true
			} else if (this.inputVel.x > 0) {
				this.goingLeft = false
			}
			
			if (this.inputShoot) {
				this.shoot()
				this.inputShoot = false
			}
			
			this.pos.x += this.vel.x
			this.pos.y += this.vel.y

			let newElement = this.getElement(new Vector2d(0, 0))
			if (!newElement || (newElement.textContent != N && newElement.textContent != this.char)) {
				this.pos.y = this.prevPos.y
				this.pos.x = this.prevPos.x
				this.vel.y = 0
			}
		}
		
	}
	
	let player1 = new Player("A", new Vector2d(2, 2), P1)
	let player2 = new Player("Y", new Vector2d(fieldSize.x - 3, 2), P2)

	class Projectile {
	
		constructor(pos, vel, char) {
			this.pos = pos
			this.vel = vel
			this.prevPos = null
			this.char = char
			
			this.deleteReady = false
		}
		
		draw() {
			if (this.prevPos) {
				let prevX = Math.floor(this.prevPos.x)
				let prevY = Math.floor(this.prevPos.y)
				let prevElement = field[prevY][prevX]
				prevElement.textContent = N
			}

			let element = this.getCurrElement()
			
			if (this.deleteReady && element) {
				element.textContent = N
			} else if (element) {
				element.textContent = this.char
			}
		}

		getCurrElement() {
			let xPos = Math.floor(this.pos.x)
			let yPos = Math.floor(this.pos.y)
			try {
				return field[yPos][xPos]
			} catch (e) {
				return null
			}
		}
		
		update() {
			this.prevPos = this.pos.copy()
			this.pos.x += this.vel.x
			this.pos.y += this.vel.y
			let element = this.getCurrElement()
			if (!element || isWall(element.textContent)) {
				this.deleteReady = true
				this.pos = this.prevPos
				return null
			}

			if (element.textContent == player1.char) {
				return player1
			} else if (element.textContent == player2.char) {
				return player2
			}

			return null
		}
		
	}

	function updatePlayerInputs() {
		if (keysDown["p1-up"]) {
			player1.inputJump = true
			keysDown["p1-up"] = false
		}

		if (keysDown["p2-up"]) {
			player2.inputJump = true
			keysDown["p2-up"] = false
		}

		if (keysDown["p1-left"]) player1.inputVel.x = -1
		else if (keysDown["p1-right"]) player1.inputVel.x = 1
		else player1.inputVel.x = 0

		if (keysDown["p2-left"]) player2.inputVel.x = -1
		else if (keysDown["p2-right"]) player2.inputVel.x = 1
		else player2.inputVel.x = 0

		if (keysDown["p1-shoot"]) {
			player1.inputShoot = true
			keysDown["p1-shoot"] = false
		}

		if (keysDown["p2-shoot"]) {
			player2.inputShoot = true
			keysDown["p2-shoot"] = false
		}
	}
	
	let gameRunning = true

	function keyToCode(key) {
		switch (key) {
			case "w": return "p1-up"
			case "a": return "p1-left"
			case "s": return "p1-down"
			case "d": return "p1-right"
			case " ": return "p1-shoot"
			case "shoot1": return "p1-shoot"
			case "arrowup": return "p2-up"
			case "arrowleft": return "p2-left"
			case "arrowdown": return "p2-down"
			case "arrowright": return "p2-right"
			case "enter": return "p2-shoot"
			case "shoot2": return "p2-shoot"
		}
	}
	
	addEventListener("keydown", event => {
		if (gameRunning && event.repeat) event.preventDefault()
		if (event.repeat || !gameRunning) return
		let key = event.key.toLowerCase()
		let code = keyToCode(key)
		if (code) {
			keysDown[code] = true
			event.preventDefault()
		}
	})
	
	addEventListener("keyup", event => {
		if (gameRunning && event.repeat) event.preventDefault()
		if (event.repeat || !gameRunning) return
		let key = event.key.toLowerCase()
		let code = keyToCode(key)
		if (code) {
			keysDown[code] = false
			event.preventDefault()
		}
	})

	if (terminal.mobileKeyboard) {
		terminal.mobileKeyboard.updateLayout([
			[null, "W", null, null, "↑", null],
			["A", "S", "D", "←", "↓", "→"],
			["shoot1", "shoot2"],
			["STRG+C"]
		])

		terminal.mobileKeyboard.onkeydown = (e, keyCode) => {
			let code = keyToCode(keyCode.toLowerCase())
			if (code) {
				keysDown[code] = true
			}
		}

		terminal.mobileKeyboard.onkeyup = (e, keyCode) => {
			let code = keyToCode(keyCode.toLowerCase())
			if (code) {
				keysDown[code] = false
			}
		}
	}
	
	const gameUpdate = () => {
		if (!gameRunning) return
		
		projectiles = projectiles.filter(p => !p.deleteReady)
		
		for (let p of projectiles) {
			let hitPlayer = p.update()
			p.draw()

			if (hitPlayer) {
				hitPlayer.hurt(p)
			}
		}
		
		updatePlayerInputs()

		player1.update()
		player1.draw()
		
		player2.update()
		player2.draw()
	}

	let intervalFunc = setInterval(gameUpdate, 1000 / 60)

	terminal.scroll()

	terminal.onInterrupt(() => {
		gameRunning = false
		clearInterval(intervalFunc)
		removeField()
	})
	
	while (gameRunning) {
		await sleep(100)
	}

	removeField()
	clearInterval(intervalFunc)

	// wait for players to realize the game is over
	await sleep(2000)
	
}, {
	description: "Play a game of Shoot against another player locally",
	isGame: true,
	args: {
		"?l=lives:i:1~100": "The number of lives each player has",
		"?s=shoot-delay:i:0~1000": "The number of frames between each shot"
	},
	defaultValues: {
		l: 3,
		s: 20
	}
})


// ------------------- js/commands/shutdown.js --------------------
terminal.addCommand("shutdown", async function() {
    terminal.print("Shutting down")
    for (let i = 0; i < 10; i++) {
        terminal.print(".")
        await sleep(300)
    }
    terminal.printLine()
    await terminal.animatePrint("Initiating Shutdown Process......")
    for (let i = 10; i > 0; i--) {
        terminal.print(i, Color.COLOR_1)
        terminal.printLine(" Seconds left")
        await sleep(1000)
    }
    await sleep(1000)
    await terminal.animatePrint("...?")
    await sleep(1000)
    await terminal.animatePrint("Why didn't anything happen?")
    await sleep(1000)
    await terminal.animatePrint("I guess this is just a website.")
    await sleep(1000)
    await terminal.animatePrint("Let's just not shutdown. Have a good day!")
}, {
    description: "shutdown the terminal"
})



// ------------------- js/commands/simulate.js --------------------
"use strict"

terminal.addCommand("simulate", async function(args) {
    await terminal.modules.import("game", window)
    await terminal.modules.load("window", terminal)
    const simulationName = {
        "2-masses-1-spring": "2 Masses 1 Spring Simulation",
        "planets-gravity": "Planets Gravity Simulation (Legacy)",
        "3-masses-3-springs": "3 Masses 3 Springs Simulation",
        "1d-3-masses-2-springs": "1d 3 Masses 2 Springs Simulation",
        "2-body-problem": "2 Body Problem Simulation",
        "3-body-problem": "3 Body Problem Simulation",
        "4-body-problem": "4 Body Problem Simulation",
        "5-body-problem": "5 Body Problem Simulation",
        "6-body-problem": "6 Body Problem Simulation",
        "7-body-problem": "7 Body Problem Simulation",
        "8-body-problem": "8 Body Problem Simulation",
        "circle-gravity": "Circle Gravity Simulation"
    }[args.simulation]
    
    const defaultDeltaTime = 1000 / 60

    // my professor shared these simulations with the class.
    // so here's a 10% chance to encounter a rickroll!
    // (but only once per device and only when simulating gravity)
    if (
        !localStorage.getItem("gravity-rickroll")
        && Math.random() < 0.1
        && args.simulation == "planets-gravity"
    ) {
        localStorage.setItem("gravity-rickroll", true)
        terminal.printLine("It's your unlucky day!")
        await sleep(1000)
        terminal.href("https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    }

    let terminalWindow = terminal.modules.window.make({
        name: simulationName ?? "Simulation", fullscreen: args.fullscreen})
    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    class PointMass {

        constructor(mass, pos, {
            vel = new Vector2d(0, 0),
            acc = new Vector2d(0, 0),
            color = "#a5a1ff",
            drawPath = false,
            pathColor = "blue",
            maxPathLength = 5000,
        }={}) {
            this.mass = mass
            this.pos = pos
            this.vel = vel
            this.acc = acc

            this.color = color
            this.drawPath = drawPath
            this.pathColor = pathColor
            this.maxPathLength = maxPathLength

            this.path = []
        }

        get radius() {
            return 20 * Math.sqrt(getValue(this.mass))
        }

    }

    class Spring {

        constructor(m1, m2, k, length) {
            this.m1 = m1
            this.m2 = m2
            this.k = k
            this.length = length
        }

    }

    class SimulationParameter {

        constructor(id, key, action, value, options) {
            this.id = id
            this.key = key
            this.action = action
            this.value = value
            this.options = options
        }

        change() {
            const index = this.options.indexOf(this.value) ?? 0
            this.value = this.options[(index + 1) % this.options.length]
        }

    }

    class SimulationSetup {

        constructor() {
            this.masses = []
            this.springs = []
            this.parameters = []
            this.updateRules = []
            this.initRules = []

            this.currMousePos = null
            this.viewCentre = new Vector2d(0, 0)

            this.friction = 0
            this.drawCOM = false
            this.COMColor = "#ed9bff"
            this.drawCOMPath = true
            this.COMMaxPathLength = 1000
            this.COMPathColor = "violet"
            this.COMRadius = 20
        }
        
        addInitRule(rule) {
            this.initRules.push(rule)
        }

        addUpdateRule(rule) {
            this.updateRules.push(rule)
            return this
        }

        enableCOM({
            color="#ed9bff",
            drawPath=true,
            radius=20,
            maxPathLength=1000,
            pathColor="violet"
        }={}) {
            this.drawCOM = true
            this.drawCOMPath = drawPath
            this.maxPathLength = maxPathLength
            this.pathColor = pathColor
            this.COMRadius = radius
            this.COMColor = color
            return this
        }

        setFriction(friction) {
            this.friction = friction
            return this
        }

        addSpring(spring) {
            this.springs.push(spring)
            return this
        }

        addMass(mass) {
            this.masses.push(mass)
            return this
        }

        addParameter(param) {
            this.parameters.push(param)
            return this
        }

    }

    function getValue(paramOrNumber) {
        if (paramOrNumber instanceof SimulationParameter) {
            return paramOrNumber.value
        } else {
            return paramOrNumber
        }
    }

    function make2dSimulation(setup) {
        const viewCentreTarget = new Vector2d(0, 0)
        const COMPath = []

        const R = () => {
            const pos = new Vector2d(0, 0)
            let massSum = 0
            for (const obj of setup.masses) {
                pos.iadd(obj.pos.scale(getValue(obj.mass)))
                massSum += getValue(obj.mass)
            }

            return pos.scale(1 / massSum)
        }

        function screenPos(pos) {
            const middle = new Vector2d(canvas.width / 2, canvas.height / 2)
            return pos.add(middle).add(setup.viewCentre)
        }

        function drawPath(path, color) {
            if (path.length < 2) {
                return
            }

            context.beginPath()

            for (let i = 0; i < path.length; i++) {
                const pos = screenPos(path[i])
                if (i == 0) {
                    context.moveTo(pos.x, pos.y)
                } else {
                    context.lineTo(pos.x, pos.y)
                }
            }

            context.strokeStyle = color
            context.lineWidth = 1
            context.stroke()
        }

        function drawBackground(gridSize=50) {
            context.fillStyle = "white"
            context.fillRect(0, 0, canvas.width, canvas.height)

            const startX = setup.viewCentre.x % gridSize
            const startY = setup.viewCentre.y % gridSize

            function drawGridLine(x1, y1, x2, y2) {
                context.moveTo(x1, y1)
                context.lineTo(x2, y2)
                context.strokeStyle = "#eee"
                context.lineWidth = 1
                context.stroke()
            }

            for (let x = startX; x < canvas.width; x += gridSize) {
                drawGridLine(x, 0, x, canvas.height)
            }

            for (let y = startY; y < canvas.height; y += gridSize) {
                drawGridLine(0, y, canvas.width, y)
            }
        }

        function screenPosToSimulationPos(screenPos) {
            const middle = new Vector2d(canvas.width / 2, canvas.height / 2)
            return screenPos.sub(setup.viewCentre).sub(middle)
        }

        let cameraFollowing = true
        let simulationActive = true

        let focusMassNumber = null

        addEventListener("keydown", event => {
            if (event.key == " ") {
                focusMassNumber = null
                cameraFollowing = !cameraFollowing
                viewCentreTarget.set(setup.viewCentre)
            }

            if (event.key == "j") {
                if (focusMassNumber === null) {
                    focusMassNumber = 0
                } else {
                    focusMassNumber++
                }
            }

            if (event.key == "s") {
                simulationActive = !simulationActive
            }

            const cameraSpeed = 100
            if (event.key == "ArrowUp") {
                viewCentreTarget.iadd(new Vector2d(0, 1).scale(cameraSpeed))
            } else if (event.key == "ArrowDown") {
                viewCentreTarget.iadd(new Vector2d(0, 1).scale(-cameraSpeed))
            } else if (event.key == "ArrowLeft") {
                viewCentreTarget.iadd(new Vector2d(1, 0).scale(cameraSpeed))
            } else if (event.key == "ArrowRight") {
                viewCentreTarget.iadd(new Vector2d(1, 0).scale(-cameraSpeed))
            }

            for (let param of setup.parameters) {
                if (event.key == param.key) {
                    param.change()
                }
            }
        })

        let focusedObj = null
        setup.currMousePos = null

        canvas.onmousedown = event => {
            setup.currMousePos = Vector2d.fromEvent(event, canvas)
            const mouse = screenPosToSimulationPos(setup.currMousePos)

            let closestObj = null
            let minDistance = Infinity

            for (let obj of setup.masses) {
                const dist = mouse.distance(obj.pos)
                if (minDistance > dist) {
                    closestObj = obj
                    minDistance = dist
                }
            }

            if (minDistance < 200 && closestObj) {
                focusedObj = closestObj
            }
        }

        canvas.onmousemove = event => {
            const mouse = Vector2d.fromEvent(event, canvas)
            setup.currMousePos = mouse
        }

        canvas.onmouseup = event => {
            if (focusedObj && setup.currMousePos) {
                const mousePos = screenPosToSimulationPos(setup.currMousePos)
                focusedObj.vel.iadd(mousePos.sub(focusedObj.pos).scale(0.03))
            }

            focusedObj = null
            setup.currMousePos = null
        }

        canvas.ontouchstart = event => canvas.onmousedown(event)
        canvas.ontouchmove = event => canvas.onmousemove(event)
        canvas.ontouchend = event => canvas.onmouseup(event)

        function drawArrow(headPos, tailPos, color) {
            const delta = headPos.sub(tailPos)

            context.save()
            context.translate(screenPos(tailPos).x, screenPos(tailPos).y)
            context.rotate(delta.angle)
            context.scale(delta.length, delta.length)

            const lineWidth = Math.min(Math.max(3, delta.length * 0.05), 10)
            context.lineWidth = lineWidth / delta.length

            function drawLine(x1, y1, x2, y2) {
                context.beginPath()
                context.moveTo(x1, y1)
                context.lineTo(x2, y2)
                context.stroke()
            }
            
            context.lineCap = "round"
            context.strokeStyle = color
            drawLine(1, 0, 0, 0)
            drawLine(0, 0, 0.2, -0.2)
            drawLine(0, 0, 0.2, 0.2)

            context.restore()
        }

        function drawInstructions() {
            const lines = [
                "space : toggle camera",
                "drag a mass to kick it",
                "",
                `camera=${cameraFollowing ? "follow" : "manual"}`
            ]

            for (const param of setup.parameters) {
                lines.unshift(`${param.key.padEnd(5)} : ${param.action}`)
                lines.push(`${param.id}=${param.value}`)
            }

            if (!cameraFollowing) {
                lines.unshift("arrow : move camera")
            }

            context.font = "15px monospace"
            context.fillStyle = "black"
            context.textBaseline = "top"
            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], 10, i * 20 + 10)
            }
        }

        function addToPath(path, v, maxPathLength) {
            path.unshift(v.copy())
            if (path.length > maxPathLength) {
                path.pop()
            }
        }

        function update(dt) {
            if (!simulationActive) {
                return
            }

            for (const spring of setup.springs) {
                const [m1, m2] = [spring.m1, spring.m2]
                const displacement = m1.pos.distance(m2.pos) - getValue(spring.length)
                const forceLength = -getValue(spring.k) * displacement
                m1.vel.iadd(m1.pos.sub(m2.pos).normalized.scale(forceLength / getValue(m1.mass)))
                m2.vel.iadd(m2.pos.sub(m1.pos).normalized.scale(forceLength / getValue(m2.mass)))
            }

            for (const rule of setup.updateRules) {
                rule(dt)
            }

            for (const obj of setup.masses) {
                obj.vel.iadd(obj.acc.scale(dt / 16))
                obj.pos.iadd(obj.vel.scale(dt / 16))
                obj.vel.iscale(1 - getValue(setup.friction))

                if (obj.drawPath) {
                    addToPath(obj.path, obj.pos, obj.maxPathLength)
                }
            }

            if (setup.drawCOM) {
                addToPath(COMPath, R(), setup.COMMaxPathLength)
            }

            if (focusMassNumber !== null) {
                const mass = setup.masses[focusMassNumber % setup.masses.length]
                viewCentreTarget.set(mass.pos.scale(-1))
            } else if (cameraFollowing) { 
                viewCentreTarget.set(R().scale(-1))
            }

            setup.viewCentre.iadd(viewCentreTarget.sub(setup.viewCentre).scale(0.05))
        }

        function drawBall(pos, color, radius) {
            context.beginPath()
            context.arc(pos.x, pos.y, radius, 0, Math.PI * 2)

            context.fillStyle = color
            context.fill()

            context.strokeStyle = "black"
            context.lineWidth = 1
            context.stroke()
        }

        function drawSpring(p1, p2, color, steps=20) {
            const pos = t => p1.add(p2.sub(p1).scale(t))

            context.beginPath()
            context.moveTo(p1.x, p1.y)

            const normal = p2.sub(p1).rotate(Math.PI / 2).normalized
            
            for (let i = 0; i < steps; i++) {
                const direction = i % 2 == 0 ? 1 : -1
                const p = pos((i + 1) / (steps + 1)).add(normal.scale(10 * direction))
                context.lineTo(p.x, p.y)
            }

            context.lineTo(p2.x, p2.y)
            context.lineCap = "round"
            context.lineWidth = 1
            context.strokeStyle = color
            context.stroke()
        }

        function render() {
            canvas.width = canvas.clientWidth
            canvas.height = canvas.clientHeight
            context.clearRect(0, 0, canvas.width, canvas.height)
            drawBackground()

            drawInstructions()

            for (const obj of setup.masses.filter(m => m.drawPath)) {
                drawPath(obj.path, obj.pathColor)
            }

            if (setup.drawCOMPath) {
                drawPath(COMPath, setup.COMPathColor)
            }

            for (const spring of setup.springs) {
                drawSpring(
                    screenPos(spring.m1.pos),
                    screenPos(spring.m2.pos),
                    "black", Math.floor(getValue(spring.length) / 20))
            }

            for (const obj of setup.masses) {
                drawBall(screenPos(obj.pos), obj.color, obj.radius)
            }

            if (setup.drawCOM) {
                drawBall(screenPos(R()), setup.COMColor, setup.COMRadius)
            }

            if (focusedObj && setup.currMousePos) {
                drawArrow(focusedObj.pos, screenPosToSimulationPos(setup.currMousePos), focusedObj.pathColor)
            }
        }

        for (const rule of setup.initRules) {
            rule()
        }

        if (args["skip-ticks"] != null) {
            const skipTicks = args["skip-ticks"]
            if (skipTicks < 0) {
                terminalWindow.close()
                simulationRunning = false
                throw new Error("Can't skip negative number of ticks")
            }
            
            for (let i = 0; i < skipTicks; i++) {
                update(defaultDeltaTime)
            }
        }

        simulationActive = !args["start-being-halted"]

        return {render, update}
    }

    function makeNBodyProblem(numMasses) {
        return () => {
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0, [0, 0.0001, 0.001, 0.01, 0.1])

            const gravityParam = new SimulationParameter(
                "gravity_const", "g", "change gravity const",
                args.gravity ?? 1000, [100, 300, 500, 750, 1000, 1500])

            const massColors = []
            let hueDegOffset = (numMasses == 3) ? 0 : Math.PI / 8
            for (let i = 0; i < numMasses; i++) {
                const hue = (i / numMasses + hueDegOffset) % 1
                const mass = Color.hsl(hue, 0.8, 0.7).string.hex
                const path = Color.hsl(hue, 1, 0.5).string.hex
                massColors.push({mass, path})
            }

            for (let i = 0; i < numMasses; i++) {
                const angle = i / numMasses * (Math.PI * 2)
                const massColor = massColors[i % massColors.length]
                const mass = new PointMass(1, Vector2d.fromAngle(angle).scale(200),
                    {color: massColor.mass, drawPath: true, pathColor: massColor.path,
                        vel: Vector2d.fromAngle(angle).rotate(Math.PI / 2)})
                setup.addMass(mass)
                setup.enableCOM({radius: 5})
            }

            setup.setFriction(frictionParam)
            setup.addParameter(gravityParam)
                 .addParameter(frictionParam)

            setup.addUpdateRule(dt => {
                for (const obj of setup.masses) {
                    for (const other of setup.masses) {
                        if (obj == other) {
                            continue
                        }

                        const delta = other.pos.sub(obj.pos)
                        const dir = delta.normalized

                        // newtons universal law of gravity:
                        const gravityStrength = Math.min(getValue(gravityParam) * getValue(other.mass) / (delta.length ** 2), 0.1)
                        obj.vel.iadd(dir.scale(gravityStrength).scale(dt / 16))
                    }
                }
            })

            return make2dSimulation(setup)
        }
    }

    const simulation = {
        "2-masses-1-spring": () => {
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0.001, [0, 0.0001, 0.001, 0.01, 0.1])
            const massParam = new SimulationParameter(
                "mass_ratio", "m", "change mass ratio",
                1, [1, 2, 5, 10])
            const springLengthParam = new SimulationParameter(
                "spring_length", "l", "change spring length",
                200, [50, 100, 200, 300, 500])
            const springConstantParam = new SimulationParameter(
                "spring_const", "k", "change spring constant",
                0.001, [0.1, 0.01, 0.001, 0.0001, 0.00001])

            const m1 = new PointMass(massParam, new Vector2d(-100, 0),
                {color: "#94afff", drawPath: true, pathColor: "blue"})
            const m2 = new PointMass(1, new Vector2d(100, 0),
                {color: "#ff9494", drawPath: true, pathColor: "red"})

            setup.addParameter(frictionParam).addParameter(massParam)
                .addParameter(springConstantParam).addParameter(springLengthParam)

            setup.addMass(m1).addMass(m2)
            setup.addSpring(new Spring(m1, m2, springConstantParam, springLengthParam))

            setup.setFriction(frictionParam)
            setup.enableCOM({
                color: "#ed9bff",
                radius: 5,
                pathColor: "violet"
            })

            return make2dSimulation(setup)
        },

        "3-masses-3-springs": () => {
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0.001, [0, 0.0001, 0.001, 0.01, 0.1])
            const springLengthParam = new SimulationParameter(
                "spring_length", "l", "change spring length",
                300, [100, 200, 300, 400, 500])
            const springConstantParam = new SimulationParameter(
                "spring_const", "k", "change spring constant",
                0.005, [0.1, 0.01, 0.005, 0.001, 0.0001, 0.00001])

            const m1Pos = new Vector2d(0, springLengthParam.value / 2 / Math.cos(Math.PI / 6))

            const m1 = new PointMass(1, m1Pos,
                {color: "#94afff", drawPath: true, pathColor: "blue"})
            const m2 = new PointMass(1, m1Pos.rotate(Math.PI * 2 / 3),
                {color: "#ff9494", drawPath: true, pathColor: "red"})
            const m3 = new PointMass(1, m1Pos.rotate(Math.PI * -2 / 3),
                {color: "#a1ff9a", drawPath: true, pathColor: "#00ff00"})

            setup.addParameter(frictionParam)
                .addParameter(springConstantParam)
                .addParameter(springLengthParam)

            setup.addMass(m1).addMass(m2).addMass(m3)
            setup.addSpring(new Spring(m1, m2, springConstantParam, springLengthParam))
            setup.addSpring(new Spring(m2, m3, springConstantParam, springLengthParam))
            setup.addSpring(new Spring(m1, m3, springConstantParam, springLengthParam))

            setup.setFriction(frictionParam)
            setup.enableCOM({radius: 5})

            return make2dSimulation(setup)
        },

        "planets-gravity": () => {
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0, [0, 0.0001, 0.001, 0.01, 0.1])
            const massParam = new SimulationParameter(
                "mass_ratio", "m", "change mass ratio",
                1, [1, 2, 5, 10, 30])
            const gravityParam = new SimulationParameter(
                "gravity_const", "g", "change gravity const",
                1000, [100, 300, 500, 750, 1000, 1500])

            const m1 = new PointMass(massParam, new Vector2d(-300, 0),
                {color: "#94afff", drawPath: true, pathColor: "blue",
                 vel: new Vector2d(0, 0.5)})
            const m2 = new PointMass(1, new Vector2d(300, 0),
                {color: "#ff9494", drawPath: true, pathColor: "red",
                 vel: new Vector2d(0, -0.5)})

            setup.setFriction(frictionParam)
            setup.addMass(m1).addMass(m2)
            setup.addParameter(gravityParam).addParameter(massParam).addParameter(frictionParam)

            setup.addUpdateRule(dt => {
                for (const obj of setup.masses) {
                    for (const other of setup.masses) {
                        if (obj == other) {
                            continue
                        }

                        const delta = other.pos.sub(obj.pos)
                        const dir = delta.normalized

                        // newtons universal law of gravity:
                        const gravityStrength = Math.min(getValue(gravityParam) * getValue(other.mass) / (delta.length ** 2), 2)
                        obj.vel.iadd(dir.scale(gravityStrength).scale(dt / 16))
                    }
                }
            })

            return make2dSimulation(setup)
        },

        "2-body-problem": makeNBodyProblem(2),
        "3-body-problem": makeNBodyProblem(3),
        "4-body-problem": makeNBodyProblem(4),
        "5-body-problem": makeNBodyProblem(5),
        "6-body-problem": makeNBodyProblem(6),
        "7-body-problem": makeNBodyProblem(7),
        "8-body-problem": makeNBodyProblem(8),

        "circle-gravity": () => {
            
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0, [0, 0.0001, 0.001, 0.01, 0.1])
            const massParam = new SimulationParameter(
                "mass_ratio", "m", "change mass ratio",
                1, [1, 2, 5, 10, 30])
            const gravityParam = new SimulationParameter(
                "gravity_const", "g", "change gravity const",
                1000, [100, 300, 500, 750, 1000, 1500])

            const m1 = new PointMass(massParam, new Vector2d(0, 0),
                {color: "#94afff", drawPath: true, pathColor: "blue",
                 vel: new Vector2d(0, 0)})
            const m2 = new PointMass(1, new Vector2d(300, 0),
                {color: "#ff9494", drawPath: true, pathColor: "red",
                 vel: new Vector2d(0, 1)})

            setup.setFriction(frictionParam)
            setup.addMass(m1).addMass(m2)
            setup.addParameter(gravityParam).addParameter(massParam).addParameter(frictionParam)

            setup.addUpdateRule(dt => {
                for (const obj of setup.masses) {
                    for (const other of setup.masses) {
                        if (obj == other) {
                            continue
                        }

                        const delta = other.pos.sub(obj.pos)
                        const dir = delta.normalized

                        // newtons universal law of gravity:
                        const gravityStrength = Math.min(getValue(gravityParam) * getValue(other.mass) / (delta.length ** 2), 2)
                        obj.vel.iadd(dir.scale(gravityStrength).scale(dt / 16))
                    }
                }
            })

            return make2dSimulation(setup)
        },

        "1d-3-masses-2-springs": () => {
            const setup = new SimulationSetup()

            const frictionParam = new SimulationParameter(
                "friction", "f", "change friction",
                0.001, [0, 0.0001, 0.001, 0.01, 0.1])
            const springLengthParam = new SimulationParameter(
                "spring_length", "l", "change spring length",
                200, [50, 100, 200, 300, 500])
            const springConstantParam = new SimulationParameter(
                "spring_const", "k", "change spring constant",
                0.005, [0.1, 0.01, 0.005, 0.001, 0.0001, 0.00001])

            const m1 = new PointMass(1, new Vector2d(-200, 0),
                {color: "#94afff", drawPath: true, pathColor: "blue"})
            const m2 = new PointMass(1, new Vector2d(0, 0),
                {color: "#ff9494", drawPath: true, pathColor: "red"})
            const m3 = new PointMass(1, new Vector2d(200, 0),
                {color: "#a1ff9a", drawPath: true, pathColor: "#00ff00"})

            setup.addParameter(frictionParam)
                .addParameter(springConstantParam)
                .addParameter(springLengthParam)

            setup.addMass(m1).addMass(m2).addMass(m3)
            setup.addSpring(new Spring(m1, m2, springConstantParam, springLengthParam))
            setup.addSpring(new Spring(m2, m3, springConstantParam, springLengthParam))

            let objY = 0
            setup.addUpdateRule(dt => {
                objY += 0.03 * dt

                for (const obj of setup.masses) {
                    obj.pos.y = objY
                    obj.vel.y = 0
                    obj.acc.y = 0
                }

                if (setup.currMousePos) {
                    setup.currMousePos.y = setup.masses[0].pos.y + setup.viewCentre.y + canvas.height / 2
                }
            })

            setup.setFriction(frictionParam)
            setup.enableCOM({radius: 5})

            return make2dSimulation(setup)
        }
    }[args.simulation]()

    let simulationRunning = true

    terminal.onInterrupt(() => {
        terminalWindow.close()
        simulationRunning = false
    })

    function loop() {
        if (!simulationRunning) {
            return
        }

        simulation.update(defaultDeltaTime)
        simulation.render()

        terminal.window.requestAnimationFrame(loop)
    }

    loop()
    while (simulationRunning) {
        await sleep(1000)
    }

    terminalWindow.close()

}, {
    description: "Run a simulation. Doesn't work well on phones",
    args: {
        "s=simulation:e:2-masses-1-spring|3-masses-3-springs|planets-gravity|1d-3-masses-2-springs|2-body-problem|3-body-problem|4-body-problem|5-body-problem|6-body-problem|7-body-problem|8-body-problem|circle-gravity": "simulation to run",
        "?f=fullscreen:b": "run application in fullscreen",
        "?g=gravity:n:0~99999999": "initial gravity constant in gravity based simulations",
        "?s=skip-ticks:i": "ticks to simulate before rendering",
        "?h=start-being-halted:b": "simulation will start being stopped"
    }
})

// ------------------- js/commands/sl.js --------------------
terminal.addCommand("sl", async function(args) {
    let FRAME = "", FRAMES = []
    FRAME  = "     ooOOOO\n"
    FRAME += "    oo      _____\n"
    FRAME += "   _I__n_n__||_|| ________\n"
    FRAME += " >(_________|_7_|-|_NOEL_|\n"
    FRAME += "  /o ()()-()() o   oo  oo"
    FRAMES.push(FRAME)

    FRAME =  "     oo OO OO\n"
    FRAME += "    oo      _____\n"
    FRAME += "   _I__n_n__||_|| ________\n"
    FRAME += " >(_________|_7_|-|_NOEL_|\n"
    FRAME += "  /o ()-()()() o   oo  oo"
    FRAMES.push(FRAME)

    FRAME =  "     oo O O O O\n"
    FRAME += "    oo      _____\n"
    FRAME += "   _I__n_n__||_|| ________\n"
    FRAME += " >(_________|_7_|-|_NOEL_|\n"
    FRAME += "  /o ()()-()() o   oo  oo"
    FRAMES.push(FRAME)

    FRAME =  "      o o o  OO O O\n"
    FRAME += "    o       _____\n"
    FRAME += "   _I__n_n__||_|| ________\n"
    FRAME += " >(_________|_7_|-|_NOEL_|\n"
    FRAME += "  /o ()()()-() o   oo  oo"
    FRAMES.push(FRAME)

    FRAME =  "     ooOOOO  o  O \n"
    FRAME += "    oo      _____\n"
    FRAME += "   _I__n_n__||_|| ________\n"
    FRAME += " >(_________|_7_|-|_NOEL_|\n"
    FRAME += "  /o ()()-()() o   oo  oo"
    FRAMES.push(FRAME)
    
    await terminal.modules.load("window", terminal)

    const terminalWindow = terminal.modules.window.make({name: "Steam Locomotive", fullscreen: true})
    const CANVAS = terminalWindow.CANVAS
    const CONTEXT = terminalWindow.CONTEXT

    function drawText(x, y, text, color="#348d36") {
        CONTEXT.fillStyle = "black"
        CONTEXT.clearRect(x - 1, y - 1, CHARWIDTH + 1, 22)
        CONTEXT.fillStyle = color
        CONTEXT.fillText(text, x, y)
    }

    function CHARWIDTH() {
        return CONTEXT.measureText("A").width * 1.8
    }

    function drawTrain(x, frameIndex, y) {
        let frame = FRAMES[frameIndex]
        let currY = y ?? CANVAS.height / 2 - 50
        for (let line of frame.split("\n")) {
            drawText(x, currY, line, Color.WHITE)
            currY += 20
        }
    }

    function generateFlightPath({
        numWaves=10,
        numTries=10000,
    }={}) {
        const arr = f => Array.from({length: numWaves}, f)
        const makeRandomPath = () => {
            // f(x) = a * sin(b * x + c) + d
            let a = arr(() => Math.random() * 1)
            let b = arr(() => Math.random() * 5 + Math.PI * 2)
            let c = arr(() => Math.random() * Math.PI * 2)
            let d = arr(() => (Math.random() - 0.5) * 2 * 2)
            return x => {
                let sum = 0
                for (let i = 0; i < numWaves; i++)
                    sum += a[i] * Math.sin(b[i] * x + c[i]) + d[i]
                return sum
            }
        }

        const checkRandomPath = f => {
            let highestMidOffset = 0
            for (let x = 0; x < 1; x += 0.01) {
                let y = f(x)
                if (y > 1 || y < 0)
                    return false
                let midOffset = Math.abs(y - 0.5)
                highestMidOffset = Math.max(highestMidOffset, midOffset)
            }
            return highestMidOffset > 0.2
        }

        for (let i = 0; i < numTries; i++) {
            let f = makeRandomPath()
            if (checkRandomPath(f))
                return f
        }

        return null
    }

    let running = true

    const msPerFrame = 40
    const trainTime = Math.random() * 10000 + 10000
    const startTime = Date.now()
    let flightPath = null
    if (args.f) {
        flightPath = generateFlightPath()
        if (flightPath == null) {
            terminal.printEasterEgg("Navigator-Egg")
            throw new Error("Flight Navigation not found.")
        }
    } 
    function draw() {
        let frameIndex = Math.floor((Date.now() / msPerFrame) % FRAMES.length)
        CONTEXT.fillStyle = "#000000"
        CONTEXT.globalAlpha = 0.2
        CONTEXT.fillRect(0, 0, CANVAS.width, CANVAS.height)
        CONTEXT.globalAlpha = 1 
        const deltaTime = (Date.now() - startTime) / trainTime
        const x = CANVAS.width - deltaTime * CANVAS.width
        
        if (args.f) {
            const y = flightPath(deltaTime) * CANVAS.height - 50
            drawTrain(x, frameIndex, y)
        } else {
            drawTrain(x, frameIndex)
        }

        if (x < -300) running = false

        if (running)
            terminal.window.requestAnimationFrame(draw)
    }

    draw()

    while (running) {
        await new Promise(resolve => setTimeout(resolve, 100))
    }

    terminalWindow.close()
}, {
    description: "Steam Locomotive",
    args: {
        "?f=F:b": "Make it fly"
    }
})

// ------------------- js/commands/sleep.js --------------------
terminal.addCommand("sleep", async function(args) {
    await sleep(args.seconds * 1000)
}, {
    description: "sleep for a number of seconds",
    args: ["seconds:n:0~1000000"]
})


// ------------------- js/commands/slime.js --------------------
terminal.addCommand("slime", async function() {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../slime/",
        name: "Slime Simulation"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "Start a slime simulation"
})

// ------------------- js/commands/snake.js --------------------
terminal.addCommand("snake", async function(args) {
    await terminal.modules.import("game", window)

    const width = 30
    const height = 20
    const speed = 150 / args.s
    const startLength = 10

    const EMPTY = 0
    const SNAKE = 1
    const FOOD = 2
    const WALLY = 3
    const WALLX = 4
    const WALLC1 = 5
    const WALLC2 = 6
    let snake = [[width / 2, height / 2]]
    let direction = [1, 0]
    let snakeAlive = true

    let cells = null
    let foodPos = null
    function updateCells() {
        cells = Array.from({length: height}, () => Array.from({length: width}, () => EMPTY))
        for (let i = 0; i < width; i++) {
            cells[0][i] = WALLX
            cells[height - 1][i] = WALLX
        }
        for (let i = 0; i < height; i++) {
            cells[i][0] = WALLY
            cells[i][width - 1] = WALLY
        }
        cells[0][0] = WALLC1
        cells[0][width - 1] = WALLC2
        cells[height - 1][0] = WALLC1
        cells[height - 1][width - 1] = WALLC2
        for (let [x, y] of snake) {
            cells[y][x] = SNAKE
        }
        if (foodPos != null)
            cells[foodPos[1]][foodPos[0]] = FOOD
        return cells
    }
    updateCells()

    function makeNewFood() {
        let x = Math.floor(Math.random() * width)
        let y = Math.floor(Math.random() * height)
        if (cells[y][x] == EMPTY) {
            return [x, y]
        } else {
            return makeNewFood()
        }
    }
    foodPos = makeNewFood()

    function enlargenSnake() {
        snake.push([...snake[snake.length - 1]])
        foodPos = makeNewFood()
    }

    for (let i = 0; i < startLength; i++) {
        enlargenSnake()
    }

    function updateSnake() {
        if (moves.length > 0) {
            let newDirection = moves.shift()
            if (newDirection[0] != -direction[0] || newDirection[1] != -direction[1]) {
                direction = newDirection
            }
        }
        let newHead = [snake[0][0] + direction[0], snake[0][1] + direction[1]]
        for (let i = snake.length - 1; i >= 0; i--) {
            if (i == 0) {
                snake[i] = newHead
            } else {
                snake[i] = [...snake[i - 1]]
            }
            if (snake[i][0] >= width - 1) snake[i][0] = 1
            if (snake[i][0] <= 0) snake[i][0] = width - 2
            if (snake[i][1] >= height - 1) snake[i][1] = 1
            if (snake[i][1] <= 0) snake[i][1] = height - 2
            if (snake[i][0] == foodPos[0] && snake[i][1] == foodPos[1]) {
                enlargenSnake()
            }
        }
        for (let i = 1; i < snake.length; i++) {
            if (snake[i][0] == snake[0][0] && snake[i][1] == snake[0][1]) {
                snakeAlive = false
            }
        }
    }

    function printCells() {
        let elements = []
        for (let y = 0; y < height; y++) {
            let line = []
            for (let x = 0; x < width; x++) {
                line.push(terminal.print(" ", undefined, {forceElement: true}))
            }
            elements.push(line)
            terminal.addLineBreak()
        }
        return elements
    }

    let elements = printCells()

    let moves = []

    function draw() {
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let cell = cells[y][x]
                if (cell == EMPTY) {
                    elements[y][x].innerText = ". "
                    elements[y][x].style.color = "var(--foreground)"
                } else if (cell == SNAKE) {
                    elements[y][x].innerText = "# "
                    elements[y][x].style.color = "var(--accent-color-1)"
                } else if (cell == FOOD) {
                    elements[y][x].innerText = "# "
                    elements[y][x].style.color = "var(--accent-color-2)"
                } else if (cell == WALLY) {
                    elements[y][x].innerText = "| "
                    elements[y][x].style.color = "var(--foreground)"
                } else if (cell == WALLX) {
                    elements[y][x].innerText = "--"
                    elements[y][x].style.color = "var(--foreground)"
                } else if (cell == WALLC1) {
                    elements[y][x].innerText = "+-"
                    elements[y][x].style.color = "var(--foreground)"
                } else if (cell == WALLC2) {
                    elements[y][x].innerText = "+ "
                    elements[y][x].style.color = "var(--foreground)"
                }
            }
        }
    }

    function turnSnakeRed() {
        for (let i = 0; i < snake.length; i++) {
            elements[snake[i][1]][snake[i][0]].style.color = "var(--error-color)"
        }
    }

    terminal.printLine("Use the arrow keys to move the snake.")
    terminal.scroll()

    function onkeydown(keycode) {
        if (keycode == "ArrowUp") {
            moves.push([0, -1])
            return true
        } else if (keycode == "ArrowDown") {
            moves.push([0, 1])
            return true
        } else if (keycode == "ArrowLeft") {
            moves.push([-1, 0])
            return true
        } else if (keycode == "ArrowRight") {
            moves.push([1, 0])
            return true
        }
    }

    let listener = addEventListener("keydown", function(event) {
        if (event.repeat) return
        if (snakeAlive == false) return
        if (onkeydown(event.key)) {
            event.preventDefault()
        }
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout(
            terminal.mobileKeyboard.Layout.ARROWS
        )

        terminal.mobileKeyboard.onkeydown = function(e, keycode) {
            if (snakeAlive == false) return
            onkeydown(keycode)
        }
    }

    while (snakeAlive) {
        updateCells()
        updateSnake()
        draw()
        await sleep(speed)
    }

    updateCells()
    draw()
	let score = snake.length - startLength
    terminal.printLine(`You lost! Your score was ${score}.`)
    turnSnakeRed()

    removeEventListener("keydown", listener)

    await HighscoreApi.registerProcess("snake")
    await HighscoreApi.uploadScore(score)

}, {
    description: "play a game of snake",
    args: {"?s:n:1~10": "speed level of snake moving"},
    standardVals: {
        s: 2
    },
    isGame: true
})

// ------------------- js/commands/sodoku.js --------------------
terminal.addCommand("sodoku", async function(args) {

    const MODES = ["play", "solve"]

    if (args.mode !== undefined && !MODES.includes(args.mode)) {
        terminal.printLine(`Unknown mode: "${args.mode}"`)
        args.mode = undefined
    }

    if (!args.mode) {
        terminal.printLine("Please select a mode:")
        for (let mode of MODES) {
            terminal.print("- ")
            terminal.printCommand(`${mode} a sodoku`, `sodoku ${mode}`)
        }
        return
    }

    class SodokuBoard {

        _makeBlockData(fill=undefined) {
            let data = []
            for (let i = 0; i < this.blockSize; i++) {
                let row = []
                for (let j = 0; j < this.blockSize; j++) {
                    row.push(fill)
                }
                data.push(row)
            }
            return data
        }

        constructor(blockSize, boardBlockSize) {
            this.blockSize = blockSize
            this.boardBlockSize = boardBlockSize
            this.blockRows = []
            for (let i = 0; i < this.boardBlockSize; i++) {
                let row = []
                for (let j = 0; j < this.boardBlockSize; j++) {
                    row.push(this._makeBlockData())
                }
                this.blockRows.push(row)
            }
            this.highlightedIndex = null
            this.hasCheated = false
        }

        getBlock(x, y) {
            return this.blockRows[y][x]
        }

        getNumber(x, y) {
            let blockX = Math.floor(x / this.blockSize)
            let blockY = Math.floor(y / this.blockSize)
            let block = this.getBlock(blockX, blockY)
            let localX = x % this.blockSize
            let localY = y % this.blockSize
            return block[localY][localX]
        }

        setNumber(x, y, number) {
            let blockX = Math.floor(x / this.blockSize)
            let blockY = Math.floor(y / this.blockSize)
            let block = this.getBlock(blockX, blockY)
            let localX = x % this.blockSize
            let localY = y % this.blockSize
            block[localY][localX] = number
        }

        getRows() {
            let rows = []
            for (let i = 0; i < this.blockSize * this.boardBlockSize; i++) {
                let row = []
                for (let j = 0; j < this.blockSize * this.boardBlockSize; j++) {
                    row.push(this.getNumber(j, i))
                }
                rows.push(row)
            }
            return rows
        }

        getColumns() {
            let columns = []
            for (let i = 0; i < this.blockSize * this.boardBlockSize; i++) {
                let column = []
                for (let j = 0; j < this.blockSize * this.boardBlockSize; j++) {
                    column.push(this.getNumber(i, j))
                }
                columns.push(column)
            }
            return columns
        }

        getBlocks() {
            let blocks = []
            for (let i = 0; i < this.boardBlockSize; i++) {
                for (let j = 0; j < this.boardBlockSize; j++) {
                    let block = this.getBlock(j, i)
                    blocks.push(block)
                }
            }
            return blocks
        }

        toString() {
            let outputString = ""
            let lineString = "+"
            for (let i = 0; i < this.boardBlockSize; i++) {
                lineString += "-".repeat(this.blockSize * 4 - 1) + "+"
                if (i != this.boardBlockSize - 1) {
                    lineString += "+"
                }
            }
            let thickLineString = lineString.replaceAll("-", "=")
            let rows = this.getRows()
            for (let i = 0; i < rows.length; i++) {
                if (i != 0 && i % this.blockSize === 0) {
                    outputString += thickLineString + "\n|"
                } else {
                    outputString += lineString + "\n|"
                }
                if (i * rows.length == this.highlightedIndex) {
                    outputString += "<"
                } else {
                    outputString += " "
                }
                let row = rows[i]
                for (let j = 0; j < row.length; j++) {
                    let number = row[j]
                    let index = i * row.length + j
                    let nextIsHighlighted = index + 1 == this.highlightedIndex
                    let isHighlightedIndex = index == this.highlightedIndex
                    if (number === undefined) {
                        outputString += " "
                    } else {
                        outputString += number
                    }
                    if (isHighlightedIndex) {
                        outputString += ">"
                    } else {
                        outputString += " "
                    }
                    if (j % this.blockSize === this.blockSize - 1 && j != row.length - 1) {
                        outputString += "||" 
                    } else {
                        outputString += "|"
                    }
                    if (nextIsHighlighted && j != row.length - 1) {
                        outputString += "<"
                    } else {
                        outputString += " "
                    }
                }
                outputString += "\n"
            }
            outputString += lineString + "\n"
            return outputString
        }

        xyFromIndex(index) {
            let x = index % (this.blockSize * this.boardBlockSize)
            let y = Math.floor(index / (this.blockSize * this.boardBlockSize))
            return [x, y]
        }

        indexFromXY(x, y) {
            return y * (this.blockSize * this.boardBlockSize) + x
        }

        get maxIndex() {
            return (this.blockSize * this.boardBlockSize) ** 2
        }

        printToElement() {
            return terminal.printLine(this.toString(), undefined, {forceElement: true})
        }

        getLockedMap() {
            let lockedMap = []
            for (let i = 0; i < this.blockSize * this.boardBlockSize; i++) {
                let row = []
                for (let j = 0; j < this.blockSize * this.boardBlockSize; j++) {
                    row.push(this.getNumber(j, i) !== undefined)
                }
                lockedMap.push(row)
            }
            return lockedMap
        }

        async playFromInput() {
            await sleep(100)

            let currX = 0
            let currY = 0
            let gameRunning = true

            let lockedMap = this.getLockedMap()

            terminal.onInterrupt(() => {
                gameRunning = false
            })

            const onkeydown = (key, event) => {
                if (!gameRunning) {
                    return
                }

                let prevFen = this.toFEN()

                if (key == "Backspace") {
                    if (lockedMap[currY][currX]) {
                        return
                    }
                    this.setNumber(currX, currY, undefined)
                    this.highlightedIndex = this.indexFromXY(currX, currY)
                    event.preventDefault()
                    return
                } else if (key == "s") {
                    this.hasCheated = true
                    this.solveLive(element).then(() => {
                        gameRunning = false
                    })
                } else if (/^[1-9]$/.test(key)) {
                    if (lockedMap[currY][currX]) {
                        return
                    }
                    this.setNumber(currX, currY, parseInt(key))
                    event.preventDefault()
                } else if (key.startsWith("Arrow")) {
                    if (key == "ArrowUp") {
                        currY--
                        if (currY < 0) currY = 0
                    }
                    if (key == "ArrowDown") {
                        currY++
                        if (currY >= this.size) currY = this.size - 1
                    }
                    if (key == "ArrowLeft") {
                        currX--
                        if (currX < 0) currX = 0
                    }
                    if (key == "ArrowRight") {
                        currX++
                        if (currX >= this.size) currX = this.size - 1
                    }
                    event.preventDefault()
                }

                if (this.includesConflict()) {
                    this.loadFEN(prevFen)
                } else {
                    if (this.getAmountLeft() == this.size ** 2) {
                        gameRunning = false
                    }
                }

                this.highlightedIndex = this.indexFromXY(currX, currY)
            }

            let listener = terminal.window.addEventListener("keydown", async event => {
                if (!gameRunning) {
                    terminal.window.removeEventListener("keydown", listener)
                }
                
                onkeydown(event.key, event)
            })

            if (terminal.mobileKeyboard) {
                terminal.mobileKeyboard.updateLayout([
                    ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
                    [null, "↑", null],
                    ["←", "↓", "→"],
                    ["Backspace"],
                    ["STRG+C"]
                ])
        
                terminal.mobileKeyboard.onkeydown = function(e, keycode) {
                    onkeydown(keycode, e)
                }
            }

            let element = this.printToElement()
            terminal.addLineBreak()
            terminal.printLine("- Use the Arrow Keys to move around")
            terminal.printLine("- Press a number to set it")
            terminal.printLine("- Press Backspace to remove a number")

            terminal.scroll()
            this.highlightedIndex = this.indexFromXY(currX, currY)

            while (gameRunning) {
                element.textContent = this.toString()
                await sleep(50)
            }

            terminal.printSuccess("You made it!")

            this.highlightedIndex = null
            element.textContent = this.toString()

            terminal.window.removeEventListener("keydown", listener)

            return element
        }

        async fillFromInput() {
            await sleep(100)

            let currIndex = 0

            terminal.onInterrupt(() => {
                currIndex = this.maxIndex
            })

            const onkeydown = (key, event) => {
                if (currIndex >= this.maxIndex) {
                    return
                }
                
                let [x, y] = this.xyFromIndex(currIndex)

                if (key == "Backspace") {
                    if (currIndex > 0)
                        currIndex--
                    [x, y] = this.xyFromIndex(currIndex)
                    this.setNumber(x, y, undefined)
                    this.highlightedIndex = currIndex
                    event.preventDefault()
                    return
                } else if (/^[1-9]$/.test(key)) {
                    this.setNumber(x, y, parseInt(key))
                    event.preventDefault()
                } else if (key == "Enter" || key == " ") {
                    currIndex++
                    this.highlightedIndex = currIndex
                    event.preventDefault()
                    return
                } else {
                    return
                }

                currIndex++
                this.highlightedIndex = currIndex
            }

            let listener = terminal.window.addEventListener("keydown", async event => {
                if (currIndex >= this.maxIndex) {
                    terminal.window.removeEventListener("keydown", listener)
                }
                
                onkeydown(event.key, event)
            })

            if (terminal.mobileKeyboard) {
                terminal.mobileKeyboard.updateLayout([
                    ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
                    ["Enter", "Backspace"],
                    ["STRG+C"]
                ])
        
                terminal.mobileKeyboard.onkeydown = function(e, keycode) {
                    onkeydown(keycode, e)
                }
            }

            let element = this.printToElement()
            terminal.addLineBreak()
            terminal.printLine("- Press a number to set it")
            terminal.printLine("- Press Backspace to remove a number")
            terminal.printLine("- Press Enter to go to the next field")
            terminal.scroll()
            this.highlightedIndex = currIndex

            while (currIndex < this.maxIndex) {
                element.textContent = this.toString()
                await sleep(50)
            }

            this.highlightedIndex = null
            element.textContent = this.toString()

            terminal.window.removeEventListener("keydown", listener)

            return element
        }

        loadFEN(fenString) {
            // example: 123456789/123456789/123456789|123456789/123456789/123456789|123456789/123456789/123456789
            let rows = fenString.split("|")
            for (let i = 0; i < rows.length; i++) {
                let row = rows[i]
                let numbers = row.split("/")
                for (let j = 0; j < numbers.length; j++) {
                    let blockNumbers = numbers[j].split("")
                    for (let k = 0; k < blockNumbers.length; k++) {
                        let block = this.getBlock(j, i)
                        let value = blockNumbers[k] == "_" ? undefined : parseInt(blockNumbers[k])
                        if (value !== undefined && (isNaN(value) || value < 1 || value > 9))
                            throw new Error("Invalid FEN string")
                        block[Math.floor(k / this.blockSize)][k % this.blockSize] = value
                    }
                }
            }
        }

        get size() {
            return this.blockSize * this.boardBlockSize
        }

        getBlockData(x, y) {
            let i = Math.floor(x / 3)
            let j = Math.floor(y / 3)
            return this.getBlock(i, j).flat()
        }

        toFEN() {
            let fenString = ""
            let blocks = this.getBlocks()
            for (let i = 0; i < blocks.length; i++) {
                let blockData = blocks[i].flat()
                let blockString = blockData.map(x => x == undefined ? "_" : x).join("")
                fenString += blockString
                if (i % this.boardBlockSize == this.boardBlockSize - 1 && i != blocks.length - 1) {
                    fenString += "|"
                } else if (i != blocks.length - 1) {
                    fenString += "/"
                }
            }
            return fenString
        }

        copy() {
            let newBoard = new Board(this.blockSize, this.boardBlockSize)
            newBoard.loadFEN(this.toFEN())
            return newBoard
        }

        includesConflict() {
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    let prevNum = this.getNumber(x, y)
                    if (prevNum == undefined) continue
                    this.setNumber(x, y, undefined)

                    let row = this.getRows()[y]
                    let column = this.getColumns()[x]
                    let blockData = this.getBlockData(x, y)

                    let foundError = (
                        row.includes(prevNum) ||
                        column.includes(prevNum) ||
                        blockData.includes(prevNum)
                    )

                    this.setNumber(x, y, prevNum)

                    if (foundError) {
                        return [x, y]
                    }
                }
            }
            return false
        }

        async wavefunctionCollapse(sleepTime=100, outputElement=null) {
            const iterate = () => {
                let possibleOptions = this.getPossibleData()
                let entropies = possibleOptions.map(arr => {
                    if (arr === undefined) return Infinity
                    return arr.length
                })

                let lowestEntropy = Math.min(...entropies)

                if (lowestEntropy == 0)
                    return "fail"
                if (lowestEntropy == Infinity)
                    return "finished"

                let lowestEntropyIndeces = entropies.map((e, i) => {
                    if (e == lowestEntropy) return i
                    return -1
                }).filter(i => i != -1)

                let randomIndex = Math.floor(Math.random() * lowestEntropyIndeces.length)
                let randomEntropyIndex = lowestEntropyIndeces[randomIndex]
                
                let options = possibleOptions[randomEntropyIndex]
                let choiceIndex = Math.floor(Math.random() * options.length)
                let choice = options[choiceIndex]
                let [x, y] = this.xyFromIndex(randomEntropyIndex)

                this.setNumber(x, y, choice)
                return "continue"
            }

            let iterationResult = "continue"
            while (iterationResult == "continue") {
                if (sleepTime > 0)
                    await sleep(sleepTime)
                iterationResult = iterate()
                if (outputElement)
                    outputElement.textContent = this.toString()
            }

            return iterationResult
        }

        getPossibleData() {
            let possibleNumbers = []
            let rows = this.getRows()
            let columns = this.getColumns()
            let options = Array.from(Array(9), (_, i) => i + 1)
            for (let y = 0; y < this.size; y++) {
                for (let x = 0; x < this.size; x++) {
                    if (this.getNumber(x, y) != undefined) {
                        possibleNumbers.push(undefined)
                        continue
                    }

                    let row = rows[y]
                    let column = columns[x]
                    let blockData = this.getBlockData(x, y)

                    let possibleOptions = options.filter(n => {
                        if (row.includes(n)) return false
                        if (column.includes(n)) return false
                        if (blockData.includes(n)) return false

                        return true
                    })

                    possibleNumbers.push(possibleOptions)
                }
            }
            return possibleNumbers
        }

        async solveLive(outputElement) {
            // solve using wavefunction collapse technique
            let originalFEN = this.toFEN()
            let waitTimes = [30, 20, 10]
            let waitBetweenIndex = 2
            for (let i = 0; true; i++) {
                let result = await this.wavefunctionCollapse(waitTimes[i] ?? 0, outputElement)
                if (result == "finished")
                    break

                this.loadFEN(originalFEN)
                if (waitTimes[i] === undefined && i % waitBetweenIndex == 0) {
                    await sleep(0)
                    waitBetweenIndex++
                    waitBetweenIndex = Math.min(waitBetweenIndex, 100)
                }
            }
        }

        async solveFast(maxAttempts=10000) {
            let originalFEN = this.toFEN()
            let i = 0
            for (; true; i++) {
                let result = await this.wavefunctionCollapse(0)
                if (result == "finished")
                    break
                this.loadFEN(originalFEN)
                if (i >= maxAttempts)
                    throw new Error("Could not solve board!")
            }
            return i + 1
        }

        getAmountLeft() {
            return this.getRows().flat().reduce((a, b) => a + (b != undefined ? 1 : 0), 0)
        }

        getRandomXY() {
            let x = Math.floor(Math.random() * this.size)
            let y = Math.floor(Math.random() * this.size)
            return [x, y]
        }

        getRandomFilled(maxAttempts=10000) {
            let [x, y] = this.getRandomXY()
            let i = 0
            while (this.getNumber(x, y) == undefined) {
                [x, y] = this.getRandomXY()
                i++
                if (i >= maxAttempts)
                    throw new Error("Could not find filled square!")
            }
            return [x, y]
        }

        static async random(amountLeft) {
            let board = new SodokuBoard(3, 3)
            try {
                await board.solveFast()
            } catch (e) {
                throw new Error("Could not generate random board!")
            }
            while (board.getAmountLeft() > amountLeft) {
                let [x, y] = board.getRandomFilled()
                board.setNumber(x, y, undefined)
            }
            return board
        }

    }

    const MODE_FUNCS = {

        async solve() {
            let board = new SodokuBoard(3, 3)
            let outputElement = null

            if (args.fen) {
                try {
                    board.loadFEN(args.fen)
                } catch (e) {
                    throw new Error("Invalid FEN string!")
                }
                outputElement = board.printToElement()
            } else {
                outputElement = await board.fillFromInput()
                if (args["give-fen"]) {
                    let fen = board.toFEN()
                    terminal.printLine(fen)
                    await terminal.copy(fen, {printMessage: true})
                }
            }

            let conflict = board.includesConflict()
            if (conflict) {
                throw new Error("Conflict at (" + conflict.map(x => x + 1).join(", ") + "): Impossible Board!")
            }

            await board.solveLive(outputElement)
            terminal.printSuccess("Solved Sudoku puzzle successfully!")
        },

        async play() {
            const difficulties = {
                "easy": 1 / 1,
                "medium": 1 / 0.2,
                "hard": 1 / 0.1
            }

            const amountLeftDifficulties = {
                "easy": [40, 50],
                "medium": [20, 30],
                "hard": [17, 20]
            }

            async function getDifficulty() {
                terminal.printLine("Choose a difficulty:")
                for (let difficulty in difficulties) {
                    terminal.print("  " + difficulty)
                    terminal.printLine(` (${difficulty.charAt(0)})`)
                }
                let chosenDifficulty = null
                while (chosenDifficulty == null) {
                    let difficulty = await terminal.prompt("> ")
                    difficulty = difficulty.toLowerCase()
                    if (difficulty in difficulties) {
                        return difficulty
                    } else if (difficulty.length == 1) {
                        for (let virtualDifficulty in difficulties) {
                            if (virtualDifficulty.charAt(0) == difficulty) {
                                return virtualDifficulty
                            }
                        }
                    }
                    terminal.printLine("unknown difficulty: " + `"${difficulty}"`)
                }
            }

            async function generateBoard(difficulty) {
                let minAmountLeft = amountLeftDifficulties[difficulty][0]
                let maxAmountLeft = amountLeftDifficulties[difficulty][1]
                let amountLeft = Math.floor(Math.random() * (maxAmountLeft - minAmountLeft + 1) + minAmountLeft)
                let board = null
                let difficultyTries = difficulties[difficulty]
                let maxTries = difficultyTries + Math.ceil(difficultyTries / 5)
                let attempts = 0
                while (true) {
                    board = await SodokuBoard.random(amountLeft)
                    let fen = board.toFEN()
                    let solves = await board.solveFast()
                    board.loadFEN(fen)

                    attempts++
                    if (attempts % 10 == 0)
                        await sleep(0)
                    
                    if (solves >= difficultyTries && solves <= maxTries) {
                        break
                    }
                }
                return board
            }

            let difficulty = await getDifficulty()

            let board = new SodokuBoard(3, 3)

            if (args.fen) {
                try {
                    board.loadFEN(args.fen)
                } catch (e) {
                    throw new Error("Invalid FEN string!")
                }
            } else {
                terminal.addLineBreak()
                terminal.printLine(`Generating ${difficulty} board...`)
                await sleep(100)
                board = await generateBoard(difficulty)
                if (args["give-fen"]) {
                    let fen = board.toFEN()
                    await terminal.copy(fen, {printMessage: true})
                }
            }

            await board.playFromInput()

            if (difficulty == "hard" && !board.hasCheated) {
                terminal.printSuccess("You beat the hardest Sudoku puzzle!")
                terminal.printLine("For this achievement, you get an easter egg:")
                terminal.printEasterEgg("Sodoku-Egg")
            }

        }

    }

    await MODE_FUNCS[args.mode]()

}, {
    description: "Solve or generate a sodoku puzzle",
    args: {
        "?mode:e:play|solve": "the mode to run in (play, solve)",
        "?fen:s": "a FEN string to load",
        "?give-fen:b": "output the FEN string for the inputted puzzle"
    },
    isGame: true
})

// ------------------- js/commands/solve.js --------------------
terminal.addCommand("solve", async function(args) {
    let equation = args.equation
    if (!/^[0-9x\s\\\*\.a-z+-\^\(\)]+=[0-9x\s\\\*\.a-z+-\^\(\)]+$/.test(equation)) {
        terminal.printError("Invalid equation")
        terminal.printLine("Only numbers, x, *, +, -, ^, (, ), \\ and spaces are allowed")
        return
    }
    while (/[0-9]x/g.test(equation)) equation = equation.replace(/([0-9])x/g, "$1*x")
    while (/[0-9a-z]\s*\^\s*[0-9a-z]/g.test(equation)) equation = equation.replace(/([0-9a-z])\s*\^\s*([0-9a-z])/g, "$1**$2")
    let [left, right] = equation.split("=")
    let iterations = args.i
    let iterationCount = 0
    let maxIterations = args.m
    let lowerBound = args.l
    let upperBound = args.u
    try {
        var [LHS, RHS] = [Function("x", `return ${left}`), Function("x", `return ${right}`)]
    } catch {
        throw new Error("Invalid equation!")
    }
    function findSolution(minX, maxX, resolution, depth) {
        let diff = maxX - minX
        let stepSize = diff / resolution
        let lastState = LHS(minX) > RHS(maxX)
        let solutions = Array()
        for (let x = minX; x <= maxX; x += stepSize) {
            iterationCount++
            if (iterationCount > maxIterations)
                return solutions
            let currState = LHS(x) > RHS(x)
            if (currState != lastState) {
                if (depth === 1) {
                    solutions.push(x)
                } else {
                    solutions = solutions.concat(findSolution(
                        x - stepSize,
                        x + stepSize,
                        resolution,
                        depth - 1
                    ))
                }
            }
            lastState = currState
        }
        return solutions
    }
    
    let solutions = findSolution(lowerBound, upperBound, Math.round((upperBound - lowerBound) * 10), iterations)
    let roundFactor = 10 ** 3
    let shownSolutions = Array()
    let solutionCount = 0
    for (let i = 0; i < solutions.length; i++) {
        let solution = String(Math.round(solutions[i] * roundFactor) / roundFactor)
        if (shownSolutions.includes(solution)) continue
        solutionCount++
        let xName = `x${solutionCount}`
        terminal.print(xName, Color.COLOR_1)
        terminal.print(" = ")
        terminal.printLine(solution, Color.LIGHT_GREEN)
        shownSolutions.push(solution)
    }
    if (solutions.length == 0) {
        terminal.printLine("No solutions found")
    }
    if (iterationCount >= maxIterations) {
        terminal.printError("Max iterations reached")
    }
}, {
    description: "solve a mathematical equation for x",
    args: {
        "*equation": "the equation to solve",
        "?i:n:1~5": "the number of iteration-steps to perform",
        "?m:n:1~100000": "the maximum number of total iterations to perform",
        "?l:n": "the lower bound of the search interval",
        "?u:n": "the upper bound of the search interval"
    },
    standardVals: {
        i: 4,
        m: 100000,
        l: -100,
        u: 100
    },
    disableEqualsArgNotation: true
})



// ------------------- js/commands/sorting.js --------------------
terminal.addCommand("sorting", async function(args) {

    let array = Array.from({length: args.n}, (_, i) => i + 1)

    function shuffleArray() {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    shuffleArray()

    let windowSize = Math.min((terminal.parentNode.clientWidth - 100) * 0.9, (terminal.parentNode.clientHeight - 100) * 0.9)

    const elementSize = Math.max(Math.floor(windowSize / array.length), 1)

    let elements = []
    
    function firstDraw() {
        let parentContainer = document.createElement("div")
        parentContainer.style.width = `${args.n * elementSize}px`
        parentContainer.style.height = `${args.n * elementSize}px`
        parentContainer.style.display = "grid"
        parentContainer.style.gridTemplateColumns = `repeat(${args.n}, 1fr)`
        parentContainer.style.alignItems = "end"
        for (let i = 0; i < array.length; i++) {
            let element = document.createElement("div")
            element.style.backgroundColor = "white"
            element.style.width = `${elementSize}px`
            element.style.height = `${array[i] * elementSize}px`
            elements.push(element)
            parentContainer.appendChild(element)
        }
        terminal.parentNode.appendChild(parentContainer)
    }

    let prevElements = []
    const swapColor = "lightgreen"

    function unmark() {
        for (let element of prevElements) {
            element.style.backgroundColor = "white"
        }
        prevElements = []
    }

    function heightToFreq(height) {
        const minFreq = 100
        const maxFreq = 1000
        return (height / args.n) * (maxFreq - minFreq) + minFreq
    }

    let waitTime = 100 / args.speed

    function swap(i, j) {
        unmark()
        let temp = array[i]
        array[i] = array[j]
        array[j] = temp
        elements[i].style.height = `${array[i] * elementSize}px`
        elements[j].style.height = `${array[j] * elementSize}px`
        elements[i].style.backgroundColor = swapColor
        elements[j].style.backgroundColor = swapColor
        prevElements = [elements[i], elements[j]]
        if (!args.s) {
            playFrequency(heightToFreq(array[i]), waitTime)
        }
    }

    function mark(i) {
        elements[i].style.backgroundColor = swapColor
        prevElements.push(elements[i])
        if (!args.s) {
            playFrequency(heightToFreq(array[i]), waitTime)
        }
    }

    function update(i) {
        elements[i].style.height = `${array[i] * elementSize}px`
    }

    async function endAnimation() {
        unmark()
        for (let i = 0; i < array.length; i++) {
            elements[i].style.backgroundColor = swapColor
            if (!args.s) {
                playFrequency(heightToFreq(array[i]), waitTime)
            }
            await sleep(waitTime)
        }
        await sleep(waitTime)
        for (let i = 0; i < array.length; i++) {
            elements[i].style.backgroundColor = "white"
        }
    }

    const algorithms = {
        "bubble": async function() {
            for (let i = 0; i < array.length; i++) {
                for (let j = 0; j < array.length - i - 1; j++) {
                    if (array[j] > array[j + 1]) {
                        swap(j, j + 1)
                        await sleep(waitTime)
                    }
                }
            }
        },
        "insertion": async function() {
            for (let i = 1; i < array.length; i++) {
                let j = i - 1
                let key = array[i]
                while (j >= 0 && array[j] > key) {
                    swap(j, j + 1)
                    await sleep(waitTime)
                    j--
                }
                array[j + 1] = key
            }
        },
        "selection": async function() {
            for (let i = 0; i < array.length; i++) {
                let minIndex = i
                for (let j = i + 1; j < array.length; j++) {
                    mark(j)
                    await sleep(waitTime)
                    unmark()
                    if (array[j] < array[minIndex]) {
                        minIndex = j
                    }
                }
                swap(i, minIndex)
                await sleep(waitTime)
            }
        },
        "quick": async function() {
            async function partition(min, max) {
                let pivot = array[max]
                let i = min - 1
                for (let j = min; j < max; j++) {
                    if (array[j] < pivot) {
                        i++
                        swap(i, j)
                        await sleep(waitTime)
                    }
                }
                swap(i + 1, max)
                await sleep(waitTime)
                return i + 1
            }

            async function quickSort(min, max) {
                if (min < max) {
                    let pi = await partition(min, max)
                    await quickSort(min, pi - 1)
                    await quickSort(pi + 1, max)
                }
            }

            await quickSort(0, array.length - 1)
        },
        "heap": async function() {
            async function heapify(n, i) {
                let largest = i
                let l = 2 * i + 1
                let r = 2 * i + 2
                if (l < n && array[l] > array[largest]) {
                    largest = l
                }
                if (r < n && array[r] > array[largest]) {
                    largest = r
                }
                if (largest != i) {
                    swap(i, largest)
                    await sleep(waitTime)
                    await heapify(n, largest)
                }
            }

            for (let i = Math.floor(array.length / 2) - 1; i >= 0; i--) {
                await heapify(array.length, i)
            }
            for (let i = array.length - 1; i >= 0; i--) {
                swap(0, i)
                await sleep(waitTime)
                await heapify(i, 0)
            }
        },
        "merge": async function() { 
            // inplace merge sort with marking
            async function merge(start, mid, end) {
                let i = start
                let j = mid + 1
                let temp = []
                while (i <= mid && j <= end) {
                    mark(i)
                    mark(j)
                    await sleep(waitTime)
                    unmark()
                    if (array[i] <= array[j]) {
                        temp.push(array[i])
                        i++
                    } else {
                        temp.push(array[j])
                        j++
                    }
                }
                while (i <= mid) {
                    temp.push(array[i])
                    i++
                }
                while (j <= end) {
                    temp.push(array[j])
                    j++
                }
                for (let i = start; i <= end; i++) {
                    array[i] = temp[i - start]
                    update(i)
                    mark(i)
                    await sleep(waitTime)
                }
            }

            async function mergeSort(start, end) {
                if (start < end) {
                    let mid = Math.floor((start + end) / 2)
                    await mergeSort(start, mid)
                    await mergeSort(mid + 1, end)
                    await merge(start, mid, end)
                }
            }

            await mergeSort(0, array.length - 1)
        }
    }

    if (args.algorithm === null) {
        terminal.printLine("Available algorithms:")
        for (let algorithm in algorithms) {
            terminal.print("- ")
            terminal.printCommand(algorithm, `sorting ${algorithm}`)
        }
        return
    }

    if (!(args.algorithm in algorithms)) {
        throw new Error("Unknown algorithm")
    }

    firstDraw()

    terminal.scroll()

    await sleep(1000)

    await algorithms[args.algorithm]()

    await endAnimation()

    unmark()

}, {
    description: "display a sorting algorithm",
    args: {
        "?algorithm": "the algorithm to display",
        "?n:i:10~1000": "the number of elements to sort",
        "?speed:n:0~100": "the speed of the sorting algorithm",
        "?s:b": "silent mode (deactivate sound)"
    },
    standardVals: {
        algorithm: null,
        n: 20,
        speed: 1,
    }
})



// ------------------- js/commands/sounds.js --------------------
terminal.addCommand("sounds", async function(args) {
    if (args.random) {
        for (let i = 0; i < args.length; i++) {
            args.text += args.alphabet[Math.floor(Math.random() * args.alphabet.length)]
        }
    }

    let context = new AudioContext(),
        osc = context.createOscillator(),
        gain = context.createGain()

    osc.connect(gain)
    gain.connect(context.destination)

    const alphabet = " abcdefghijklmnopqrstuvwxyz.,\n"
    const frequencies = []

    for (let letter of args.text) {
        if (!alphabet.includes(letter)) {
            throw new Error(`Unknown Character: "${letter}"`)
        }

        const indexInAlphabet = alphabet.indexOf(letter)

        if (indexInAlphabet == 0) {
            frequencies.push(0)
        } else {
            frequencies.push(frequencyFromNoteOffset(indexInAlphabet))
        }
    }

    osc.start(0)

    terminal.onInterrupt(() => {
        osc.stop()
    })

    const output1 = terminal.print("", undefined, {forceElement: true})
    const output2 = terminal.print("", new Color(0, 0, 255), {forceElement: true})
    const output3 = terminal.print("", undefined, {forceElement: true})

    function updateOutput(index) {
        output1.textContent = args.text.slice(0, index)
        output2.textContent = args.text[index]
        output3.textContent = args.text.slice(index + 1, args.text.length)
    }
    
    for (let i = 0; i < frequencies.length; i++) {
        updateOutput(i)
        const freq = frequencies[i]

        osc.frequency.value = freq
    
        if (freq != 0) {
            gain.gain.setValueAtTime(1, context.currentTime) 
            gain.gain.exponentialRampToValueAtTime(0.2, context.currentTime + args.interval / 1000)
        } else {
            gain.gain.exponentialRampToValueAtTime(0.000001, context.currentTime + args.interval / 1000)
        }

        await sleep(args.interval)
    }

    osc.stop()

}, {    
    description: "make sounds",
    args: {
        "*text:s": "text to speak",
        "?i=interval:i:1~999999": "interval in ms between letters",
        "?r=random:b": "make random",
        "?l=length:i:1~99999": "length of random notes",
        "?a=alphabet:s": "alphabet of random letters"
    },
    defaultValues: {
        text: "",
        interval: 500,
        length: 10,
        alphabet: " abcdefghijklmnopqrstuvwxyz.,\n"
    }
})

// ------------------- js/commands/spion.js --------------------
const getApiUrl = "../spion/api/get.php"
const addApiUrl = "../spion/api/add.php"

terminal.addCommand("spion", async function(args) {
    let result = await fetch(getApiUrl)
    let places = await result.json()
    let placeNames = places.map(place => place.place.toLowerCase())

    if (args.add && args.list) {
        throw new Error("Cannot add and list at the same time")
    }

    if (args.add) {
        let name = await terminal.prompt("Ort Name: ")
        name = name.trim()
        while (name == "" || placeNames.includes(name.toLowerCase())) {
            if (name == "") {
                terminal.printLine("Name darf nicht leer sein", Color.COLOR_1)
            } else {
                terminal.printLine("Name bereits vorhanden", Color.COLOR_1)
            }
            name = await terminal.prompt("Ort Name: ")
            name = name.trim()
        }

        let roles = []
        while (roles.length < 20) {
            let role = await terminal.prompt("Rolle " + (roles.length + 1) + ": ")
            role = role.trim()

            if (role == "") {
                terminal.printError("Name darf nicht leer sein")
                continue
            }

            let roleNames = roles.map(role => role.toLowerCase())
            if (roleNames.includes(role.toLowerCase())) {
                terminal.printError("Name bereits vorhanden")
                continue
            }

            roles.push(role)
        }

        let formData = new FormData()

        formData.append("json", JSON.stringify({
            place: name,
            roles: roles,
        }))

        let result = await fetch(addApiUrl, {
            method: "POST",
            body: formData,
        })

        let json = await result.json()
        if (json.ok) {
            terminal.printSuccess("Ort hinzugefügt")
        } else {
            terminal.printError("Fehler beim hinzufügen: " + json.message)
        }
    } else if (args.list) {
        let place = places.find(place => place.place == args.list)
        if (!place) {
            terminal.print("Ort nicht gefunden", Color.COLOR_1)
            return
        }
        terminal.printLine("Ort: " + place.place, Color.COLOR_1)
        terminal.printLine("Rollen:")
        for (let i = 0; i < place.roles.length; i++) {
            const role = place.roles[i]
            terminal.print(i + 1, Color.COLOR_1)
            terminal.printLine(": " + role)
        }
    } else {
        terminal.printLine("Alle Orte:", Color.COLOR_1)
        for (let i = 0; i < places.length; i++) {
            const place = places[i]
            terminal.print(i + 1, Color.COLOR_1)
            terminal.print(": ")
            terminal.printCommand(place.place, "spion --list \"" + place.place + "\"")
        }
        terminal.addLineBreak()
        terminal.printCommand("Ort hinzufügen", "spion --add")
    }
}, {
    description: "Spiel Spiel Manager",
    args: {
        "?a=add:b": "add a new place",
        "?l=list:s": "list a given places roles"
    },
    isSecret: true
})

// ------------------- js/commands/stacker.js --------------------
terminal.addCommand("stacker", async function(args) {
    await terminal.modules.import("game", window)

    const GAME_SIZE = new Vector2d(26, 10)
    const towerOffset = 3

    let towerWidth = 12

    const firstPrint = () => {
        let outputs = []
        for (let i = 0; i < GAME_SIZE.y; i++) {
            let line = []
            for (let j = 0; j < GAME_SIZE.x; j++) {
                let output = terminal.print(" ")
                line.push(output)
            }
            outputs.push(line)
            terminal.addLineBreak()
        }
        return outputs
    }

    terminal.printLine("press SPACE to place block")
    let outputs = firstPrint()

    const drawTowerLine = (lineIndex, towerWidth) => {
        let startX = Math.floor(GAME_SIZE.x / 2 - towerWidth / 2)
        for (let i = 0; i < towerWidth; i++) {
            outputs[lineIndex][startX + i].textContent = "#"
        }
    }

    for (let i = towerOffset; i < outputs.length; i++) {
        drawTowerLine(i, towerWidth)
    }

    const moveDown = () => {
        for (let i = outputs.length - 1; i >= 0; i--) {
            let prevLine = ""
            if (i > 0) {
                for (let j = 0; j < outputs[i - 1].length; j++) {
                    prevLine += outputs[i - 1][j].textContent
                }
            } else {
                prevLine = " ".repeat(outputs.length)
            }

            for (let j = 0; j < outputs[i].length; j++) {
                outputs[i][j].textContent = prevLine[j]
            }
        }
    }

    let scrollPos = 0
    let scrollDirection = 1

    const clearScrollPiece = () => {
        let scrollLine = towerOffset - 1
        for (let i = 0; i < outputs[scrollLine].length; i++) {
            outputs[scrollLine][i].textContent = " "
        }
    }

    const drawScrollPiece = () => {
        let scrollLine = towerOffset - 1
        clearScrollPiece()
        for (let i = scrollPos; i < scrollPos + towerWidth; i++) {
            if (i < 0 || i > outputs[scrollLine].length - 1)
                continue
            outputs[scrollLine][i].textContent = "#"
        }
    }

    let score = 0

    const dropPiece = () => {
        let scrollLine = towerOffset - 1
        towerWidth = 0
        for (let i = 0; i < outputs[scrollLine].length; i++) {
            if (outputs[scrollLine][i].textContent != "#")
                continue

            if (outputs[scrollLine + 1][i].textContent == "#") {
                towerWidth++
            } else {
                outputs[scrollLine][i].textContent = " "
            }
        }
        if (towerWidth > 0) {
            score++
        } else {
            gameRunning = false
            return
        }

        moveDown()
        update()
    }

    const update = () => {
        if (scrollPos + towerWidth >= GAME_SIZE.x)
            scrollDirection = -1
        if (scrollPos <= 0)
            scrollDirection = 1

        scrollPos += scrollDirection

        drawScrollPiece()
    }

    let gameRunning = true

    let keyListener = addEventListener("keydown", (e) => {
        if (gameRunning == false)
            return

        if (e.key == "c" && e.ctrlKey) {
            removeEventListener("keydown", keyListener)
            gameRunning = false
        }

        if (e.key == " ") {
            dropPiece()
        }
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout([
            ["DROP"],
            ["STRG+C"]
        ])

        terminal.mobileKeyboard.onkeydown = (e, keycode) => {
            if (gameRunning == false)
                return

            if (keycode == "DROP") {
                dropPiece()
            }
        }
    }

    terminal.scroll()
    while (gameRunning) {
        update()
        await sleep(100 - Math.min(score, 15) * 5)
    }

    terminal.printLine(`Game over! Your score: ${score}`)

    await HighscoreApi.registerProcess("stacker")
    await HighscoreApi.uploadScore(score)
}, {
    description: "play a stacker game",
    isGame: true
})

// ------------------- js/commands/stat.js --------------------
terminal.addCommand("stat", async function(args) {
    await terminal.modules.import("statistics", window)

    if (args.color !== null && args["axis-color"] === null) {
        args["axis-color"] = args.color
    }

    if (args.color === null) {
        args.color = terminal.data.foreground.toString()
    }

    if (args["axis-color"] === null) {
        args["axis-color"] = terminal.data.foreground.toString()
    }

    if (args.background === null) {
        args.background = terminal.data.background.toString()
    }

    let dataset = null

    if (args.function) {
        if (args.nums) {
            throw new Error("Cannot specify both nums and function")
        }

        if (!args.x) {
            args.x = "x"
            args["x-name"] = "x"
        }

        if (!args.y) {
            args.y = "y"
            args["y-name"] = "y"
        }

        await terminal.modules.load("mathenv", terminal)

        let func = x => {
            terminal.modules.mathenv.setValue("x", x)
            let [result, error] = terminal.modules.mathenv.eval(args.function)
            if (error)
                throw new Error(error)
            if (isNaN(result))
                throw new Error("Function returned NaN")
            return result
        }

        dataset = Dataset.fromFunc(func, {min: args.min, max: args.max, length: args.length})
    }

    const options = {
        random: "a random data set",
        randomSorted: "a random sorted data set",
        gauss: "a gaussian distribution",
        sin: "a sine wave",
        triangle: "a triangle wave",
        square: "a square wave",
        pendulum: "a pendulum wave"
    }

    if (args.nums == null && dataset == null) {
        terminal.printLine("Usage: stat [options] [nums|dataset]")
        for (let key in options) {
            let command = `stat ${key}`
            terminal.printCommand(`${key.padEnd(12)} ${options[key]}`, command)
        }
        return
    }

    if (dataset == null)
    switch (args.nums.trim()) {
        case "random":
            dataset = Dataset.random({length: args.length})
            break
        case "randomSorted":
            dataset = Dataset.randomSorted({length: args.length})
            break
        case "gauss":
            dataset = Dataset.fromFunc(x => {
                return Math.exp(-Math.pow(x, 2))
            }, {min: -3, max: 3, length: args.length})
            break
        case "sin":
            dataset = Dataset.fromFunc(x => {
                return Math.sin(x) + 1
            }, {min: 0, max: Math.PI * 4, length: args.length})
            break
        case "triangle":
            dataset = Dataset.fromFunc(x => {
                return Math.abs(x % 2 - 1)
            }, {min: 0, max: 4, length: args.length})
            break
        case "square":
            dataset = Dataset.fromFunc(x => {
                return x % 2 < 1 ? 1 : 0
            }, {min: 0, max: 5, length: args.length})
            break
        case "pendulum":
            dataset = Dataset.fromFunc(x => {
                return Math.sin(x)* Math.exp(-x / 10) + 0.7
            }, {min: 1, max: Math.PI * 12, length: args.length})
            break
        default:
            dataset = Dataset.fromString(args.nums)
    }

    if (dataset.length < 2) {
        throw new Error("not enough data points")
    }

    const canvas = document.createElement("canvas")
    canvas.width = args.width
    canvas.height = args.height
    const context = canvas.getContext("2d")
    terminal.parentNode.appendChild(canvas)
    terminal.scroll()

    const plot = (d=dataset) => {
        d.lineplot(context, {
            xAxisName: args.x,
            yAxisName: args.y,
            paddingPx: args.padding,
            arrowSize: 5,
            xAxisNameColor: args["axis-color"],
            yAxisNameColor: args["axis-color"],
            color: args["axis-color"],
            backgroundColor: args.background
        }, {
            color: args.color,
            lineWidth: args.linewidth,
            displayPoints: !args.nopoints
        })
    }

    if (args.animateMs) {
        let intervalMs = args.animateMs / dataset.numbers.length
        let startTime = Date.now()
        let interval = setInterval(() => {
            let time = Date.now() - startTime
            let index = Math.max(Math.floor(time / intervalMs), 1)
            if (index >= dataset.numbers.length) {
                index = dataset.numbers.length - 1
                clearInterval(interval)
            }
            plot(new Dataset(dataset.numbers.slice(0, index + 1)))
        }, intervalMs)
        plot(new Dataset(dataset.numbers.slice(0, 1)))
    } else {
        plot()
    }

    terminal.addLineBreak()
}, {
    description: "show a statistic of a given data set",
    args: {
        "?*nums:s": "the numbers to show the statistic of",
        "?f=function:s": "the function to plot",    
        "?min:n": "the minimum value of the function",
        "?max:n": "the maximum value of the function",
        "?width:n:1~9999": "the width of the canvas",
        "?height:n:1~9999": "the height of the canvas",
        "?x=x-name:s": "the name of the x axis",
        "?y=y-name:s": "the name of the y axis",
        "?p=padding:n:0~9999": "the padding of the canvas",
        "?color=foreground:s": "the color of plot",
        "?axis-color:s": "the color of the axis",
        "?a=animateMs": "animate the plot",
        "?background": "the background color of the canvas",
        "?l=length:i:2~99999": "the length of a data set",
        "?linewidth:n:1~999": "the width of the line in pixels",
        "?nopoints:b": "disable the points being displayed"
    },
    defaultValues: {
        nums: null,
        width: 640,
        height: 400,
        x: null,
        y: null,
        min: -10,
        max: 10,
        padding: 20,
        "axis-color": null,
        color: null,
        animateMs: 500,
        background: null,
        length: 100,
        linewidth: 2,
    }
})

// ------------------- js/commands/style.js --------------------
terminal.addCommand("style", async function(args) {
    class Preset {  

        constructor(b=undefined, f=undefined, c1=Color.rgb(255, 255, 0), c2=Color.rgb(139, 195, 74)) {
            this.background = b
            this.foreground = f
            this.accentColor1 = c1
            this.accentColor2 = c2
        }

    }

    let PRESETS = {}
    PRESETS["normal"] = new Preset(Color.rgb(3, 3, 6), Color.WHITE)
    PRESETS["ha©k€r"] = new Preset(Color.BLACK, Color.hex("#4aff36"), Color.hex("#20C20E"), Color.hex("#20C20E"))
    PRESETS["light"] = new Preset(Color.hex("#255957"), Color.hex("#EEEBD3"))
    PRESETS["purple"] = new Preset(Color.hex("#371E30"), Color.hex("#F59CA9"), Color.hex("#DF57BC"), Color.hex("#F6828C"))
    PRESETS["slate"] = new Preset(Color.hex("#282828"), Color.hex("#ebdbb2"), Color.hex("#d79921"), Color.hex("#98971a"))
    PRESETS["red"] = new Preset(Color.hex("#e74645"), Color.WHITE, Color.hex("#fdfa66"), Color.hex("#fdfa66"), Color.hex("#e74645"))
    PRESETS["cold"] = new Preset(Color.hex("#3c2a4d"), Color.hex("#e0f0ea"), Color.hex("#95adbe"), Color.hex("#95adbe"))

    if (args.preset == null) {
        terminal.printLine("There are a few presets to choose from:")
        let lineWidth = 0
        for (let presetName of Object.keys(PRESETS)) {
            lineWidth += (presetName + " ").length
            terminal.printCommand(presetName + " ", `style ${presetName}`, Color.WHITE, false)
            if (lineWidth > 35) {
                terminal.printLine()
                lineWidth = 0
            }
        }
        terminal.printLine()
        return
    }
    if (!(args.preset in PRESETS))
        throw new Error(`Unknown preset "${args.preset}"`)
    let attributes = ["background", "foreground", "accentColor1", "accentColor2"]
    let preset = PRESETS[args.preset]
    for (let attribute of attributes) {
        if (preset[attribute] == undefined)
            continue
        terminal.data[attribute] = preset[attribute]
    }
}, {
    description: "change the style of the terminal",
    args: ["?preset"],
    standardVals: {
        preset: null
    }
})



// ------------------- js/commands/sudo.js --------------------
terminal.addCommand("sudo", async function() {
    let password = await terminal.prompt("[sudo] password: ", {password: true})
    
    if (password.length < 8)
        throw new Error("Password too short")
    if (password.length > 8)
        throw new Error("Password too long")
    if (password.match(/[A-Z]/))
        throw new Error("Password must not contain uppercase letters")
    if (password.match(/[a-z]/))
        throw new Error("Password must not contain lowercase letters")
    if (password.match(/[0-9]/))
        throw new Error("Password must not contain numbers")

    function containsRepeatedCharacters(str) {
        for (let char of str) {
            if (str.replace(char, "").includes(char))
                return true
        }
        return false
    }

    if (containsRepeatedCharacters(password))
        throw new Error("Password must not contain repeated characters")

    terminal.printSuccess("Password accepted")
    terminal.printLine("You are now officially a hacker!!")
    terminal.printEasterEgg("Hacker-Egg")
}, {
    description: "try to use sudo",
    args: ["**"]
})

// ------------------- js/commands/terminal.js --------------------
terminal.addCommand("terminal", async function(args) {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: terminal.window.location.href,
        name: "Terminal inside Terminal",
        fullscreen: args.f
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })
}, {
    description: "a terminal inside a terminal",
    args: {"?f=fullscreen:b": "Open in fullscreen mode"}
})

// ------------------- js/commands/terml.js --------------------
class TermlSettings {

    static INLINE_DELIMITER = " "
    static LINE_DELIMIETER = "\n"
    static INDENT_CHAR = "\t" // must be a single character
    static DEF_KEYWORD = "DEF"
	static COMMENT_CHAR = "#" // must be a single character

	static TAB_WIDTH = 4

	static maxRepeat = 1000

	static OUT_FUNC = (str) => {
		Terml.output += str
	}

	static IN_FUNC = (str) => {
		return prompt(str)
	}

}

class TermlError extends Error {

    static makeName(name) {
        return `Terml${name}Error`
    }

    constructor(message) {
        super(message)
        this.name = TermlError.makeName("")
    }

}

class TermlSyntaxError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlError.makeName("Syntax")
	}

}

class TermlRuntimeError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlError.makeName("Runtime")
	}

    static makeName(name) {
		return `TermlRuntime${name}Error`
	}

}

class TermlRuntimeNumArgumentsError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlRuntimeError.makeName("NumArguments")
	}

}

class TermlRuntimeTypeError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlRuntimeError.makeName("Type")
	}

}

class TermlRuntimeMaxRepeatError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlRuntimeError.makeName("MaxRepeat")
	}

}

class TermlRuntimeSubstatementIndexError extends TermlError {

	constructor(message) {
		super(message)
		this.name = TermlRuntimeError.makeName("SubstatementIndex")
	}

}

class TermlValueObject {}

class TermlLiteral extends TermlValueObject {

	constructor(value) {
		super()
		this._value = value
		this.isLiteral = true
	}

	get value() {
		return this._value	
	}

	static fromToken(token) {
		if (token.isStringLiteral)
			return new TermlStringLiteral(token.value)
		if (token.isNumberLiteral)
			return new TermlNumberLiteral(token.value)
		throw new TermlError("Token is not a literal")
	}

}

class TermlStringLiteral extends TermlLiteral {

	constructor(value) {
		super(value.toString())
	}

	static fromArray(arr) {
		let str = ""
		for (let charCode of arr) {
			let char = String.fromCharCode(charCode)
			str += char
		}
		return new TermlStringLiteral(str)
	}

	get stringValue() {
		return this._value
	}

	toString() {
		return `"${this.value}"`
	}

	get value() {
		let listData = []
		for (let char of this._value) {
			let charCode = char.charCodeAt(0)
			listData.push(charCode)
		}
		return listData
	}

}

class TermlNumberLiteral extends TermlLiteral {

	constructor(value) {
		super(value)
	}

	toString() {
		return `${this.value}`
	}

}

class TermlToken {

	checkIfNumberLiteral() {
		const numRegex = /^-?\d+(?:\.\d+)?$/

		if (numRegex.test(this.content)) {
			this.isNumberLiteral = true
			this.content = parseFloat(this.content)
			let error = TermlVariable.getValueError(this.content)
			if (error) throw error
			return true
		}

		return false
	}

	toString() {
		return this.content
	}

    constructor(content, {isStringLiteral=false}={}) {
        this.content = content
		this.isStringLiteral = isStringLiteral
		this.isNumberLiteral = this.checkIfNumberLiteral()
    }

	get isLiteral() {
		return this.isStringLiteral || this.isNumberLiteral
	}

	toLiteral() {
		return TermlLiteral.fromToken(this)
	}

    get value() {
        return this.content
    }

}

function TermlIsVar(obj) {
	return (
		obj instanceof TermlVariable ||
		obj instanceof TermlList
	)
}

class TermlVariable extends TermlValueObject {

    constructor(name, value, parentContainer) {
		super()
        if (!name) throw new TermlError("No name provided")
        this.name = name
        this.setValue(value)

        if (!(parentContainer instanceof TermlVariableContainer))
            throw new TermlError("Container is not a TermlVariableContainer")
        this.parentContainer = parentContainer
		this.isList = false
    }

	toString() {
		return `VAR{${this.name}}`
	}

	toCharacter() {
		let char = String.fromCharCode(this.value)
		return char
	}

    get isRoot() {
        return this.parentContainer === undefined   
    }

    get value() {
        return this._value
    }

    set value(value) {
        this.setValue(value)
    }

    static getValueError(value) {
        if (typeof value !== "number")
            return new TermlError("Value is not a number")
    }

    setValue(value=0) {
        const error = TermlVariable.getValueError(value)
        if (error) throw error
        this._value = value
    }

    get binString() {
        return this.value.toString(2).padStart(8, "0")
    }

    get hexString() {
        return this.value.toString(16).padStart(2, "0").toUpperCase()
    }

}

class TermlList extends TermlValueObject {

	constructor(name, value, parentContainer) {
		super()
        if (!name) throw new TermlError("No name provided")
        this.name = name
        this.setValue(value)

        if (!(parentContainer instanceof TermlVariableContainer))
            throw new TermlError("Container is not a TermlVariableContainer")
        this.parentContainer = parentContainer
		this.isList = true
	}

	toString() {
		return `LIST{${this.name}}`
	}

	set value(value) {
		this.setValue(value)
	}

	copyValue() {
		return this._value.slice()
	}

	get reference() {
		return this._value
	}

	get value() {
		return this.copyValue()
	}

	setValue(value=[]) {
        const error = TermlList.getValueError(value)
        if (error) throw error
        this._value = value
	}

	static getValueError(value) {
		if (!Array.isArray(value))
			return new TermlError("Value is not an array")
		for (let i = 0; i < value.length; i++) {
			const error = TermlVariable.getValueError(value[i])
			if (error) return error
		}
	}

	getStringContent() {
		return this.value.map(v => v.toCharacter()).join()
	}

	get binString() {
		return this.value.map(v => v.toString(2).padStart(8, "0")).join(" ")
	}

	get hexString() {
		return this.value.map(v => v.toString(16).padStart(2, "0").toUpperCase()).join(" ")
	}

}

class TermlModule {

	constructor(name, functions, variables, termlCode) {
		const toDict = (arr, key) => {
			let dict = {}
			for (let item of arr) {
				dict[item[key]] = item
			}
			return dict
		}

		if (!name) throw new TermlError("No name provided")
		this.name = name
		this.functions = toDict(functions, "name")
		this.variables = toDict(variables, "name")
		this.termlCode = termlCode
	}

}

class TermlVariableContainer {

    constructor({name=undefined, parentContainer=undefined}={}) {
        this.variables = {}
        this.functions = {}
        this.name = name // name may be undefined

        if (parentContainer && !(parentContainer instanceof TermlVariableContainer))
            throw new TermlError("Parent container is not a VariableContainer")
        this.parentContainer = parentContainer // parentContainer may be undefined
    }

	importModule(module) {
		if (!(module instanceof TermlModule))
			throw new TermlError("Module is not a TermlModule")
		for (let name in module.functions) {
			if (!this.functionExists(name))
				this.setFunction(name, module.functions[name])
		}
		for (let name in module.variables) {
			if (!this.variableExists(name))
				this.setVariable(name, module.variables[name])
		}
	}

    setFunction(name, func) {
        if (!name)
            throw new TermlError("No name provided")
        if (!(func instanceof TermlFunction))
            throw new TermlError("Function is not a TermlFunction")
        this.functions[name] = func
    }

    functionExists(name) {
        if (!name)
            throw new TermlError("No name provided")
        return this.functions[name] !== undefined
    }

    getFunction(name) {
        if (!name) 
            throw new TermlError("No name provided")
        return this.functions[name]
    }

    getVariable(name) {
        if (!name)
            throw new TermlError("No name provided")
        return this.variables[name]
    }

	variableExists(name) {
		if (!name)
			throw new TermlError("No name provided")
		return this.variables[name] !== undefined
	}

	setVariableRef(name, variable) {
		if (!name)
			throw new TermlError("No name provided")
		if (!TermlIsVar(variable))
			throw new TermlError("Variable is not a TermlVariable")
		this.variables[name] = variable
	}

    setVariable(name, value) {
        if (!name)
            throw new TermlError("No name provided")
        if (this.variables[name]) {
            this.variables[name].value = value
        } else {
			try {
				this.variables[name] = new TermlVariable(name, value, this)
			} catch (error) {
				try {
					this.variables[name] = new TermlList(name, value, this)
				} catch (error) {
					throw new TermlError("Variable is not a TermlVariable or TermlList")
				}
			}
        }
    }

}

class TermlStatement {

    constructor(functionName, args, {substatements=undefined, parent=undefined, container=undefined}={}) {
        if (!functionName)
            throw new TermlError("No functionName provided")
        this.functionName = functionName
        this.args = args || []
        this.substatements = substatements || []
		this.container = container || new TermlVariableContainer({name: this.makeContainerName()})
        this.parent = parent // parent may be undefined

		this.isStatement = true
		this.isFunction = false
    }

	toString() {
		return `STMT{${this.functionName.value}; ${this.args.map(a => a.toString()).join(", ")}}`
	}

	makeContainerName() {
        return `STMT{${this.functionName.value}}`
    }

    addSubstatement(statement) {
        if (!(statement instanceof TermlStatement))
            throw new TermlError("Statement is not a TermlStatement")
        this.substatements.push(statement)
    }

    static fromTokens(tokens, opts) {
        if (!tokens || !tokens.length)
            throw new TermlError("No tokens provided")
        const functionName = tokens.shift()
        return new TermlStatement(functionName, tokens, opts)
    }

}

class TermlFunction {

    constructor(name, args, statements, jsFunction) {
        if (!name)
            throw new TermlError("No name provided")
        this.name = name
        this.args = args || []
        this.statements = statements || []
        this.container = new TermlVariableContainer({name: this.makeContainerName()})

		if (jsFunction && typeof jsFunction !== "function")
			throw new TermlError("jsFunction is not a function")
		this.jsFunction = jsFunction

		this.isStatement = false
		this.isFunction = true
    }

	execute() {
		if (this.jsFunction) {
			return this.jsFunction(...arguments)
		} else {
			throw new TermlError("Function has no jsFunction")
		}
	}

    makeContainerName() {
        return `FUNC{${this.name.value}}`
    }

    addStatement(statement) {
        if (!(statement instanceof TermlStatement))
            throw new TermlError("Statement is not a TermlStatement")
        this.statements.push(statement)
    }

}

class TermlParser {

    constructor() {
        this.globalStatement = new TermlStatement(
			new TermlToken("__GLOBAL__"),
            [], {parent: undefined})
    }

    tokenize(line) {
        let tokens = []
        let currentToken = ""
        let inString = false
		const inlineDeliminiters = [TermlSettings.INLINE_DELIMITER]
        const stringDelimiters = ["\"", "'"]
        let currentStringDelimiter = undefined

        for (let char of line) {
            if (inString) {
                if (char === currentStringDelimiter) {
                    inString = false
                    currentStringDelimiter = undefined
                    tokens.push(new TermlToken(currentToken, {isStringLiteral: true}))
                    currentToken = ""
                } else {
                    currentToken += char
                }
            } else {
                if (stringDelimiters.includes(char)) {
                    inString = true
                    currentStringDelimiter = char
                } else if (inlineDeliminiters.includes(char)) {
                    if (currentToken !== "")
                        tokens.push(new TermlToken(currentToken))
                    currentToken = ""
                } else {
                    currentToken += char
                }
            }
			if (currentToken === TermlSettings.INDENT_CHAR) {
				tokens.push(new TermlToken(currentToken))
				currentToken = ""
			}
        }

        if (currentToken !== "")
            tokens.push(new TermlToken(currentToken))

		tokens = tokens.map(token => {
			if (token.isLiteral)
				return token.toLiteral()
			else
				return token
		})

        return tokens
    }

    parseLines(lines) {
		let tokenizedLines = lines.map(this.tokenize)
        let currIndent = 0

        let lastStatement = undefined
		
		let currParent = this.globalStatement
        for (let line of tokenizedLines) {
			if (line.length === 0)
				continue

            let indent = 0
            while (line[0].value === TermlSettings.INDENT_CHAR) {
                indent++
                line.shift()
            }

            if (indent - 1 > currIndent)
                throw new TermlSyntaxError("Invalid indentation")

            while (indent < currIndent) {
                currParent = currParent.parent
                currIndent--
            }

            if (indent > currIndent) {
                if (!lastStatement)
                    throw new TermlSyntaxError("Invalid indentation (no previous statement)")

                currParent = lastStatement
            }

            let statement = TermlStatement.fromTokens(line, 
                {parent: currParent})

            currParent.addSubstatement(statement)

			lastStatement = statement
			currIndent = indent
        }
    }

    extractLines(string) {
        return string
            .split(TermlSettings.LINE_DELIMIETER)
            .filter(line => line.trim().length > 0)
    }

    parse(string) {
        if (typeof string !== "string")
            throw new TermlError("Input is not a string")
        this.parseLines(this.extractLines(string))
		return this.globalStatement
    }

}

const TermlStandardModule = new TermlModule("standard", [

	new TermlFunction("__GLOBAL__", [], [], (args, statement, runtime) => {
		Terml.checkType(args, [])
		for (let substatement of statement.substatements) {
			runtime.executeStatement(substatement)
		}
	}),

	new TermlFunction("NEW", ["name", "?value"], [], (args, statement, runtime) => {
		let container = statement.parent.container
		if (!Terml.getTypeError(args, [TermlStringLiteral])) {
			container.setVariable(args[0].stringValue, undefined)
			return
		} 

		Terml.checkType(args, [TermlStringLiteral, TermlValueObject])
		let [varName, varValue] = args
		container.setVariable(varName.stringValue, varValue.value)
	}),

	new TermlFunction("NEW_LST", ["name", "?value"], [], (args, statement, runtime) => {
		let container = statement.parent.container
		if (!Terml.getTypeError(args, [TermlStringLiteral])) {
			container.setVariable(args[0].stringValue, [])
			return
		} 

		window.container = container

		Terml.checkType(args, [TermlStringLiteral, TermlStringLiteral])
		let [varName, varValue] = args
		container.setVariable(varName.stringValue, varValue.value)
	}),

	new TermlFunction("PUSH", ["name", "value"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject])
		let [variable, valueToken] = args
		variable.reference.push(valueToken.value)
	}),

	new TermlFunction("INSERT_AT", ["name", "value", "index"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject, TermlNumberLiteral])
		let [variable, valueToken, indexToken] = args
		variable.reference.splice(indexToken.value, 0, valueToken.value)
	}),

	new TermlFunction("POP", ["name", "?var"], [], (args, statement, runtime) => {
		if (!Terml.getTypeError(args, [TermlList])) {
			let [variable] = args
			variable.reference.pop()
			return
		}
		Terml.checkType(args, [TermlList, TermlVariable])
		let [variable, valueToken] = args
		if (variable.value.length === 0)
			return
		valueToken.value = variable.reference.pop()
	}),

	new TermlFunction("CONCAT", ["list1", "list2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlList])
		let [list1, list2] = args
		list1.value = list1.value.concat(list2.value)
	}),

	new TermlFunction("UNSHIFT", ["name", "value"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject])
		let [variable, valueToken] = args
		variable.reference.unshift(valueToken.value)
	}),

	new TermlFunction("DELETE_AT", ["name", "index"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject])
		let [variable, indexToken] = args
		if (indexToken.value >= variable.value.length)
			return
		variable.reference.splice(indexToken.value, 1)
	}),

	new TermlFunction("SHIFT", ["name", "?var"], [], (args, statement, runtime) => {
		if (!Terml.getTypeError(args, [TermlList])) {
			let [variable] = args
			variable.reference.shift()
			return
		}
		Terml.checkType(args, [TermlList, TermlVariable])
		let [variable, valueToken] = args
		valueToken.value = variable.reference.shift()
	}),

	new TermlFunction("GET_AT", ["name", "index", "var"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject, TermlVariable])
		let [variable, indexToken, valueToken] = args
		valueToken.value = variable.reference[indexToken.value]
	}),

	new TermlFunction("SET_AT", ["name", "index", "value"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList, TermlValueObject, TermlValueObject])
		let [variable, indexToken, valueToken] = args
		variable.reference[indexToken.value] = valueToken.value
	}),

	new TermlFunction("SET", ["name", "value"], [], (args, statement, runtime) => {
		if (!Terml.getTypeError(args, [TermlList, TermlList])) {
			let [list1, list2] = args
			list1.value = list2.value
			return
		}
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [variable, valueToken] = args
		variable.value = valueToken.value
	}),

	new TermlFunction("OUT", ["value"], [], (args, statement, runtime) => {
		if (!Terml.getTypeError(args, [TermlValueObject])) {
			let [valueToken] = args
			let value = valueToken.value
			if (Array.isArray(value)) 
				value = TermlStringLiteral.fromArray(value).stringValue
			TermlSettings.OUT_FUNC(("" + value).replace(/\\n/g, "\n"))
		}
	}),

	new TermlFunction("OUT_LST", ["value"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlValueObject])
		let error = Terml.getTypeError(args, [TermlList])
		if (error) error = Terml.getTypeError(args, [TermlStringLiteral])
		if (error) throw error
		let stringVal = JSON.stringify(args[0].value)
		TermlSettings.OUT_FUNC(stringVal)
	}),

	new TermlFunction("IN", ["name"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlList])
		let [variable] = args
		let input = TermlSettings.IN_FUNC()
		variable.value = new TermlStringLiteral(input).value
	}),

	new TermlFunction("ADD", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value += var2.value
	}),

	new TermlFunction("SUB", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value -= var2.value
	}),

	new TermlFunction("MUL", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value *= var2.value
	}),

	new TermlFunction("DIV", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value /= var2.value
	}),

	new TermlFunction("MOD", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value %= var2.value
	}),

	new TermlFunction("POW", ["var1", "var2"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable, TermlValueObject])
		let [var1, var2] = args
		var1.value = Math.pow(var1.value, var2.value)
	}),

	new TermlFunction("ROUND", ["var"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable])
		let [var1] = args
		var1.value = Math.round(var1.value)
	}),

	new TermlFunction("SQRT", ["var"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable])
		let [var1] = args
		var1.value = Math.sqrt(var1.value)
	}),

	new TermlFunction("FLOOR", ["var"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable])
		let [var1] = args
		var1.value = Math.floor(var1.value)
	}),

	new TermlFunction("CEIL", ["var"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlVariable])
		let [var1] = args
		var1.value = Math.ceil(var1.value)
	}),

	new TermlFunction("DEF", [], [], (args, defStatement, runtime) => {
		Terml.checkType(args[0], TermlStringLiteral)
		let funcName = args[0].stringValue
		let funcArgs = args.slice(1)
		Terml.checkType(funcArgs, funcArgs.map(() => TermlStringLiteral))

		function parseVarName(name) {
			let info = {
				isReference: false,
			}

			if (name.startsWith("&")) {
				info.isReference = true
				name = name.slice(1)
			}

			info.name = name
			return info
		}

		function jsFunc(args, statement) {
			if (args.length !== funcArgs.length)
				throw new TermlRuntimeNumArgumentsError()
			Terml.checkType(args, args.map(() => TermlValueObject))
			for (let i = 0; i < funcArgs.length; i++) {
				let varInfo = parseVarName(funcArgs[i].stringValue)
				if (varInfo.isReference && TermlIsVar(args[i])) {
					defStatement.container.setVariableRef(varInfo.name, args[i])
				} else {
					defStatement.container.setVariable(funcArgs[i].stringValue, args[i].value)
				}
			}

			defStatement.container.setFunction("EXEC_SUB", new TermlFunction("EXEC_SUB", [], [], (execArgs) => {
				Terml.checkType(execArgs, [TermlValueObject])
				let subIndex = execArgs[0].value
				if (subIndex < 0 || subIndex >= defStatement.substatements.length)
					throw new TermlRuntimeSubstatementIndexError()
				let substatement = statement.substatements[subIndex]
				if (substatement === undefined)
					throw new TermlRuntimeSubstatementIndexError("undefined")
				runtime.executeStatement(substatement)
			}))

			defStatement.container.setFunction("LEN_SUB", new TermlFunction("LEN_SUB", [], [], (lenArgs) => {
				Terml.checkType(lenArgs, [TermlVariable])
				lenArgs[0].value = statement.substatements.length
			}))

			for (let substatement of defStatement.substatements) {
				runtime.executeStatement(substatement)
			}
		}

		let func = new TermlFunction(funcName, args, defStatement.substatements, jsFunc)
		defStatement.parent.container.setFunction(funcName, func)
	}),

	new TermlFunction("IS_EQ", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		outputVar.value = (val1.value === val2.value) ? 1 : 0
	}),

	new TermlFunction("IS_LT", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		outputVar.value = (val1.value < val2.value) ? 1 : 0
	}),

	new TermlFunction("IS_GT", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		outputVar.value = (val1.value > val2.value) ? 1 : 0
	}),

	new TermlFunction("OR", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		outputVar.value = (val1.value || val2.value) ? 1 : 0
	}),

	new TermlFunction("XOR", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		let a = val1.value ? 1 : 0
		let b = val2.value ? 1 : 0
		outputVar.value = (a ^ b) ? 1 : 0
	}),

	new TermlFunction("NOT", ["val1", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlVariable])
		let [val1, outputVar] = args
		outputVar.value = (val1.value) ? 0 : 1
	}),

	new TermlFunction("AND", ["val1", "val2", "var"], [], (args) => {
		Terml.checkType(args, [TermlValueObject, TermlValueObject, TermlVariable])
		let [val1, val2, outputVar] = args
		let a = val1.value ? 1 : 0
		let b = val2.value ? 1 : 0
		outputVar.value = (a && b) ? 1 : 0
	}),

	new TermlFunction("IF", ["value"], [], (args, statements, runtime) => {
		Terml.checkType(args, [TermlValueObject])
		let [value] = args
		if (value.value !== 0) {
			for (let substatement of statements.substatements) {
				runtime.executeStatement(substatement)
			}
		}
	}),

	new TermlFunction("IF_NOT", ["value"], [], (args, statements, runtime) => {
		Terml.checkType(args, [TermlValueObject])
		let [value] = args
		if (value.value === 0) {
			for (let substatement of statements.substatements) {
				runtime.executeStatement(substatement)
			}
		}
	}),

	new TermlFunction("WHILE", ["value"], [], (args, statement, runtime) => {
		Terml.checkType(args, [TermlValueObject])
		let [value] = args
		let count = 0
		while (value.value !== 0) {
			for (let substatement of statement.substatements) {
				runtime.executeStatement(substatement)
			}
			count++
			if (count > TermlSettings.maxRepeat)
				throw new TermlRuntimeMaxRepeatError("WHILE loop exceeded maximum number of iterations")
		}
	}),

	new TermlFunction("WHILE_NOT", ["value"], [], (args, statements, runtime) => {
		Terml.checkType(args, [TermlValueObject])
		let [value] = args
		let count = 0
		while (value.value !== 0) {
			for (let substatement of statements.substatements) {
				runtime.executeStatement(substatement)
			}
			count++
			if (count > TermlSettings.maxRepeat)
				throw new TermlRuntimeMaxRepeatError("WHILE_NOT loop exceeded maximum number of iterations")
		}
	}),

	new TermlFunction("REPEAT", ["value"], [], (args, statement, runtime) => {
		let variable = null
		if (!Terml.getTypeError(args, [TermlValueObject, TermlStringLiteral])) {
			let container = statement.container
			container.setVariable(args[1].stringValue, undefined)
			variable = container.getVariable(args[1].stringValue)
		} else {
			Terml.checkType(args, [TermlValueObject])
		}
		
		let val = args[0].value

		if (val < 0)
			throw new TermlRuntimeError("REPEAT value must be positive")
		if (val > TermlSettings.maxRepeat)
			throw new TermlRuntimeMaxRepeatError(`REPEAT value must be less than ${TermlSettings.maxRepeat}`)
		for (let count = 0; count < val; count++) {
			if (variable)
				variable.value = count
			for (let substatement of statement.substatements) {
				runtime.executeStatement(substatement)
			}
		}
	}),

], [])

class TermlRuntime {

	constructor(globalStatement) {
		this.preCode = ""
		this.globalStatement = globalStatement
		this.importModule(TermlStandardModule)
	}

	importModule(module) {
		this.globalStatement.container.importModule(module)
	}

	execute() {
		this.executeStatement(this.globalStatement)
	}

	getVariable(name, statement) {
		if (!statement)
			statement = this.globalStatement

		let currContainer = statement
		while (!currContainer.container.variableExists(name)) {
			currContainer = currContainer.parent
			if (!currContainer) {
				throw new TermlError(`Variable ${name} is not defined`)
			}
		}
		return currContainer.container.getVariable(name)
	}

	getFunction(name, statement) {
		if (!statement)
			statement = this.globalStatement

		let currContainer = statement
		while (!currContainer.container.functionExists(name)) {
			currContainer = currContainer.parent
			if (!currContainer)
				throw new TermlError(`Function ${name} is not defined`)
		}
		return currContainer.container.getFunction(name)
	}

	executeStatement(statement) {
		let functionName = statement.functionName.value
		let func = this.getFunction(functionName, statement)
		let args = statement.args.map(arg => {
			return (arg.isLiteral) ? arg : this.getVariable(arg.value, statement)
		})
		func.execute(args, statement, this)
	}

}

class Terml {

	static output = ""

	static checkType(value, type) {
		let error = Terml.getTypeError(value, type)
		if (error) throw error
	}

	static getTypeError(value, type) {
		if (type instanceof Array) {
			if (!(value instanceof Array)) {
				return new TermlRuntimeTypeError("Array")
			}
			if (type.length !== value.length) {
				return new TermlRuntimeNumArgumentsError()
			}
			if (type.length === 0)
				return undefined
			for (let t of type) {
				for (let v of value)
					if (v instanceof t)
						return undefined
					else
						return new TermlRuntimeTypeError(t.name)
			}
			throw new TermlRuntimeTypeError(type.name)
		} else {
			if (value instanceof type)
				return undefined
			else
				return new TermlRuntimeTypeError(type.name)
		}
	}

	static get Settings() {
		return TermlSettings
	}

	static removeStaticWhitespace(text) {
		let lines = text.split("\n").filter(l => l.length > 0)
		const allLinesStartWith = str => {
			for (let line of lines)
				if (!line.startsWith(str))
					return false
			return true
		}

		const removeFirstCharOfLines = () => {
			for (let i = 0; i < lines.length; i++) {
				lines[i] = lines[i].slice(1)
			}
			lines = lines.filter(l => l.length > 0)
			return lines.length === 0
		}

		while (allLinesStartWith(" ")) if(removeFirstCharOfLines()) break
		while (allLinesStartWith("\t")) if(removeFirstCharOfLines()) break

		return lines.join("\n")
	}

	static furbishCode(code) {
		const commentRegex = new RegExp(`^[\\s\\t]*${TermlSettings.COMMENT_CHAR}.*$`)
		let lines = code.split(TermlSettings.LINE_DELIMIETER)
			.filter(l => l.length > 0)
			.filter(l => !commentRegex.test(l))
		
		code = lines.join(TermlSettings.LINE_DELIMIETER)
		code = Terml.removeStaticWhitespace(code)
			.replaceAll(" ".repeat(TermlSettings.TAB_WIDTH), TermlSettings.INDENT_CHAR)

		let docParser = new DOMParser().parseFromString(code, "text/html")
		return docParser.documentElement.textContent
	}

	static run(code, {log=false}={}) {
		code = Terml.furbishCode(code)
		Terml.output = ""
		const parser = new TermlParser()
		const globalStatement = parser.parse(code)
		const runtime = new TermlRuntime(globalStatement)
		runtime.execute()

		if (log) Terml.logOutput()

		return Terml.output
	}

	static logOutput() {
		console.log(Terml.output)
	}

	static parseDocument(document) {
		let termlElements = document.querySelectorAll("terml")
		for (let element of termlElements) {
			const code = element.innerHTML
			const parentElement = element.parentElement
			element.remove()

			let newTextContent = ""

			try {
				newTextContent = Terml.run(code)
			} catch (e) {
				if (e instanceof TermlError) {
					newTextContent = e.toString()
				} else {
					throw e
				}
			}

			parentElement.innerHTML += newTextContent
		}
	}

}

terminal.addCommand("terml", async function(args) {
	const file = terminal.getFile(args.file)
	if (file.isDirectory)
		throw new Error("File is not readable")
	const code = file.content
	TermlSettings.OUT_FUNC = txt => {
		terminal.print(txt)
	}
	
	try {
		Terml.run(code)
	} catch (e) {
		terminal.addLineBreak()
		throw e
	}
}, {
	description: "run a .terml file",
	args: {
		"file": "the file to run"
	}
})

// ------------------- js/commands/tetris.js --------------------
terminal.addCommand("tetris", async function(args) {
    await terminal.modules.import("game", window)

    const pieces = [
        [[0,-2], [0,-1], [0, 0], [ 0, 1]],
        [[0,-1], [0, 0], [0, 1], [-1, 0]],
        [[0,-1], [0, 0], [0, 1], [-1, 1]],
        [[0,-1], [0, 0], [0, 1], [-1,-1]],
        [[0,-1], [0, 0], [-1,1], [-1, 0]],
        [[-1,-1],[0, 0], [-1,0], [ 0, 1]],
        [[-1,-1],[0, 0], [-1,0], [ 0,-1]],
    ].map(p => p.map(s => new Vector2d(s[0], s[1])))

    const pieceType = {
        CUBE: 6
    }

    const pieceColors = [
        Color.hex("FF0000"),
        Color.hex("00FF00"),
        Color.hex("0000FF"),
        Color.hex("FFFF00"),
        Color.hex("FF00FF"),
        Color.hex("00FFFF"),
        Color.hex("88FF88"),
    ]

    const FIELD_HEIGHT = 20
    const FIELD_WIDTH = 10

    class Piece {

        constructor(pieceIndex, game) {
            this.pieceIndex = pieceIndex ?? Math.floor(Math.random() * pieces.length)
            this.relativeCoords = [...pieces[pieceIndex]]
            this.color = pieceColors[pieceIndex]
            this.pos = 0
            this.falling = true
            this.game = game

            this.id = Math.random()
        }

        equals(otherPiece) {
            return this.id == otherPiece.id
        }

        get value() {
            return this.pieceIndex + 1
        }

        get type() {
            return this.pieceIndex
        }

        get coords() {
            return this.relativeCoords.map(c => c.add(this.pos))
        }

        rotate() {
            if (this.type == pieceType.CUBE)
                return

            let prevCoords = this.relativeCoords.map(c => c.copy())
            this.relativeCoords = this.relativeCoords.map(c => new Vector2d(-c.y, c.x))
            if (this.outOfBounds()) {
                this.relativeCoords = prevCoords
            }
        }

        draw() {
            this.coords.forEach(c => {
                if (c.x >= 0 && c.x < FIELD_WIDTH && c.y >= 0 && c.y < FIELD_HEIGHT) {
                    this.game.canvas[c.y][c.x] = this.value
                }
            })
        }

        touchesOtherPiece() {
            for (let pos of this.coords) {
                if (this.game.fieldOccupied(pos, this)) {
                    return true
                }
            }
            return false
        }

        outOfBounds() {
            if (this.touchesOtherPiece()) return true
            return this.coords.some(c => c.x < 0 || c.x >= FIELD_WIDTH || c.y >= FIELD_HEIGHT)
        }

        moveSide(amount) {
            this.pos = this.pos.add(new Vector2d(amount, 0))
            if (this.outOfBounds()) {
                this.pos = this.pos.add(new Vector2d(-amount, 0))
            }
        }

        update() {
            this.pos.y += 1
            if (this.outOfBounds()) {
                this.pos.y -= 1
                this.falling = false
            }
        }

    }

    class TetrisGame {

        firstDraw() {
            this.canvasOutputs = []
            this.nextPieceOutputs = []
            this.holdPieceOutputs = []
            this.scoreOutput = null
            terminal.printLine("+" + "-".repeat(FIELD_WIDTH * 2) + "+")
            for (let i = 0; i < FIELD_HEIGHT; i++) {
                let outputRow = []
                terminal.print("|")
                for (let j = 0; j < FIELD_WIDTH; j++) {
                    let element = terminal.print("  ", undefined, {forceElement: true})
                    outputRow.push(element)
                    element.style.transition = "none"
                }
                terminal.print("|")
                this.canvasOutputs.push(outputRow)

                const printPiecePart = output => {
                    terminal.print("   |")
                    let line = []
                    for (let i = 0; i < 3; i++) {
                        line.push(terminal.print("  ", undefined, {forceElement: true}))
                        line[i].style.transition = "none"
                    }
                    terminal.print("|")
                    output.push(line)
                }

                if (i == 0) terminal.print("   +-Next-+")
                if (i > 0 && i < 5) printPiecePart(this.nextPieceOutputs)
                if (i == 5) terminal.print("   +------+")

                if (i == 7) terminal.print("   +-Hold-+")
                if (i > 7 && i < 12) printPiecePart(this.holdPieceOutputs)
                if (i == 12) terminal.print("   +------+")

                if (i == 14) {
                    terminal.print("   Score: ")
                    this.scoreOutput = terminal.print("0")
                }

                terminal.addLineBreak()
            }
            terminal.printLine("+" + "-".repeat(FIELD_WIDTH * 2) + "+")
        }

        clearCanvas() {
            this.canvas = Array.from({length: FIELD_HEIGHT}, () => Array.from({length: FIELD_WIDTH}, () => 0))
        }

        drawPixel(pos, value) {
            if (pos.x < 0 || pos.x >= FIELD_WIDTH || pos.y < 0 || pos.y >= FIELD_HEIGHT)
                return

            let realPos = pos.mul(new Vector2d(1, 1))

            let color = new Color(0, 0, 0, 0)
            if (value != 0) {
                color = pieceColors[value - 1]
            }

            this.canvasOutputs[realPos.y][realPos.x].style.backgroundColor = color.toString()
        }

        constructor() {
            this.running = true
            this.intervalTime = 500

            this.canvasOutputs = null
            this.firstDraw()

            this.canvas = null
            this.clearCanvas()

            this.pieces = []
            this.pieceQueue = this.makeShuffledPieces()

            this.holdPieceIndex = null

            this.score = 0
        }

        makeShuffledPieces() {
            let tempPieces = Array.from({length: pieces.length}, (_, i) => i)
            tempPieces.sort(() => Math.random() - 0.5)
            return tempPieces
        }

        get currFallingPiece() {
            return this.pieces.find(p => p.falling)
        }

        anyPieceFalling() {
            return this.pieces.some(p => p.falling)
        }

        update() {
            for (let piece of this.pieces)
                piece.update()
            if (!this.anyPieceFalling()) {
                if (this.pieceQueue.length < 2) {
                    this.pieceQueue = this.makeShuffledPieces()
                }
                this.spawnPiece(this.pieceQueue.shift())
            }

            this.checkLines()
        }

        removeLine(lineIndex) {
            this.pieces.forEach(p => {
                for (let i = 0; i < p.relativeCoords.length; i++) {
                    let relativeCoord = p.relativeCoords[i]
                    let coord = relativeCoord.add(p.pos)
                    if (coord.y == lineIndex) {
                        p.relativeCoords.splice(i, 1)
                        i--
                    } else if (coord.y < lineIndex) {
                        p.relativeCoords[i] = relativeCoord.add(new Vector2d(0, 1))
                    }
                }
            })
        }

        checkLines() {
            for (let y = 0; y < FIELD_HEIGHT; y++) {
                let line = this.canvas[y]
                if (line.every(v => v != 0)) {
                    this.removeLine(y)
                    this.score += 1
                }
            }
        }

        fieldOccupied(pos, ignorePiece) {
            for (let piece of this.pieces) {
                if (piece.equals(ignorePiece))
                    continue
                if (piece.coords.some(c => c.equals(pos)))
                    return true
            }
            return false
        }

        spawnPiece(typeIndex) {
            let piece = new Piece(typeIndex, this)
            piece.pos = new Vector2d(Math.floor(FIELD_WIDTH / 2), 0)
            let rotations = Math.floor(Math.random() * 4)
            for (let i = 0; i < rotations; i++)
                piece.rotate()
            this.pieces.push(piece)
            if (piece.touchesOtherPiece())
                this.running = false
        }

        drawSidepanel(pieceIndex, outputArray) {
            if (pieceIndex === undefined || pieceIndex === null) return

            let piece = new Piece(pieceIndex, this)

            for (let i = 0; i < outputArray.length; i++) {
                for (let j = 0; j < outputArray[i].length; j++) {
                    outputArray[i][j].style.backgroundColor = "rgba(0, 0, 0, 0)"
                    let x = j - 1
                    let y = i - 2
                    if (piece.relativeCoords.some(c => c.x == x && c.y == y)) {
                        outputArray[i][j].style.backgroundColor = pieceColors[piece.pieceIndex]
                    }
                }
            }
        }

        hold() {
            if (this.holdPieceIndex === null) {
                this.holdPieceIndex = this.currFallingPiece.pieceIndex
                this.pieces.splice(this.pieces.indexOf(this.currFallingPiece), 1)
                return
            } else {
                let temp = this.currFallingPiece.pieceIndex
                this.pieces.splice(this.pieces.indexOf(this.currFallingPiece), 1)
                this.spawnPiece(this.holdPieceIndex)
                this.holdPieceIndex = temp
            }
        }

        draw() {
            this.clearCanvas()
            for (let piece of this.pieces)
                piece.draw(this)
            for (let i = 0; i < FIELD_HEIGHT; i++) {
                for (let j = 0; j < FIELD_WIDTH; j++) {
                    let value = this.canvas[i][j]
                    this.drawPixel(new Vector2d(j, i), value)
                }
            }

            this.drawSidepanel(this.pieceQueue[0], this.nextPieceOutputs)
            this.drawSidepanel(this.holdPieceIndex, this.holdPieceOutputs)

            this.scoreOutput.textContent = this.score
        }

    }

    let game = new TetrisGame()

    function onkeydown(keycode, e) {
        if (keycode == "ArrowLeft") {
            game.currFallingPiece.moveSide(-1)
            game.draw()
        } else if (keycode == "ArrowRight") {
            game.currFallingPiece.moveSide(1)
            game.draw()
        } else if (keycode == "ArrowDown") {
            game.update()
            game.draw()
            if (e)
                e.preventDefault()
        } else if (keycode == "ArrowUp") {
            game.currFallingPiece.rotate()
            game.draw()
            if (e)
                e.preventDefault()
        } else if (keycode == "h" || keycode == "HOLD") {
            game.hold()
            game.draw()
            if (e)
                e.preventDefault()
        }
    }

    let keyListener = addEventListener("keydown", (e) => {
        if (game.running == false)
            return

        if (e.key == "c" && e.ctrlKey) {
            removeEventListener("keydown", keyListener)
            game.running = false
        }

        if (game.anyPieceFalling() == false)
            return

        onkeydown(e.key, e)
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout([
            [null, "↑", null],
            ["←", "↓", "→"],
            ["HOLD"],
            ["STRG+C"]
        ])

        terminal.mobileKeyboard.onkeydown = (e, keycode) => {
            onkeydown(keycode)
        }
    }

    terminal.scroll()
    while (game.running) {
        game.update()
        game.draw()
        await sleep(game.intervalTime)
    }

    terminal.printLine(`Game over! Your score was ${game.score}`)

    await HighscoreApi.registerProcess("tetris")
    await HighscoreApi.uploadScore(game.score)

}, {
    description: "play a classic game of tetris",
    isGame: true
})

// ------------------- js/commands/tictactoe.js --------------------
terminal.addCommand("tictactoe", async function(args) {
    await terminal.modules.import("game", window)

    const N = " "
    const X = "X"
    const O = "O"

    let field = [[N, N, N], [N, N, N], [N, N, N]]

    function setField(n, val) {
        let row = (n + 2) % 3
        let index = Math.floor((n -0.1) / 3)
        field[index][row] = val
    }

    function getField(n) {
        let row = (n + 2) % 3
        let index = Math.floor((n - 0.1) / 3)
        return field[index][row]
    }

    function printField() {
        terminal.printLine(` ${getField(1)} | ${getField(2)} | ${getField(3)} `)
        terminal.printLine(`---+---+---`)
        terminal.printLine(` ${getField(4)} | ${getField(5)} | ${getField(6)} `)
        terminal.printLine(`---+---+---`)
        terminal.printLine(` ${getField(7)} | ${getField(8)} | ${getField(9)} `)
    }

    async function getUserInput() {
        input = await terminal.promptNum("Your move [1-9]: ", {min: 1, max: 9})
        if (getField(input) != N) {
            terminal.printLine("Field is not free.")
            return getUserInput()
        } else {
            return input
        }
    }

    function isWon() {
        const possibleWins = [
            [1, 2, 3], [4, 5, 6], [7, 8, 9],
            [1, 4, 7], [2, 5, 8], [3, 6, 9],
            [1, 5, 9], [3, 5, 7]
        ]
        for (let winner of [X, O]) {
            for (let winConfig of possibleWins) {
                let winConfigTrue = true
                for (let condition of winConfig) {
                    if (getField(condition) != winner)
                        winConfigTrue = false
                }
                if (winConfigTrue) {
                    return winner
                }
            }
        }
        return false
    }

    function isDraw() {
        for (let i = 0; i < 9; i++)
            if (getField(i + 1) == N)
                return false
        return true
    }

    function getComputerInputRandom() {
        let a = Math.floor(Math.random() * 9) + 1
        while (getField(a) != 0)
            a = Math.floor(Math.random() * 9) + 1
        return a
    }

    function getComputerInputNormal() {
        const f = Array.from({length: 9}).map((v, i) => getField(i + 1)).map(f => f == " " ? "_" : f)
        const originalF = f.slice()

        function randomChoice(lst) {
            const index = Math.floor(Math.random() * lst.length)
            if (originalF[index] != "_") {
                return randomChoice(lst)
            }
            return lst[index]
        }

        function seite() {
            return randomChoice([2, 4, 6, 8])
        }

        function ecke() {
            return randomChoice([1, 3, 7, 9])
        }

        function zufall() {
            return getComputerInputRandom()
        }

        ueberpruefung = 0;
        if(f[4]=="_") {f[4]="O";} else {//3 in der Reihe für O:
        if(f[0]=="O"&&f[1]=="O"&&f[2]=="_") {f[2]="O";} else { //012
        if(f[1]=="O"&&f[2]=="O"&&f[0]=="_") {f[0]="O";} else {
        if(f[0]=="O"&&f[2]=="O"&&f[1]=="_") {f[1]="O";} else {
        if(f[3]=="O"&&f[4]=="O"&&f[5]=="_") {f[5]="O";} else { //345
        if(f[4]=="O"&&f[5]=="O"&&f[3]=="_") {f[3]="O";} else {
        if(f[5]=="O"&&f[3]=="O"&&f[4]=="_") {f[4]="O";} else {
        if(f[6]=="O"&&f[7]=="O"&&f[8]=="_") {f[8]="O";} else { //678
        if(f[7]=="O"&&f[8]=="O"&&f[6]=="_") {f[6]="O";} else {
        if(f[6]=="O"&&f[8]=="O"&&f[7]=="_") {f[7]="O";} else {
        if(f[0]=="O"&&f[3]=="O"&&f[6]=="_") {f[6]="O";} else { //036
        if(f[6]=="O"&&f[0]=="O"&&f[3]=="_") {f[3]="O";} else {
        if(f[6]=="O"&&f[3]=="O"&&f[0]=="_") {f[0]="O";} else {
        if(f[1]=="O"&&f[4]=="O"&&f[7]=="_") {f[7]="O";} else { //147
        if(f[4]=="O"&&f[7]=="O"&&f[1]=="_") {f[1]="O";} else {
        if(f[7]=="O"&&f[1]=="O"&&f[4]=="_") {f[4]="O";} else {
        if(f[8]=="O"&&f[5]=="O"&&f[2]=="_") {f[2]="O";} else { //258
        if(f[2]=="O"&&f[8]=="O"&&f[5]=="_") {f[5]="O";} else {
        if(f[2]=="O"&&f[5]=="O"&&f[8]=="_") {f[8]="O";} else {
        if(f[0]=="O"&&f[8]=="O"&&f[4]=="_") {f[4]="O";} else { //048
        if(f[4]=="O"&&f[8]=="O"&&f[0]=="_") {f[0]="O";} else {
        if(f[4]=="O"&&f[0]=="O"&&f[8]=="_") {f[8]="O";} else {
        if(f[4]=="O"&&f[2]=="O"&&f[6]=="_") {f[6]="O";} else { //246
        if(f[2]=="O"&&f[6]=="O"&&f[4]=="_") {f[4]="O";} else {
        if(f[6]=="O"&&f[4]=="O"&&f[2]=="_") {f[2]="O";} else {    //X aufhalten:
        if(f[0]=="X"&&f[1]=="X"&&f[2]=="_") {f[2]="O";} else { //012
        if(f[1]=="X"&&f[2]=="X"&&f[0]=="_") {f[0]="O";} else {
        if(f[0]=="X"&&f[2]=="X"&&f[1]=="_") {f[1]="O";} else {
        if(f[3]=="X"&&f[4]=="X"&&f[5]=="_") {f[5]="O";} else { //345
        if(f[4]=="X"&&f[5]=="X"&&f[3]=="_") {f[3]="O";} else {
        if(f[5]=="X"&&f[3]=="X"&&f[4]=="_") {f[4]="O";} else {
        if(f[6]=="X"&&f[7]=="X"&&f[8]=="_") {f[8]="O";} else { //678
        if(f[7]=="X"&&f[8]=="X"&&f[6]=="_") {f[6]="O";} else {
        if(f[6]=="X"&&f[8]=="X"&&f[7]=="_") {f[7]="O";} else {
        if(f[0]=="X"&&f[3]=="X"&&f[6]=="_") {f[6]="O";} else { //036
        if(f[6]=="X"&&f[0]=="X"&&f[3]=="_") {f[3]="O";} else {
        if(f[6]=="X"&&f[3]=="X"&&f[0]=="_") {f[0]="O";} else {
        if(f[1]=="X"&&f[4]=="X"&&f[7]=="_") {f[7]="O";} else { //147
        if(f[4]=="X"&&f[7]=="X"&&f[1]=="_") {f[1]="O";} else {
        if(f[7]=="X"&&f[1]=="X"&&f[4]=="_") {f[4]="O";} else {
        if(f[8]=="X"&&f[5]=="X"&&f[2]=="_") {f[2]="O";} else { //258
        if(f[2]=="X"&&f[8]=="X"&&f[5]=="_") {f[5]="O";} else {
        if(f[2]=="X"&&f[5]=="X"&&f[8]=="_") {f[8]="O";} else {
        if(f[0]=="X"&&f[8]=="X"&&f[4]=="_") {f[4]="O";} else { //048
        if(f[4]=="X"&&f[8]=="X"&&f[0]=="_") {f[0]="O";} else {
        if(f[4]=="X"&&f[0]=="X"&&f[8]=="_") {f[8]="O";} else {
        if(f[4]=="X"&&f[2]=="X"&&f[6]=="_") {f[6]="O";} else { //246
        if(f[2]=="X"&&f[6]=="X"&&f[4]=="_") {f[4]="O";} else {
        if(f[6]=="X"&&f[4]=="X"&&f[2]=="_") {f[2]="O";} else {    //Zwickmühlenverhinderung felder 0, 1 und 3 etc. (vorrausschauend):
        if(f[1]=="X"&&f[3]=="X"&&f[0]=="_"&&f[2]=="_"&&f[6]=="_") {f[0]="O";} else { //0
        if(f[1]=="X"&&f[6]=="X"&&f[0]=="_"&&f[2]=="_"&&f[3]=="_") {f[0]="O";} else {
        if(f[2]=="X"&&f[3]=="X"&&f[0]=="_"&&f[1]=="_"&&f[6]=="_") {f[0]="O";} else {
        if(f[1]=="X"&&f[5]=="X"&&f[2]=="_"&&f[0]=="_"&&f[8]=="_") {f[2]="O";} else { //2
        if(f[1]=="X"&&f[8]=="X"&&f[2]=="_"&&f[0]=="_"&&f[5]=="_") {f[2]="O";} else {
        if(f[0]=="X"&&f[5]=="X"&&f[2]=="_"&&f[8]=="_"&&f[1]=="_") {f[2]="O";} else {
        if(f[5]=="X"&&f[7]=="X"&&f[8]=="_"&&f[2]=="_"&&f[6]=="_") {f[8]="O";} else { //8
        if(f[2]=="X"&&f[7]=="X"&&f[8]=="_"&&f[6]=="_"&&f[5]=="_") {f[8]="O";} else {
        if(f[5]=="X"&&f[6]=="X"&&f[8]=="_"&&f[2]=="_"&&f[7]=="_") {f[8]="O";} else {
        if(f[3]=="X"&&f[7]=="X"&&f[6]=="_"&&f[0]=="_"&&f[8]=="_") {f[6]="O";} else { //6
        if(f[0]=="X"&&f[7]=="X"&&f[6]=="_"&&f[8]=="_"&&f[3]=="_") {f[6]="O";} else {
        if(f[3]=="X"&&f[8]=="X"&&f[6]=="_"&&f[0]=="_"&&f[7]=="_") {f[6]="O";} else {
        if(f[2]=="_"&&f[4]=="X"||f[6]=="_"&&f[4]=="X"||f[8]=="_"&&f[4]=="X"||f[0]=="_"&&f[4]=="X") {ecke(); ueberpruefung++;}
        if(f[4]!="_"&&ueberpruefung==0) {if(f[1]=="_"||f[5]=="_"||f[3]=="_"||f[7]=="_") {seite();}} else if(ueberpruefung==0) {zufall();}
        }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}

        for (let i = 0; i < 9; i++) {
            if (originalF[i] != f[i]) {
                return i + 1
            }
        }

        return getComputerInputRandom()
    }

    const bots = {
        "impossible": getComputerInputNormal,
        "easy": getComputerInputRandom
    }

    let getComputerInput = bots[args.d]

    if (getComputerInput == undefined) {
        terminal.printError(`Unknown difficulty: ${args.d}`)
        terminal.printLine("Available difficulties:")
        for (let difficulty of Object.keys(bots)) {
            terminal.print("- ")
            terminal.printCommand(difficulty, `tictactoe ${difficulty}`)
        }
        return
    }

    if (Math.random() < 0.5) {
        setField(getComputerInput(), O)
    }

    while (!isWon() && !isDraw()) {
        printField()
        setField(await getUserInput(), X)
        if (isWon() || isDraw())
            break
        setField(getComputerInput(), O)
        terminal.addLineBreak()
    }

    let winner = isWon()
    terminal.printLine("the game has ended...")
    await sleep(2000)
    printField()
    if (winner) {
        terminal.printLine(`${winner} has won!`)
    } else {
        terminal.printLine("It's a draw!")
    }

}, {
    description: "play a game of tic tac toe against the computer.",
    args: {
        "?d=difficulty": "play against an unbeatable computer."
    },
    standardVals: {
        d: "impossible"
    },
    isGame: true
})

// ------------------- js/commands/time.js --------------------
terminal.addCommand("time", async function(args) {
    const output = terminal.print("", undefined, {forceElement: true})
    output.style.fontSize = args.size + "em"
    output.style.paddingTop = "0.5em"
    output.style.paddingBottom = "0.5em"
    output.style.display = "inline-block"
    
    let startTime = 0
    if (args.start) {
        startTime = Date.now()
    }

    function makeTimeString() {
        let ms = Date.now() - startTime

        if (!args.start) {
            let offset = new Date().getTimezoneOffset()
            // offset is given in -minutes
            ms -= offset * 60 * 1000
        }

        const milliseconds = ms % 1000
        const seconds = Math.floor(ms / 1000) % 60
        const minutes = Math.floor(ms / 1000 / 60) % 60
        const hours = Math.floor(ms / 1000 / 60 / 60) % 24

        const p = (num, len=2) => {
            return num.toString().padStart(len, "0")
        }

        let str = ""
        if (!args['no-hours']) str += `${p(hours)}:`
        if (!args['no-minutes']) str += `${p(minutes)}:`
        if (!args['no-seconds']) str += `${p(seconds)}`
        if (args.m) str += `:${p(milliseconds, 3)}`

        if (str.endsWith(":")) {
            str = str.slice(0, -1) // remove trailing colon
        }

        if (str === "") {
            throw new Error("You disabled all time components!")
        }

        return str
    }

    let running = true

    function update() {
        output.textContent = makeTimeString()
        if (running)
            terminal.window.requestAnimationFrame(update)
    }

    update()

    terminal.onInterrupt(() => {
        running = false
    })

    output.textContent = makeTimeString()

    while (running) {
        await terminal.sleep(100)
    }

}, {
    description: "Shows the current time.",
    args: {
        "?no-hours:b": "Hide hours.",
        "?no-minutes:b": "Hide minutes.",
        "?no-seconds:b": "Hide seconds.",
        "?m=show-milli:b": "Show milliseconds.",
        "?f=size:n:0.1~99": "Font size in em.",
        "?s=start:b": "Start a stopwatch.",
    },
    defaultValues: {
        size: 3,
    }
})

// ------------------- js/commands/timer.js --------------------
terminal.addCommand("timer", async function(rawArgs) {
    let words = rawArgs.split(" ").filter(w => w.length > 0)
    let ms = 0
    for (let word of words) {
        if (/^[0-9]+s$/.test(word)) {
            ms += parseInt(word.slice(0, -1)) * 1000
        } else if (/^[0-9]+m$/.test(word)) {
            ms += parseInt(word.slice(0, -1)) * 60 * 1000
        } else if (/^[0-9]+h$/.test(word)) {
            ms += parseInt(word.slice(0, -1)) * 60 * 60 * 1000
        } else {
            throw new Error(`Invalid time '${word}'`)
        }
    }

    if (ms == 0) {
        terminal.printLine("An example time could be: '1h 30m 20s'")
        throw new Error("Invalid time!")
    }

    const progressBarWidth = 30

    class Timer {

        firstPrint() {
            terminal.printLine("+" + "-".repeat(progressBarWidth) + "+")
            terminal.print("|")
            this.progressOutput = terminal.print("", undefined, {forceElement: true})
            terminal.printLine("|")
            terminal.printLine("+" + "-".repeat(progressBarWidth) + "+")
            this.timeLeftOutput = terminal.print("", undefined, {forceElement: true})
            terminal.addLineBreak()
        }

        constructor() {
            this.progressOutput = null
            this.timeLeftOutput = null

            this.startTime = Date.now()
            this.endTime = this.startTime + ms
            this.firstPrint()
            this.running = true
            this.interval = setInterval(this.update.bind(this), 100)
        }

        update() {
            if (!this.running) return

            let timeLeft = this.endTime - Date.now()
            if (timeLeft <= 0) {
                this.stop()
            } else {
                let seconds = Math.floor(timeLeft / 1000) % 60
                let minutes = Math.floor(timeLeft / (60 * 1000)) % 60
                let hours = Math.floor(timeLeft / (60 * 60 * 1000))
                this.timeLeftOutput.textContent = `Time left: ${hours}h ${minutes}m ${seconds}s`
                let progressCount = Math.floor((progressBarWidth * (ms - timeLeft)) / ms)
                let percent = Math.floor((100 * (ms - timeLeft)) / ms)
                let progress = stringPadMiddle(`${percent}%`, progressCount, "=")
                this.progressOutput.textContent = stringPadBack(progress, progressBarWidth, " ")
            }
        }

        async alarm() {
            let frequencies = [523.25, 587.33, 659.25, 698.46, 783.99, 880, 987.77, 1046.5]
            let duration = 100

            for (let i = 0; i < 2; i++) {
                for (let freq of frequencies) {
                    await playFrequency(freq, duration)
                }

                for (let freq of frequencies.reverse()) {
                    await playFrequency(freq, duration)
                }
            }
        }

        stop() {
            if (!this.running) return
            clearInterval(this.interval)
            this.running = false
            this.alarm()
            this.timeLeftOutput.textContent = "Time's up!"
            this.progressOutput.textContent = stringPadMiddle("100%", progressBarWidth, "=")
        }

    }

    let timer = new Timer()

    while (timer.running) await sleep(100)

}, {
    description: "set a timer",
    rawArgMode: true
})



// ------------------- js/commands/todo.js --------------------
function fetchWithParam(url, params) {
    let query = Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join("&")
    return fetch(`${url}?${query}`)
}

class TodoApi {

    static GET_LIST_API = "https://www.noel-friedrich.de/todo/api/get-list.php"
    static ADD_ITEM_API = "https://www.noel-friedrich.de/todo/api/add-item.php"
    static EDIT_ITEM_API = "https://www.noel-friedrich.de/todo/api/edit-item.php"
    static DELETE_ITEM_API = "https://www.noel-friedrich.de/todo/api/delete-item.php"
    static CHECK_ITEM_API = "https://www.noel-friedrich.de/todo/api/check-item.php"

    static async getList(owner_name) {
        let response = await fetchWithParam(TodoApi.GET_LIST_API, {
            owner_name: owner_name
        })
        return await response.json()
    }
    
    static async addItem(owner_name, text_content, due_time="-") {
        return await fetchWithParam(TodoApi.ADD_ITEM_API, {
            owner_name: owner_name,
            text_content: text_content,
            due_time: due_time
        })
    }

    static async editItem(uid, text_content) {
        return await fetchWithParam(TodoApi.EDIT_ITEM_API, {
            uid: uid,
            text_content: text_content
        })
    }

    static async deleteItem(uid) {
        return await fetchWithParam(TodoApi.DELETE_ITEM_API, {uid: uid})
    }

    static async checkItem(item_uid, checked) {
        return await fetchWithParam(TodoApi.CHECK_ITEM_API, {
            item_uid: item_uid,
            check_val: checked ? 1 : 0
        })
    }

}

terminal.addCommand("todo", async function(args) {
    const getTodoItemChoice = async (headerText) => {
        return new Promise(async (resolve, reject) => {
            const elements = []
    
            const loadingElement = terminal.printLine("\nLoading...", undefined, {forceElement: true})
    
            try {
                let todos = await TodoApi.getList(args.name)

                if (args.u) {
                    todos = todos.filter(t => t.done == "0")
                }

                loadingElement.remove()
    
                if (todos.length == 0) {
                    throw new Error("Specified todo list is empty")
                }
    
                elements.push(terminal.printLine(headerText, Color.COLOR_1, {forceElement: true}))
                
                for (let todo of todos) {
                    let text = todo.done == "1" ? "[x]" : "[ ]"
                    text += " " + todo.text_content + (todo.due_time != "-" ? ` (${todo.due_time})` : "") + "\n"
                    elements.push(terminal.printClickable(text, () => {
                        for (let element of elements) {
                            element.remove()
                        }
                        resolve(todo)
                    }))
                }
            } catch (e) {
                loadingElement.remove()
                reject(e)
            }

            terminal.scroll()
        })
    }

    if (args["rm-completed"]) {
        await terminal.acceptPrompt(`Do you really want to delete all completed todos from "${args.name}"?`, false)
        const progressModule = await terminal.modules.load("progressbar", terminal)
        
        const todos = await TodoApi.getList(args.name)
        const completedTodos = todos.filter(t => t.done == "1")

        if (completedTodos.length == 0) {
            throw new Error(`Todo List "${args.name}" doesn't contain any completed todos`)
        }

        const progressBar = progressModule.printProgressBar({width: 62})

        for (let i = 0; i < completedTodos.length; i++) {
            await TodoApi.deleteItem(completedTodos[i].uid)
            progressBar.update(i / completedTodos.length)
        }

        progressBar.finish()
        terminal.printSuccess(`Successfully removed ${completedTodos.length} todos.`)
        return

    } else if (args["rm-item"]) {
        const choice = await getTodoItemChoice("Please choose an item to delete.")
        await TodoApi.deleteItem(choice.uid)

        terminal.printSuccess(`Successfully deleted item ("${choice.text_content}")`)
        return

    } else if (args["edit-item"]) {
        const choice = await getTodoItemChoice("Please choose an item to edit.")
        const newText = await terminal.prompt("Enter the new text: ")
        await TodoApi.editItem(choice.uid, newText)

        terminal.printSuccess(`Successfully edited item ("${choice.text_content}")`)
        return

    } else if (args["add-item"]) {
        const newText = await terminal.prompt("Enter the text: ")
        let dueDate = "-"
        try {
            await terminal.acceptPrompt("Do you want to add a due date?", false)
            dueDate = await terminal.prompt("Due Date: ")
        } catch {}
        await TodoApi.addItem(args.name, newText, dueDate)

        terminal.printSuccess(`Successfully added item to "${args.name}"`)
        return

    }

    const outputElement = terminal.print("", undefined, {forceElement: true})

    let updateCount = 0

    const updateOutput = async () => {
        const currUpdate = ++ updateCount
        terminal.printLine("\nLoading...", undefined, {outputNode: outputElement})

        try {
            let todos = await TodoApi.getList(args.name)

            if (args.u) {
                todos = todos.filter(t => t.done == "0")
            }

            outputElement.innerHTML = "<br>"
            
            for (let todo of todos) {
                terminal.printClickable(todo.done == "1" ? "[x]" : "[ ]", async () => {
                    if (currUpdate != updateCount) return
                    await TodoApi.checkItem(todo.uid, todo.done != "1")
                    updateOutput()
                }, Color.COLOR_1, {outputNode: outputElement})

                const text = " " + todo.text_content + (todo.due_time != "-" ? ` (${todo.due_time})` : "")
                terminal.printLine(text, undefined, {outputNode: outputElement})
            }

            if (todos.length == 0) {
                const text = `< no todo items found >`
                terminal.printLine(text, undefined, {outputNode: outputElement})
            }

            terminal.printLine("", undefined, {outputNode: outputElement})
            terminal.printClickable("[Reload] ", () => {
                updateOutput()
            }, undefined, {outputNode: outputElement})
            terminal.printCommand("[Add Item] ", `todo ${args.name} --add-item`,
                undefined, false, {outputNode: outputElement})
            terminal.printCommand("[Remove Item] ", `todo ${args.name} --rm-item`,
                undefined, false, {outputNode: outputElement})
            terminal.printCommand("[Edit Item] ", `todo ${args.name} --edit-item`,
                undefined, false, {outputNode: outputElement})
            terminal.printLine("", undefined, {outputNode: outputElement})
        } catch (e) {
            console.error(e)
            outputElement.innerHTML = "<br>"
            terminal.printError(e.message, "Unexpected Error", {outputNode: outputElement})
        }

        outputElement
    }

    updateOutput()
}, {
    description: "show and manage a todo list",
    args: {
        "n=name:s": "name of the the todo list",
        "?u=uncompleted-only:b": "only show the uncompleted todos",
        "?a=add-item:b": "add an item to the todo list",
        "?r=rm-item:b": "remove an item from the todo list",
        "?e=edit-item:b": "edit an item of the todo list",
        "?rm-completed:b": "remove all completed todos from the todo list"
    }
})

// ------------------- js/commands/touch.js --------------------
terminal.addCommand("touch", async function(args) {
    if (!terminal.isValidFileName(args.filename))
        throw new Error("Invalid filename")
    if (terminal.fileExists(args.filename))
        throw new Error("File already exists")

    const file = new PlainTextFile().setName(args.filename)
    terminal.currDirectory.addChild(file)
}, {
    description: "create a file in the current directory",
    args: {
        "filename:s": "the name of the file"
    }
})



// ------------------- js/commands/turing.js --------------------
class TuringError {

    constructor(message, lineNum, lineContent) {
        this.message = message
        this.lineNum = lineNum
        this.lineContent = lineContent
    }

    print() {
        terminal.printError(this.message)
        if (this.lineContent !== undefined) {
            terminal.printLine(`  > ${this.lineContent}`)
            if (this.lineNum !== undefined)
                terminal.printLine(`    on line #${this.lineNum}`)
        }
    }

}

class TuringInstruction {

    constructor(state, content, newContent, direction, newState) {
        this.state = state
        this.content = content
        this.newContent = newContent
        this.direction = direction
        this.newState = newState
    }
    
    exportLinear() {
		return [
			this.newContent,
			this.direction,
			this.newState
		]
	}

}

class TuringMachine {

    error(message, lineNum, lineContent) {
        this.errors.push(new TuringError(message, lineNum, lineContent))
    }

    parseCode(code) {
        const removeComments = code => code.split("\n")
            .map(line => line
                .trim()
                .split(";")[0]
                .split("//")[0]
            )
            .join("\n")

        code = removeComments(code)

        let lineNum = 0
        for (let line of code.split("\n")) {
            lineNum++

            if (line.length === 0) continue

            let parts = line.split(" ").map(p => p.trim()).filter(p => p.length > 0)
            if (parts.length !== 5) {
                this.error("Invalid Number of Instructions", lineNum, line)
                continue
            }

            let [
                state,
                content,
                newContent,
                direction,
                newState
            ] = parts

            this.states.add(state)
            this.states.add(newState)
            this.alphabet.add(content)
            this.alphabet.add(newContent)

            if (!direction.match(/^(left|right|l|r|L|R|\*)$/)) {
                this.error("Invalid Direction", lineNum, line)
                continue
            } else if (direction === "l" || direction === "L" || direction === "left") {
                direction = -1
            } else if (direction === "r" || direction === "R" || direction === "right") {
                direction = 1
            } else if (direction === "*") {
                direction = 0
            }

            if (!this.instructions[state]) this.instructions[state] = {}

            if (newContent == "*") newContent = content
            if (newState == "*") newState = state

            this.instructions[state.toString()][content.toString()] = new TuringInstruction(
                state, content, newContent, direction, newState
            )

        }

    }
    
    exportInstructionsLinear() {
		let result = {}
		for (let [key1, tempVal1] of Object.entries(this.instructions)) {
			let tempResult = {}
			for (let [key2, tempVal2] of Object.entries(tempVal1)) {
				tempResult[key2] = tempVal2.exportLinear()
			}
			result[key1] = tempResult
		}
		return JSON.stringify(result)
	}

    constructor(code, {
        startState="0",
        startTapeContent="",
        standardTapeContent="_",
        maxSteps=100000
    }={}) {
        this.standardTapeContent = standardTapeContent
        this.tape = Array.from(startTapeContent) || []
        this.state = startState
        this.tapeIndex = 0
        this.errors = []
        this.states = new Set()
        this.alphabet = new Set()
        this.instructions = {}
        this.actualTapeIndex = 0
        this.stepCount = 0
        this.maxSteps = maxSteps
        this.parseCode(code)
    }

    get tapeContent() {
        return this.tape[this.tapeIndex]
    }

    set tapeContent(content) {
        this.tape[this.tapeIndex] = content
    }

    moveTape(direction) {
        if (direction === 0) return
        this.tapeIndex += direction
        this.actualTapeIndex += direction
        if (this.tapeIndex < 0) {
            this.tape.unshift(this.standardTapeContent)
            this.tapeIndex = 0
        } else if (this.tapeIndex >= this.tape.length) {
            this.tape.push(this.standardTapeContent)
        }

        while (this.tape[0] === this.standardTapeContent
        && this.tapeIndex > 0) {
            this.tape.shift()
            this.tapeIndex--
        }

        while (this.tape[this.tape.length - 1] === this.standardTapeContent
        && this.tapeIndex < this.tape.length - 1) {
            this.tape.pop()
        }
    }

    firstDraw() {
        terminal.print("[")
        this.tapeOut = terminal.print("", undefined, {forceElement: true})
        terminal.printLine("]")
        terminal.print(" ")
        this.pointerOut = terminal.print("", undefined, {forceElement: true})
        terminal.printLine(" ")
        terminal.print("Current State: ")
        this.stateOut = terminal.print("", undefined, {forceElement: true})
        terminal.addLineBreak()
        terminal.print("Current Index: ")
        this.indexOut = terminal.print("", undefined, {forceElement: true})
        terminal.addLineBreak()
        this.draw()
    }
    
    compile(maxTapeSize=10000) {
		let code = ""
		let startIndex = ~~(maxTapeSize/2)
		const writeLine = l => code += l + "\n"
		writeLine(`onmessage = () => {`)
		writeLine(`  const states = ${this.exportInstructionsLinear()};`)
		writeLine(`  let index = ${startIndex};`)
		writeLine(`  let tape = Array.from(Array(${maxTapeSize})).fill("${this.standardTapeContent}");`)
		for (let i = 0; i < this.tape.length; i++) {
			let tapeContent = this.tape[i]
			writeLine(`  tape[${startIndex + i}] = "${tapeContent}";`)
		}
		writeLine(`  let state = "${this.state}";`)
        writeLine(`  let i = 0;`)
        writeLine(`  let start = performance.now();`)
		writeLine(`  for (;; i++) {`)
		writeLine(`     const instructs = states[state];`)
		writeLine(`     if (!instructs) break;`)
		writeLine(`     let instruction = instructs[tape[index]] ?? instructs["*"];`)
		writeLine(`     if (!instruction) break;`)
		writeLine(`     if (instruction[0] != "*")`)
		writeLine(`       tape[index] = instruction[0];`)
		writeLine(`     index += instruction[1];`)
		writeLine(`     state = instruction[2];`)
		writeLine(`     if (i >= ${this.maxSteps}) break;`)
		writeLine(`  }`)
        writeLine(`  let ms = performance.now() - start;`)
		writeLine(`  const output = tape.filter(t => t != "${this.standardTapeContent}").join("");`)
		writeLine(`  postMessage([output, state, i, ms]);`)
		writeLine(`}`)
		return code
	}
	
	async executeCompiled(code) {
		const blob = new Blob([code], {type: 'application/javascript'})
		let worker = new Worker(URL.createObjectURL(blob))
		let running = true
		worker.onmessage = e => {
            let [output, state, steps, ms] = e.data
            terminal.printLine(`Finished ${steps} steps in ${ms.toFixed(2)}ms.`)
			terminal.printLine(`\nTerminal Tape Content (length=${output.length}):\n${output}`)
            terminal.printLine(`\nTerminal State: ${state}`)
			worker.terminate()
			running = false
		}
		worker.postMessage("")
		let i = 0
		while (running) {
			i++
			if (i == 10) {
				terminal.printLine("This may take a bit...")
			}
			await sleep(100)
		}
	}

    draw() {
        this.tapeOut.textContent = this.tape.join("")
        this.pointerOut.textContent = " ".repeat(this.tapeIndex) + "^"
        this.stateOut.textContent = this.state
        this.indexOut.textContent = this.actualTapeIndex
    }

    step() {
        this.stepCount++

        let possibleInstructions = this.instructions[this.state]
        if (!possibleInstructions) {
            return false
        }
        let instruction = possibleInstructions[this.tapeContent]
        if (!instruction) {
            instruction = possibleInstructions["*"]
        }
        if (!instruction) {
            return false
        }

        if (this.stepCount > this.maxSteps) {
            this.error("Max Steps Reached")
            return false
        }

        if (instruction.newContent !== "*")
            this.tapeContent = instruction.newContent
        this.state = instruction.newState
        this.moveTape(instruction.direction)

        return true
    }

}

terminal.addCommand("turing", async function(args) {

    const file = terminal.getFile(args.file)
    const machine = new TuringMachine(file.content, {
        startTapeContent: args.startTape,
        startState: args.startingState,
        maxSteps: args.maxSteps
    })
    
    if (machine.errors.length > 0) {
        machine.errors[0].print()
        return
    }

    terminal.machine = machine
    
    if (args.turbo) {
		let compiledJS = machine.compile(args.turboTapeSize)
		await machine.executeCompiled(compiledJS)
		return
	}

    machine.firstDraw()
	terminal.scroll()
    while (true) {
        await terminal.sleep(args.s)
        if (!machine.step()) {
            if (machine.errors.length > 0)
                machine.errors[0].print()
            break
        }
        machine.draw()
    }
    machine.draw()
    
}, {
    description: "run a turing machine file",
    args: {
        "file:f": "file to run",
        "?t=startTape:s": "starting tape content",
        "?s=sleep:i:0~10000": "sleep time between steps (in ms)",
        "?d=startingState:s": "starting state",
        "?m=maxSteps:i:0~9999999999": "maximum number of steps to run",
        "?p=turboTapeSize:i:0~9999999999": "size of turing machine tape",
        "?turbo:b": "run as fast as possible",
    },
    standardVals: {
        startTape: "",
        sleep: 100,
        startingState: "0",
        maxSteps: 100000,
        turboTapeSize: 10000,
    }
})


// ------------------- js/commands/turtlo.js --------------------
terminal.addCommand("turtlo", async function(args) {
    await terminal.modules.load("turtlo", terminal)
    terminal.modules.turtlo.spawn({size: args.size, silent: args.silent})
}, {
    description: "spawn turtlo",
    args: {
        "?size:i:1~3": "size of turtlo",
        "?silent:b": "don't print anything"
    },
    defaultValues: {
        size: 1
    }
})

// ------------------- js/commands/type-test.js --------------------
// 1000 words randomly chosen from a list of 10000 most common english words
// source: https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english.txt
var englishWords = [
    "spokesman", "slots", "man", "targets", "plymouth", "sec", "reflects", "constitutional", "hereby", "progressive", "rss", 
    "authors", "secrets", "basically", "wild", "beautiful", "theatre", "cry", "vhs", "fraction", "breakfast", "meal", "far", 
    "out", "glow", "literally", "specialist", "touch", "coastal", "ala", "ingredients", "medal", "adsl", "extract", "corresponding", 
    "twelve", "wizard", "micro", "cartoon", "steering", "moved", "inspection", "jul", "jpeg", "cet", "christopher", "index", 
    "value", "initially", "motivated", "threads", "friends", "worldwide", "frontier", "intense", "exp", "proprietary", "loaded", 
    "otherwise", "spider", "civilian", "detect", "tulsa", "closely", "trick", "expenditure", "responses", "deleted", "pubmed", 
    "listening", "thrown", "rosa", "relief", "magical", "thickness", "zone", "prot", "lectures", "prove", "published", "crap", 
    "allah", "dimensions", "panties", "perl", "ricky", "front", "tradition", "favourites", "naples", "sleep", "anime", "litigation", 
    "gdp", "introduces", "classical", "ntsc", "breeds", "city", "casey", "printable", "radar", "spend", "signed", "claimed", 
    "louisville", "anymore", "accident", "which", "crossword", "evening", "iran", "matters", "justice", "sarah", "textbook", 
    "silly", "follows", "iraqi", "butts", "discrete", "pod", "afraid", "error", "homeless", "tracker", "optimize", "infected", 
    "side", "adobe", "nice", "knock", "clinic", "diana", "reputation", "representation", "lyric", "compensation", "std", 
    "uploaded", "possess", "balls", "bon", "until", "info", "legs", "section", "lodging", "gallery", "allows", "attachments", 
    "mini", "mighty", "characterized", "mit", "restore", "swiss", "profiles", "herald", "henderson", "bedford", "peru", "jerry", 
    "movements", "condos", "asn", "annotation", "expand", "electron", "photoshop", "inquire", "anybody", "clip", "formed", 
    "processes", "casa", "cassette", "part", "inch", "difference", "dump", "carter", "knows", "undertake", "twisted", "were", 
    "rover", "versions", "farmers", "cartridges", "permit", "wolf", "decimal", "millions", "republic", "promotions", "photographers", 
    "unlock", "mono", "deck", "boots", "repair", "varieties", "sophisticated", "impacts", "liberal", "investment", "training", 
    "republicans", "fifth", "actor", "skating", "acts", "operated", "clear", "swaziland", "dylan", "nation", "aud", "bizrate", 
    "harm", "approaches", "martin", "confused", "pharmaceutical", "viking", "tunisia", "howto", "viagra", "conceptual", "downtown", 
    "geek", "fell", "observations", "managed", "select", "outer", "calculator", "barriers", "attributes", "rules", "spy", 
    "close", "foul", "wheels", "warrior", "bandwidth", "compressed", "bond", "creature", "minor", "mysql", "tuition", "invitations", 
    "elsewhere", "girls", "identical", "captured", "corporation", "ellis", "fifteen", "cds", "culture", "teeth", "frozen", 
    "rugs", "explained", "pop", "deutsch", "replace", "regulation", "against", "prominent", "higher", "arena", "commonly", 
    "int", "sucks", "equations", "enjoying", "marcus", "assembled", "denmark", "edinburgh", "purchasing", "printer", "puts", 
    "delivered", "oaks", "implement", "controller", "pets", "numerous", "celebs", "actors", "lottery", "biographies", "surprising", 
    "situated", "design", "penalties", "sheer", "insert", "craps", "report", "endorsement", "manage", "award", "medicines", 
    "degree", "farm", "skin", "tongue", "flight", "upload", "jessica", "portuguese", "activities", "bound", "mongolia", "internship", 
    "three", "boys", "spray", "tests", "ppc", "shades", "consequence", "institute", "wang", "poly", "pins", "notion", "ever", 
    "starting", "yea", "somehow", "visibility", "surplus", "seeing", "noble", "andrea", "applied", "mpg", "ear", "normal", 
    "victoria", "necessity", "never", "juvenile", "bhutan", "techniques", "temple", "qualification", "trial", "carolina", 
    "potential", "diagnosis", "butter", "ant", "belt", "titles", "consideration", "unexpected", "evanescence", "sunrise", 
    "gone", "opportunity", "resort", "occurrence", "dictionaries", "amp", "commissioners", "atlantic", "von", "scanner", 
    "worn", "hollywood", "corporations", "documentary", "shift", "ambien", "hobby", "organisations", "poet", "oliver", "weekly", 
    "dover", "eddie", "particular", "mark", "permitted", "wallpaper", "output", "wage", "donna", "hammer", "spirit", "university", 
    "licensed", "girl", "thumbzilla", "navy", "blogger", "poem", "descending", "powder", "cad", "website", "graphical", "root", 
    "needed", "printed", "recreational", "ordered", "mounting", "arcade", "dictionary", "lately", "computer", "responded", 
    "much", "saves", "street", "modified", "pretty", "denied", "happy", "pose", "mice", "desert", "package", "rewards", "than", 
    "pickup", "instantly", "relatives", "flooring", "better", "cycle", "indie", "leg", "health", "magnificent", "hacker", 
    "databases", "classics", "translator", "ian", "shine", "assignment", "verify", "chevrolet", "vendors", "applicants", 
    "legislation", "prozac", "beta", "blend", "soup", "perfect", "midwest", "matter", "kathy", "snake", "treo", "features", 
    "howard", "discounted", "probably", "patient", "polyphonic", "shoot", "ram", "thousands", "couples", "gabriel", "dense", 
    "plugins", "alumni", "terrorism", "parental", "deer", "build", "counted", "tokyo", "taylor", "promotion", "sensitive", 
    "improved", "ultimate", "alloy", "scroll", "iceland", "knife", "featuring", "nodes", "helmet", "maintained", "male", 
    "adults", "logical", "kenneth", "sticker", "band", "sciences", "mild", "holders", "stable", "singapore", "recipients", 
    "rolling", "ranked", "wheat", "main", "slovenia", "severe", "handles", "forecasts", "stephen", "fabric", "presence", 
    "mediawiki", "slope", "situations", "displays", "api", "sympathy", "manga", "straight", "obtaining", "preferred", "locking", 
    "performance", "guarantees", "approval", "davis", "activation", "calcium", "coal", "raises", "sql", "characteristics", 
    "behavioral", "sri", "reached", "takes", "reflect", "linear", "poverty", "canvas", "controversial", "drink", "cashiers", 
    "meals", "enables", "shortcuts", "budgets", "articles", "altered", "valve", "sex", "accessories", "advice", "countries", 
    "indicators", "unfortunately", "budapest", "vacancies", "argue", "den", "potter", "victor", "able", "dealtime", "idle", 
    "tax", "lucky", "reservations", "along", "spouse", "funding", "pre", "wound", "job", "exploring", "threatening", "ceo", 
    "scores", "stages", "combinations", "would", "dayton", "satisfied", "seemed", "gratuit", "miracle", "poor", "abortion", 
    "interaction", "developer", "original", "vbulletin", "trail", "wait", "lawyer", "pressure", "hint", "estimates", "arranged", 
    "bye", "sim", "therapy", "commercial", "ghost", "withdrawal", "finishing", "whereas", "vocal", "began", "shape", "language", 
    "forty", "told", "thinks", "rent", "patents", "chem", "asset", "officials", "drove", "deutsche", "central", "bargain", 
    "arbitration", "pull", "females", "ball", "chi", "compact", "path", "disorder", "revolution", "marie", "cemetery", "earliest", 
    "direction", "slide", "books", "consequently", "gourmet", "sports", "bite", "material", "nickname", "verzeichnis", "interim", 
    "burning", "caroline", "titten", "addition", "juice", "oscar", "measures", "pharmacology", "assumes", "professor", "adjustments", 
    "yeast", "monte", "magazines", "blessed", "partially", "whole", "reform", "distinction", "annex", "arm", "usage", "sen", 
    "buried", "stuffed", "continues", "game", "inf", "minimum", "inquiry", "visits", "kim", "campaigns", "album", "teen", 
    "ethical", "sic", "architecture", "judge", "nursery", "half", "textile", "mambo", "politicians", "offline", "you", "consistency", 
    "refused", "crimes", "cruz", "maintains", "prepare", "beatles", "manor", "things", "standard", "adaptation", "cons", 
    "market", "crops", "chuck", "configure", "scheme", "platforms", "obvious", "atm", "wants", "guides", "statewide", "goods", 
    "supported", "tennessee", "chaos", "zum", "rights", "hamburg", "bachelor", "infant", "take", "espn", "died", "decision", 
    "importantly", "defining", "wallpapers", "prep", "sept", "sapphire", "careful", "albany", "holly", "liberty", "appropriations", 
    "depends", "heavily", "shemales", "undergraduate", "relaxation", "injury", "placement", "stress", "day", "recipient", 
    "achieving", "header", "explanation", "figures", "grove", "amd", "currently", "grenada", "congo", "immigrants", "newark", 
    "strings", "protein", "xerox", "lung", "spending", "donation", "inter", "belly", "product", "tent", "instead", 
    "css", "fuzzy", "observed", "leasing", "several", "moldova", "remove", "complaint", "correct", "accountability", "bolt", 
    "second", "serial", "wrapped", "screw", "sake", "tasks", "recommend", "spring", "bad", "grants", "ken", "illustration", 
    "upgrades", "chronicles", "agencies", "missile", "limits", "varying", "laundry", "emission", "bow", "honey", "expenditures", 
    "library", "xxx", "merit", "selections", "wearing", "differently", "forests", "pounds", "restrict", "containing", "apnic", 
    "florence", "other", "ddr", "interracial", "initiated", "ins", "units", "attempt", "ran", "railroad", "appearance", "over", 
    "trials", "paint", "performs", "deborah", "tears", "merely", "none", "realtors", "ryan", "gpl", "def", "queens", "jewish", 
    "receive", "cables", "tuner", "intelligent", "louis", "beds", "restricted", "gangbang", "earth", "internet", "best", 
    "master", "screensavers", "continuity", "swift", "luis", "iso", "shall", "jane", "fool", "posts", "different", "teacher", 
    "manual", "scholarships", "mad", "clearing", "improvements", "lancaster", "federation", "nut", "ceiling", "furnishings", 
    "twice", "concepts", "francis", "give", "licenses", "down", "context", "scored", "deficit", "dos", "demands", "spam", 
    "tom", "suggest", "bind", "rich", "perspective", "thanksgiving", "dave", "metallica", "greece", "translation", "adventure", 
    "rail", "plaza", "stability", "chart", "paperback", "component", "abuse", "tel", "daniel", "backing", "feelings", "rid", 
    "skills", "reed", "filled", "voyeurweb", "proceeds", "ministries", "delivering", "departments", "deployment", "framing", 
    "pan", "contacting", "shakespeare", "retained", "remedy", "answer", "denial", "events", "opens", "integral", "tried", 
    "recorded", "fallen", "accurately", "coupons", "sending", "levy", "hot", "ppm", "commands", "hosts", "wireless", "above", 
    "thriller", "off", "forecast", "fundamental", "thanks", "harbor", "dark", "manner", "usb", "instance", "imagine", "bridge", 
    "tigers", "cigarettes", "deviant", "include", "fame", "qualifying", "distant", "minds", "trainer", "wonderful", "involving", 
    "visit", "chorus", "prediction", "associate", "threats", "contributor", "restaurant", "strategies", "postage", "sounds", 
    "watching", "die", "demonstrated", "florist", "transition", "greatest", "harper", "oem", "postal", "format", "playstation", 
    "blowing", "graphs"
]

terminal.addCommand("type-test", async function(args) {
    await terminal.modules.import("game", window)

    let chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ "
    
    function generateText(length) {
        let chosenWords = []
        let chosenWordChars = 0
        while (chosenWordChars < length) {
            let word = englishWords[Math.floor(Math.random() * englishWords.length)]
            if (chosenWords.includes(word)) {
                continue
            }
            chosenWords.push(word)
            chosenWordChars += word.length
        }

        return chosenWords.join(" ").slice(0, length).toUpperCase()
    }
    
    terminal.addLineBreak()
    
    let text = generateText(60)
    let typeIndex = -1
    let charElements = []
    for (let char of text) {
        let element = terminal.print(char, undefined, {forceElement: true})
        element.style.fontSize = "2em"
        charElements.push(element)
        if (charElements.length % 30 == 0) {
            terminal.addLineBreak()
        }
    }
    
    terminal.addLineBreak()
    let outputLine = terminal.printLine("Start the text by typing the highlighted character!")
    
    let ended = false
    let startTime = null
    let started = false
    let correctCount = 0
    
    function endTypeTest() {
        ended = true
    }
    
    function advanceCharIndex(success) {
        if (typeIndex == 0) {
            startTime = Date.now()
            started = true
        }
        let prevCharElement = charElements[typeIndex]
        let nextCharElement = charElements[typeIndex + 1]
        if (prevCharElement && success) {
            prevCharElement.style.color = "lightgreen"
            prevCharElement.style.backgroundColor = "transparent"
            correctCount++
        } else if (prevCharElement && !success) {
            prevCharElement.style.color = "red"
            prevCharElement.style.backgroundColor = "transparent"
            correctCount = Math.max(correctCount - 1, 0)
        }
        if (!nextCharElement) {
            endTypeTest()
        } else {
            nextCharElement.style.backgroundColor = "white"
            nextCharElement.style.color = "black"
        }
        typeIndex++
    }
    
    advanceCharIndex(false)
    
    let listener = addEventListener("keydown", event => {
        if (ended) return
        let upperKey = event.key.toUpperCase()
        if (event.key == "c" && event.ctrlKey) {
            removeEventListener("keydown", listener)
            ended = true
        } else if (chars.includes(upperKey)) {
            let success = upperKey == text[typeIndex]
            advanceCharIndex(success)
        }
    })

    if (terminal.mobileKeyboard) {
        terminal.mobileKeyboard.updateLayout([
            ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
            ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
            ["Z", "X", "C", "V", "B", "N", "M"],
            ["Space"],
            ["STRG+C"]
        ])

        terminal.mobileKeyboard.onkeydown = (e, key) => {
            let upperKey = key.toUpperCase()
            if (upperKey == "SPACE") upperKey = " "
            if (chars.includes(upperKey)) {
                let success = upperKey == text[typeIndex]
                advanceCharIndex(success)
            }
        }
    }
    
    let seconds = 0
    let cpm = 0
    
    function updateDisplays() {
        seconds = Math.floor((Date.now() - startTime) / 100) / 10
        cpm = Math.ceil(correctCount / (seconds / 60))
        outputLine.textContent = `seconds: ${seconds}, cpm=${cpm}`
    }
    
    terminal.scroll()
    
    while (!ended) {
        await sleep(50)
        if (started)
            updateDisplays()
    }
    
    removeEventListener("keydown", listener)
    
    terminal.printLine("FINISHED!")
    terminal.printLine(`You took ${seconds} seconds for ${correctCount} chars.`)
    terminal.printLine(`That evaluates to a score of ${cpm} cpm!`)
    
    await HighscoreApi.registerProcess("type-test")
    await HighscoreApi.uploadScore(cpm)
    
}, {
    description: "test your typing speed",
    isGame: true
})

// ------------------- js/commands/uname.js --------------------
terminal.addCommand("uname", function() {
    terminal.printLine("NOELOS OS 1.0.5")
}, {
    description: "print the operating system name"
})



// ------------------- js/commands/unit.js --------------------
terminal.addCommand("unit", async function(args) {
    const unitData = {
        "distance": [
            {names: ["m", "meter", "meters"], factor: 1},
            {names: ["km", "klick", "klicks", "kilometer", "kilometers"], factor: 1e3},
            {names: ["cm", "centimeter", "centimeters"], factor: 1e-2},
            {names: ["mm", "millimeter", "millimeter"], factor: 1e-3},
            {names: ["micrometer", "micrometers", "micro-meter", "micro-meters"], factor: 1e-6},
            {names: ["nm", "nanometer", "nanometers"], factor: 1e-9},
            {names: ["mi", "mile", "miles"], factor: 1609.344},
            {names: ["yd", "yard", "yards"], factor: 0.9144},
            {names: ["ft", "foot", "feet"], factor: 0.3048},
            {names: ['"', "in", "inch", "inches"], factor: 0.0254},
            {names: ["nmi", "nautical-mile", "nautical-miles"], factor: 1852},
            {names: ["ly", "light-year", "light-y", "light-years"], factor: 9_460_730_472_580.8e3},
            {names: ["h", "hand", "hands"], factor: 0.1016},
            {names: ["lns", "light-ns", "light-nanosecond", "light-nanoseconds"], factor: 0.299792458},
            {names: ["sf", "soccer-field", "soccer-fields", "football-field", "football-fields"], factor: 105},
            {names: ["asf", "american-football-field", "american-football-fields"], factor: 91.44},
            {names: ["er", "earth-radius", "earth-radii"], factor: 6378e3}, // surprisingly hard to approximate!
            {names: ["cu", "cubit", "cubits"], factor: 0.5}, // approximation
            {names: ["p", "palm", "palms"], factor: 0.075}, // ancient egypt hand size (https://en.wikipedia.org/wiki/Palm_(unit))
            {names: ["lk", "lks", "look", "looks"], factor: 100_000} // number of looks from a helicopter 1km high (50km in each direction)
        ],
        
        "area": [
            {names: ["sm", "qm", "m2", "square-meter", "square-meters"], factor: 1},
            {names: ["skm", "qkm", "km2", "square-kilometer", "square-kilometers"], factor: 1e6},
            {names: ["scm", "qcm", "cm2", "square-centimeter", "square-centimeters"], factor: 1e-4},
            {names: ["smm", "qmm", "mm2", "square-millimeter", "square-millimeters"], factor: 1e-6},
            {names: ["ha", "hectare", "hectares"], factor: 1e4},
            {names: ["ac", "acre", "acres"], factor: 4046.86},
            {names: ["sqmi", "square-mile", "square-miles"], factor: 2.58999e6},
            {names: ["sqyd", "square-yard", "square-yards"], factor: 0.836127},
            {names: ["sqft", "square-foot", "square-feet"], factor: 0.092903},
            {names: ["sqin", "square-inch", "square-inches"], factor: 0.00064516},
            {names: ["sqnmi", "square-nautical-mile", "square-nautical-miles"], factor: 3.4299e6},
            {names: ["sqkm", "square-kilometer", "square-kilometers"], factor: 1e6},
            {names: ["sqrd", "rood", "roods"], factor: 1011.71}, // historical unit
            {names: ["sqch", "square-chain", "square-chains"], factor: 404.686}, // historical unit
            {names: ["sqrdm", "square-rod", "square-rods"], factor: 25.2929}, // historical unit
            {names: ["sqperch", "square-perch", "square-perches"], factor: 25.2929}, // historical unit
            {names: ["sqftus", "square-foot-US-Survey", "square-feet-US-Survey"], factor: 0.0929034116}, // US Survey
            {names: ["sqmilesus", "square-mile-US-Survey", "square-miles-US-Survey"], factor: 2.5899881103e6} // US Survey
        ],

        "mass": [
            {names: ["g", "gram", "grams"], factor: 1},
            {names: ["kg", "kilogram", "kilograms"], factor: 1e3},
            {names: ["mg", "milligram", "milligrams"], factor: 1e-3},
            {names: ["μg", "microgram", "micrograms"], factor: 1e-6},
            {names: ["tonne", "metric-ton", "metric-tons"], factor: 1e6},
            {names: ["lb", "pound", "pounds"], factor: 453.592},
            {names: ["oz", "ounce", "ounces"], factor: 28.3495},
            {names: ["ct", "carat", "carats"], factor: 0.2},
            {names: ["st", "stone", "stones"], factor: 6350.29},
            {names: ["gr", "grain", "grains"], factor: 0.0647989},
            {names: ["cwt", "hundredweight", "hundredweights"], factor: 50802.3},
            {names: ["troy-oz", "troy-ounce", "troy-ounces"], factor: 31.1035}, // Precious metals
            {names: ["troy-lb", "troy-pound", "troy-pounds"], factor: 373.242}, // Precious metals
            {names: ["dalton", "atomic-mass-unit", "atomic-mass-units"], factor: 1.66053904e-27} // Atomic and molecular masses
        ],

        "temperature": [
            {names: ["c", "celsius"], factor: 1},
            {names: ["f", "fahrenheit"], to: x => (x - 32) * 5/9, from: x => x * 9/5 + 32},
            {names: ["k", "kelvin"], to: x => x + 273.15, from: x => x - 273.15},
            {names: ["r", "rankine"], to: x => (x - 491.67) * 5/9, from: x => x * 9/5 + 491.67},
            {names: ["d", "delisle"], to: x => 100 - x * 2/3, from: x => (100 - x) * 3/2},
            {names: ["réaumur", "reaumur"], to: x => x * 5/4, from: x => x * 4/5},
            {names: ["rømer", "romer"], to: x => (x - 7.5) * 40/21, from: x => x * 21/40 + 7.5}
        ],

        "speed": [
            {names: ["m/s", "mps", "meter-per-second", "meters-per-second"], factor: 1},
            {names: ["km/h", "kmh", "kph", "kilometer-per-hour", "kilometers-per-hour"], factor: 1 / 3.6},
            {names: ["mi/h", "mph", "mile-per-hour", "miles-per-hour"], factor: 0.447},
            {names: ["ft/s", "fps", "foot-per-second", "feet-per-second"], factor: 0.3048},
            {names: ["knot", "knots"], factor: 0.51444446046222225277},
            {names: ["mach", "machs"], factor: 340.29},
            {names: ["min/km", "minutes-per-kilometer"], to: x => (50/3) / x, from: x => (50/3) / x}
        ],

        "volume": [
            {names: ["m3", "cubic-meter", "cubic-meters"], factor: 1},
            {names: ["km3", "cubic-kilometer", "cubic-kilometers"], factor: 1e9},
            {names: ["cm3", "cubic-centimeter", "cubic-centimeters"], factor: 1e-6},
            {names: ["mm3", "cubic-millimeter", "cubic-millimeters"], factor: 1e-9},
            {names: ["litre", "liter", "liters", "litres"], factor: 1e-3},
            {names: ["ml", "milliliter", "milliliters"], factor: 1e-6},
            {names: ["gal", "gallon", "gallons"], factor: 3.78541},
            {names: ["qt", "quart", "quarts"], factor: 0.946353},
            {names: ["pt", "pint", "pints"], factor: 0.473176},
            {names: ["cup", "cups"], factor: 0.236588},
            {names: ["fl-oz", "fluid-ounce", "fluid-ounces"], factor: 0.0295735},
            {names: ["tbsp", "tablespoon", "tablespoons"], factor: 0.0147868},
            {names: ["tsp", "teaspoon", "teaspoons"], factor: 0.00492892},
            {names: ["yd3", "cubic-yard", "cubic-yards"], factor: 764.554},
            {names: ["ft3", "cubic-foot", "cubic-feet"], factor: 0.0283168},
            {names: ["in3", "cubic-inch", "cubic-inches"], factor: 1.63871e-5},
            {names: ["bbl", "barrel", "barrels"], factor: 0.158987} // Oil barrel (US)
        ],

        "time": [
            {names: ["s", "second", "seconds"], factor: 1},
            {names: ["ms", "millisecond", "milliseconds"], factor: 1e-3},
            {names: ["μs", "microsecond", "microseconds"], factor: 1e-6},
            {names: ["ns", "nanosecond", "nanoseconds"], factor: 1e-9},
            {names: ["min", "minute", "minutes"], factor: 60},
            {names: ["h", "hour", "hours"], factor: 3600},
            {names: ["day", "days"], factor: 86400},
            {names: ["week", "weeks"], factor: 604800},
            {names: ["fortnight", "fortnights"], factor: 1209600},
            {names: ["year", "years"], factor: 31536000},
            {names: ["decade", "decades"], factor: 315360000},
            {names: ["century", "centuries"], factor: 3153600000},
            {names: ["millennium", "millennia"], factor: 31536000000}
        ],

        "digital_storage": [
            {names: ["bit", "bits"], factor: 1},
            {names: ["byte", "bytes"], factor: 8},
            {names: ["kb", "kilobyte", "kilobytes"], factor: 8e3},
            {names: ["mb", "megabyte", "megabytes"], factor: 8e6},
            {names: ["gb", "gigabyte", "gigabytes"], factor: 8e9},
            {names: ["tb", "terabyte", "terabytes"], factor: 8e12},
            {names: ["pb", "petabyte", "petabytes"], factor: 8e15},
            {names: ["eb", "exabyte", "exabytes"], factor: 8e18},
            {names: ["zb", "zettabyte", "zettabytes"], factor: 8e21},
            {names: ["yb", "yottabyte", "yottabytes"], factor: 8e24},
            {names: ["kib", "kibibyte", "kibibytes"], factor: 1024 * 8},
            {names: ["mib", "mebibyte", "mebibytes"], factor: 1024 ** 2 * 8},
            {names: ["gib", "gibibyte", "gibibytes"], factor: 1024 ** 3 * 8},
            {names: ["tib", "tebibyte", "tebibytes"], factor: 1024 ** 4 * 8},
            {names: ["pib", "pebibyte", "pebibytes"], factor: 1024 ** 5 * 8},
            {names: ["eib", "exbibyte", "exbibytes"], factor: 1024 ** 6 * 8},
            {names: ["zib", "zebibyte", "zebibytes"], factor: 1024 ** 7 * 8},
            {names: ["yib", "yobibyte", "yobibytes"], factor: 1024 ** 8 * 8}
        ]
    }

    if (args.l) {
        for (let [category, _units] of Object.entries(unitData)) {
            terminal.printLine(category, Color.COLOR_1)
            terminal.printLine("  Base Unit: " + _units[0].names.slice(-1)[0])
            for (let unit of _units) {
                let conversion = ""
                if (unit.factor) {
                    conversion = `*${unit.factor}`
                } else if (unit.from && unit.to) {
                    conversion = `from: ${unit.from}, to: ${unit.to}`
                }

                terminal.printLine(`  - ${unit.names.slice(-1)} (${conversion})`)
            }
        }
        return
    }

    const units = []
    for (let [category, _units] of Object.entries(unitData)) {
        for (let unit of _units) {
            unit.category = category
            unit.properName = unit.names.slice(-1)[0]
            units.push(unit)
        }
    }

    args.s = args.s.trim().toLowerCase()
    args.r = args.r.trim().toLowerCase()

    const startUnit = units.find(u => u.names.includes(args.s))
    const resultUnit = units.find(u => u.names.includes(args.r))

    if (startUnit == undefined) {
        terminal.printError(`Unknown unit "${args['start-unit']}"`)
        terminal.printCommand("[list all available units]", `unit 1 m m --list-units`)
        return
    }

    if (resultUnit == undefined) {
        terminal.printError(`Unknown unit "${args['result-unit']}"`)
        terminal.printCommand("[list all available units]", `unit 1 m m --list-units`)
        return
    }

    if (startUnit.category != resultUnit.category) {
        throw new Error(`Unit dimensions don't match (${startUnit.category} ≠ ${resultUnit.category})`)
    }

    let result = args.v
    
    if (startUnit.factor) {
        result *= startUnit.factor
    } else if (startUnit.to) {
        result = startUnit.to(result)
    }

    if (resultUnit.factor) {
        result /= resultUnit.factor
    } else if (resultUnit.from) {
        result = resultUnit.from(result)
    }

    terminal.printLine(result)
}, {
    description: "convert numbers between units",
    args: {
        "v=value:n": "numeric value of unit",
        "s=start-unit:s": "starting unit",
        "r=result-unit:s": "resulting unit",
        "?l=list-units:b": "list all known units"
    }
})

// ------------------- js/commands/upload.js --------------------
terminal.addCommand("upload", async function(args) {
    if (args.filename && !terminal.isValidFileName(args.filename)) {
        throw new Error("Invalid Filename")
    }

    await terminal.modules.load("upload", terminal)

    try {
        var [fileName, fileContent, isDataURL] = await terminal.modules.upload.file()
    } catch (e) {
        throw new Error("File Upload Failed")
    }

    let construct = PlainTextFile
    if (isDataURL) {
        construct = DataURLFile
    }

    if (args.filename) {
        fileName = args.filename
    }

    if (terminal.fileExists(fileName)) {
        terminal.printError(`File "${fileName}" already exists in this folder.`)
        while (true) {
            fileName = await terminal.prompt("A new filename: ")
            if (terminal.fileExists(fileName)) {
                terminal.printError(`File "${fileName}" also already exists in this folder.`)
            } else if (!terminal.isValidFileName(fileName)) {
                terminal.printError("Invalid Filename (Contains illegal characters or is too long)")
            } else {
                break
            }
        }
    }
    const file = new (construct)(fileContent)

    file.setName(fileName)

    const fileSize = file.computeSize()

    if (!terminal.fileSystem.inSessionMode) {
        const currSystemSize = terminal.rootDirectory.computeSize()
        const maxSystemSize = terminal.data.storageSize
        const overdo = (fileSize + currSystemSize) - maxSystemSize
        if (overdo > 0) {
            terminal.print(`You have used up ${terminal.fileSystem.filesizeStr(currSystemSize)}`)
            terminal.print(`/${terminal.fileSystem.filesizeStr(maxSystemSize)} `)
            terminal.printLine(`(${Math.ceil(currSystemSize / maxSystemSize * 100)}%) of your storage.`)
            terminal.printLine(`Adding this file would exceed this limit by >${terminal.fileSystem.filesizeStr(overdo)}.`)
            throw new Error("File upload failed.")
        }
    }

    terminal.rootDirectory.addChild(file)
    terminal.printLine(`File uploaded as ${file.path} (~${terminal.fileSystem.filesizeStr(fileSize)})`)
}, {
    description: "upload a file from your computer",
    args: {
        "?f=filename:s": "name of your shiny new uploaded file",
    }
})



// ------------------- js/commands/vigenere.js --------------------
terminal.addCommand("vigenere", async function(args) {
    const getCharValue = char => char.toLowerCase().charCodeAt(0) - 97
    const getCharFromValue = value => String.fromCharCode(value + 97)
    
    if (!/^[a-zA-Z\s]+$/.test(args.message))
        throw new Error("message must only contain letters and spaces")
    else if (!/^[a-zA-Z]+$/.test(args.key))
        throw new Error("key must only contain letters")

    let output = ""

    Array.from(args.message).forEach((character, i) => {
        if (/[a-zA-Z]/.test(character)) {
            let charValue = getCharValue(character)
            let keyValue = getCharValue(args.key[i % args.key.length])
            let newValue = (charValue + keyValue) % 26
            if (args.d)
                newValue = (charValue - keyValue + 26) % 26
            output += getCharFromValue(newValue)
        } else {
            output += character
        }
    })

    terminal.printLine(output)

    if (args.c) {
        await terminal.copy(output, {printMessage: true})
    }
}, {
    description: "encrypt/decrypt a message using the vigenere cipher",
    args: {
        "message": "the message to encrypt/decrypt",
        "key": "the key to use",
        "?d=decrypt:b": "decrypt the message instead of encrypting it",
        "?c=copy:b": "copy the result to the clipboard"
    },
})



// ------------------- js/commands/visits.js --------------------
terminal.addCommand("visits", async function(args) {
    const visits = await fetch(
        "api/get_visit_count.php"
    ).then(response => response.json())
    terminal.printTable(visits.map(v => [v["url"], v["visits"]]), ["url", "visits"])
}, {
    "description": "Shows the number of page visits",
})

// ------------------- js/commands/voronoi.js --------------------
terminal.addCommand("voronoi", async function(args) {
    const NUM_RANDOM_POINTS = args.n
    const POINT_RADIUS_PX = 8
    const LINES_COLOR = "white"

    await terminal.modules.import("geometry2d", window)
    await terminal.modules.load("window", terminal)

    const terminalWindow = terminal.modules.window.make({
        name: args.r ? "Voronoi Diagram Animation" : "Click and Drag Points",
        fullscreen: args.fullscreen
    })

    const canvas = terminalWindow.CANVAS
    const context = terminalWindow.CONTEXT

    const canvasSize = () => new Point(canvas.width, canvas.height)

    const canvasBoundingPoints = new GeometryObjectCollection([
        new Point(0, 0), new Point(canvas.width, 0),
        new Point(canvas.width, canvas.height),
        new Point(0, canvas.height), 
    ])

    const canvasBoundingLines = new GeometryObjectCollection(
        canvasBoundingPoints.objects.map((p, i) => {
            return new LineSegment(p, canvasBoundingPoints.objects[(i + 1) % 4])
        })
    )

    function orderPointsByAngleAround(points, center) {
        const pointAngles = points.map(p => p.angleTo(center))
        const indeces = Array.from(points.keys())
        indeces.sort((i, j) => pointAngles[i] - pointAngles[j])
        return indeces.map(i => points[i])
    }

    const epsilon = 1e-4

    let lastHue = 0
    function randomColor() {
        const color = Color.fromHSL(lastHue, 0.8, 0.5)
        lastHue = (lastHue + Math.PI / 8) % 1
        return color
    }

    class VoronoiDiagram {

        constructor(points) {
            this.points = points ?? []
            this.pointColors = []
            this.polygons = []
        }

        addPoint(point) {
            this.points.push(point)
            this.pointColors.push(randomColor())
        }

        getClosestPointAt(position) {
            let closestDistance = Infinity
            let closestPoint = null
            for (const point of this.points) {
                const distance = point.distance(position)
                if (distance < closestDistance) {
                    closestDistance = distance
                    closestPoint = point
                }
            }
            return closestPoint
        }

        update() {
            this.polygons = []

            for (const point of this.points) {
                const bisectors = new GeometryObjectCollection()
                const boundingIntersections = new GeometryObjectCollection()

                for (const otherPoint of this.points) {
                    if (point.equals(otherPoint)) {
                        continue
                    }
                    
                    const midPoint = point.lerp(otherPoint, 0.5)
                    const bisectorAngle = point.angleTo(otherPoint) + Math.PI / 2
                    const bisector = new Line(midPoint, bisectorAngle)
                    bisectors.addObject(bisector)

                    const bisectorEnds = canvasBoundingLines.intersect(bisector)
                    console.assert(bisectorEnds.objects.length == 2)

                    boundingIntersections.addObjects(bisectorEnds.objects)
                }

                const bisectorIntersections = bisectors.selfIntersect()
                const candidatePoints = boundingIntersections
                    .concat(bisectorIntersections)
                    .concat(canvasBoundingPoints)

                // filter points by their nearest point being the correct one
                const goodPoints = candidatePoints.objects.filter(p => {
                    const nearbyP = p.lerp(point, epsilon)
                    const closestPoint = this.getClosestPointAt(nearbyP)
                    return closestPoint.equals(point)
                })

                const polygon = orderPointsByAngleAround(goodPoints, point)
                this.polygons.push(polygon)
            }

            console.assert(this.polygons.length == this.points.length)
        }

        draw() {
            context.fillStyle = "white"
            context.fillRect(0, 0, canvas.width, canvas.height)

            for (let i = 0; i < this.points.length; i++) {
                const point = this.points[i]
                const color = this.pointColors[i]
                const polygon = this.polygons[i]
                
                if (polygon.length >= 3) {
                    context.beginPath()
                    for (let i = 0; i < polygon.length + 1; i++) {
                        const point = polygon[(i + 1) % polygon.length]
                        
                        if (i == 0) {
                            context.moveTo(point.x, point.y)
                        } else {
                            context.lineTo(point.x, point.y)
                        }
                    }
                    
                    const {h, s, l} = color.hsl
                    context.fillStyle = Color.fromHSL(h / 360, s, 0.7).toString()
                    context.fill()

                    context.strokeStyle = LINES_COLOR
                    context.stroke()
                }

                context.beginPath()
                context.arc(point.x, point.y, POINT_RADIUS_PX, 0, Math.PI * 2)
                context.fillStyle = color.toString()
                context.fill()
                context.strokeStyle = LINES_COLOR
                context.stroke()
            }
        }

    }

    const voronoi = new VoronoiDiagram()
    const pointCloud = new GeometryObjectCollection()

    const randomPointInCanvas = () => canvasSize().mul(Point.random().scale(0.8).add(Point.unit11.scale(0.1)))

    for (let i = 0; i < NUM_RANDOM_POINTS; i++) {
        const randomPoint = randomPointInCanvas()
        const distance = pointCloud.distance(randomPoint)

        if (distance < 4 * POINT_RADIUS_PX) {
            i--
            continue
        }

        pointCloud.addObject(randomPoint)
        voronoi.addPoint(randomPoint)
    }

    voronoi.update()
    voronoi.draw()
    let dragPoint = null

    function spawnPoint(event) {
        const point = Point.fromEvent(event, canvas)
        voronoi.addPoint(point)
        voronoi.update()
        voronoi.draw()

        dragPoint = point
    }


    function beginDrag(event) {
        const eventPoint = Point.fromEvent(event, canvas)
        const closestPoint = voronoi.getClosestPointAt(eventPoint)
        if (!closestPoint) {
            return spawnPoint(event)
        }

        const distance = eventPoint.distance(closestPoint)
        if (distance <= POINT_RADIUS_PX * 2) {
            dragPoint = closestPoint
        } else {
            spawnPoint(event)
        }
    }

    function continueDrag(event) {
        if (!dragPoint) {
            return
        }

        const eventPoint = Point.fromEvent(event, canvas)
        dragPoint.x = eventPoint.x
        dragPoint.y = eventPoint.y

        voronoi.update()
        voronoi.draw()
    }

    function releaseDrag(event) {
        dragPoint = null
    }

    function removePoint(event) {
        const eventPoint = Point.fromEvent(event, canvas)
        
        const lengthBefore = voronoi.points.length

        let removeIndeces = []
        for (let i = 0; i < voronoi.points.length; i++) {
            if (voronoi.points[i].distance(eventPoint) <= POINT_RADIUS_PX * 2) {
                removeIndeces.push(i)
            }
        }

        for (let i = removeIndeces.length - 1; i >= 0; i--) {
            voronoi.points.splice(removeIndeces[i], 1)
            voronoi.pointColors.splice(removeIndeces[i], 1)
        }
        
        if (lengthBefore != voronoi.points.length) {
            event.stopImmediatePropagation()
        }

        voronoi.update()
        voronoi.draw()

        return removeIndeces.length > 0
    }

    canvas.addEventListener("mousedown", event => {
        if (event.button == 0) {
            beginDrag(event)
        }
    })

    canvas.addEventListener("mousemove", continueDrag)
    canvas.addEventListener("mouseup", releaseDrag)
    canvas.addEventListener("contextmenu", event => {
        if (removePoint(event)) {
            event.preventDefault()
        }
    })

    canvas.addEventListener("touchstart", beginDrag)
    canvas.addEventListener("touchmove", continueDrag)
    canvas.addEventListener("touchend", releaseDrag)
    
    // for debugging
    terminal.window.voronoi = voronoi

    if (args["random-move"]) {

        function movePointsToTargets(points, targets, reset=false, speed=1) {
            for (let i = 0; i < targets.length; i++) {
                const point = points[i]
                const target = targets[i]

                const delta = target.sub(point)
                if (delta.length > speed * 2) {
                    point.iadd(delta.normalized.scale(speed))
                } else if (reset) {
                    targets[i].set(randomPointInCanvas())
                }
            }
        }

        const targetTargets = voronoi.points.map(p => p.copy())
        const targets = voronoi.points.map(p => p.copy())

        function loop() {
            movePointsToTargets(targets, targetTargets, true, 0.6)
            movePointsToTargets(voronoi.points, targets, false, 0.51)

            voronoi.update()
            voronoi.draw()

            window.requestAnimationFrame(loop)
        }

        loop()
        
    }

}, {
    description: "create voronoi diagrams interactively",
    args: {
        "?n=num-points:i:0~100": "number of random initial points",
        "?r=random-move:b": "make points wander randomly",
        "?f=fullscreen:b": "enable fullscreen mode",
    },
    defaultValues: {
        n: 8
    }
})

// ------------------- js/commands/w.js --------------------
terminal.addCommand("w", function() {
    terminal.printLine("USER   TIME_ELAPSED")
    terminal.print("root   ", Color.COLOR_1)
    terminal.printLine(((Date.now() - terminal.startTime) / 1000) + "s")
}, {
    description: "print the current time elapsed"
})



// ------------------- js/commands/water.js --------------------
terminal.addCommand("water", async function(args) {
    const ithBitNums = Array.from({length: 32}).map((_, i) => (1 << i))

    class SmallWaterGrid {

        constructor(n, rows) {
            if (n > 32) {
                throw new Error("Maximum Size is 32")
            }

            this.n = n
            this.rows = rows ?? new Uint32Array(n)
        }

        copy() {
            return new SmallWaterGrid(this.n, this.rows.slice())
        }

        fillWithWater(x, y) {
            this.rows[y] |= ithBitNums[x]
        }

        static random(n, p=0.2) {
            const grid = new SmallWaterGrid(n)
            for (let y = 0; y < n; y++) {
                for (let x = 0; x < n; x++) {
                    if (Math.random() < p) {
                        grid.fillWithWater(x, y)
                    }
                }
            }
            return grid
        }

        isFilled(x, y) {
            return (this.rows[y] & ithBitNums[x]) !== 0
        }

        toString() {
            const topBottomLine = "+" + "-".repeat(this.n * 2 + 1) + "+"
            let outString = topBottomLine + "\n"
            for (let y = 0; y < this.n; y++) {
                outString += "|"
                for (let x = 0; x < this.n; x++) {
                    if (this.isFilled(x, y)) {
                        outString += " W"
                    } else {
                        outString += " ."
                    }
                }
                outString += " |\n"
            }
            return outString + topBottomLine
        }

        _iterationStep() {
            const rowCopy = this.rows.slice()
            let madeChange = false

            for (let y = 0; y < this.n; y++) {
                for (let x = 0; x < this.n; x++) {
                    if (rowCopy[y] & ithBitNums[x]) {
                        continue
                    }

                    let sum = 0
                    sum += (x > 0 && (rowCopy[y] & ithBitNums[x - 1]) !== 0)
                    sum += (x < this.n - 1 && (rowCopy[y] & ithBitNums[x + 1]) !== 0)
                    sum += (y > 0 && (rowCopy[y - 1] & ithBitNums[x]) !== 0)
                    sum += (y < this.n - 1 && (rowCopy[y + 1] & ithBitNums[x]) !== 0)

                    if (sum >= 2) {
                        this.rows[y] |= ithBitNums[x]
                        madeChange = true
                    }
                }
            }

            return madeChange
        }

        computeLength(makeCopy=true) {
            const grid = makeCopy ? this.copy() : this
            for (let n = 1;; n++) {
                if (!grid._iterationStep()) {
                    return n
                }
            }
        }

    }

    async function showAnimation(grid, intervalMs=200) {
        const gridCopy = grid.copy()
        const element = terminal.print("", undefined, {forceElement: true})
        element.textContent = grid.toString()
        while (gridCopy._iterationStep()) {
            element.textContent = gridCopy.toString()
            await sleep(intervalMs)
        }
    }

    async function computeMaximumLength(n, {printProgress=true, progressUpdateInterval=10_000}={}) {
        const maxNumInRow = 2 ** n
        const rows = new Uint8Array(n)
        let maxLength = 1
        const totalNum = 2 ** (n * n)
        let bestGrid = null
        const progressOutput = printProgress ? terminal.print("", undefined, {forceElement: true}) : null
        if (printProgress) {
            terminal.addLineBreak()
        }

        let i = 0
        let carry = false
        let count = 0
        while (i < n) {
            if (!carry) {
                const grid = new SmallWaterGrid(n, rows)
                const length = grid.computeLength(true)
                if (length > maxLength) {
                    maxLength = length
                    bestGrid = new SmallWaterGrid(n, rows.slice())
                }

                if (printProgress) {
                    count++
                    const percent = Math.round(count / totalNum * 10_000) / 100
                    if (count % progressUpdateInterval === 0) {
                        progressOutput.textContent = `${percent}% done`
                        await sleep(0)
                    }
                }
            }

            rows[i]++
            carry = false
            if (rows[i] >= maxNumInRow) {
                rows[i] = 0
                i++
                carry = true
            } else {
                i = 0
            }

            if (printProgress) {
                progressOutput.textContent = "Finished."
            }
        }

        return {maxLength, bestGrid}
    }

    const {maxLength, bestGrid} = await computeMaximumLength(6)
    terminal.printLine(maxLength)
    terminal.printLine(bestGrid.toString())
}, {
    description: "compute solutions to the longest water problem",
    isSecret: true
})

// ------------------- js/commands/watti.js --------------------
terminal.addCommand("watti", async function(args) {
    if (args.action == "list") {
        const result = await fetch("https://www.noel-friedrich.de/walk-to-college/api/get_walks.php")
        const walks = await result.json()

        for (let walk of walks) {
            terminal.printLine(`${walk.date}: ${walk.names}`)
        }
    } else if (args.action == "add") {
        const names = await terminal.prompt("Names: ")
        const date = await terminal.prompt("Date: ")
        const password = await terminal.prompt("Password: ", {password: true})

        let url = "https://www.noel-friedrich.de/walk-to-college/api/add_walk.php?"
        url += `names=${encodeURIComponent(names)}&`
        url += `date=${encodeURIComponent(date)}&`
        url += `password=${encodeURIComponent(password)}`

        const result = await fetch(url)
        const text = await result.text()
        terminal.printLine(text)
    }
}, {
    description: "manage the walk to trinity database",
    isSecret: true,
    args: {
        "action:e:list|add": "<enum>"
    }
})

// ------------------- js/commands/wave.js --------------------
terminal.addCommand("wave", async function() {
    await terminal.modules.load("window", terminal)
    let terminalWindow = terminal.modules.window.make({
        iframeUrl: "../wave/",
        name: "Wave Simulator"
    })
    terminal.onInterrupt(() => {
        terminalWindow.close()
    })

    while (true) await sleep(100)
}, {
    description: "play with a wave"
})

// ------------------- js/commands/wc.js --------------------
terminal.addCommand("wc", function(args) {
    let text = ""
    if (args.s) {
        text = args.s
        if (args.f) {
            terminal.printLine("Ignoring file argument")
        }
    } else if (args.f) {
        let file = terminal.getFile(args.f)
        if (file.type == FileType.FOLDER) {
            throw new Error("Cannot read file of type FOLDER")
        }
        text = file.content
    } else {
        throw new Error("Either String or File must be provided")
    }

    let fileInfos = {
        "lines": text.split("\n").length,
        "words": text.split(" ").length,
        "characters": text.length
    }
    for (let [infoName, infoContent] of Object.entries(fileInfos)) {
        terminal.print(infoContent + " ", Color.COLOR_1)
        terminal.printLine(infoName)
    }
}, {
    description: "display word and line count of file",
    args: {
        "?f=file:f": "file to open",
        "?s": "string to count instead of file"
    }
})



// ------------------- js/commands/weather.js --------------------
terminal.addCommand("weather", async () => {
  try {
    const position = await new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject);
    });

    const { latitude: lat, longitude: lon } = position.coords;

    terminal.printLine("Getting weather data for your location...");

    const response = await fetch(
      `https://api.brightsky.dev/current_weather?lat=${lat}&lon=${lon}`
    );

    const {
      sources: [{ station_name }],
      weather: { temperature, icon },
    } = await response.json();

    const weatherIcons = {
      "clear-day": "☀️",
      "clear-night": "🌙",
      "partly-cloudy-day": "⛅",
      "partly-cloudy-night": "⛅",
      cloudy: "☁️",
      fog: "🌫️",
      wind: "🌬️",
      rain: "🌧️",
      sleet: "🌨️",
      snow: "❄️",
      hail: "🌨️",
      thunderstorm: "⛈️",
      null: "",
    };

    terminal.printLine(
      `Current weather near ${station_name}: ${temperature}°C, ${
        weatherIcons[icon]
      }`
    );
  } catch {
    terminal.printError("Failed to get weather data.");
  }
}, {
  description: "Get the current weather",
  author: "Colin Chadwick"
})

// ------------------- js/commands/whatday.js --------------------
terminal.addCommand("whatday", function(args) {

    function dayToStr(n) {
        return [
            "first", "second", "third", "fourth",
            "fifth", "sixth", "seventh", "eigth",
            "ninth", "tenth", "eleventh", "twelfth",
            "thirteenth", "fourteenth", "fifteenth",
            "sixteenth", "seventeenth", "eighteenth",
            "nineteenth", "twentyth", "twentyfirst",
            "twentysecond", "twentythird", "twentyfourth",
            "twentyfifth", "twentysixth", "twentyseventh",
            "twentyeighth", "twentyninth", "thirtieth",
            "thirtyfirst"
        ][n - 1]
    }

    function yearToStr(n) {
        if (n == 0) return "zero"
        let out = ""
        if (n < 0) {
            out += "minus "
            n *= -1
        }
        function twoDigitNumStr(n) {
            const n1s = [
                "", "one", "two", "three", "four", "five",
                "six", "seven", "eight", "nine", "ten",
                "eleven", "twelve", "thirteen", "fourteen",
                "fifteen"
            ], n2s = [
                "", "", "twenty", "thirty", "fourty",
                "fifty", "sixty", "seventy", "eighty",
                "ninety"
            ]
            if (n1s[n]) return n1s[n]
            let n1 = n % 10
            let n2 = parseInt((n - n1) / 10)
            let out = ""
            out += n2s[n2]
            out += n1s[n1]
            if (n2 == 1) {
                out += "teen"
            }
            return out
        }
        if (String(n).length == 1) {
            return out + twoDigitNumStr(n)
        }
        if (String(n).length == 2) {
            return out + twoDigitNumStr(n)
        }
        if (String(n).length == 3) {
            let n1 = String(n)[0]
            let n2 = String(n).slice(1, 3)
            return out + twoDigitNumStr(n1) + "hundred" + twoDigitNumStr(n2)
        }
        if (String(n).length == 4) {
            let n1 = String(n).slice(0, 2)
            let n2 = String(n).slice(2, 4)
            return out + twoDigitNumStr(n1) + "-" + twoDigitNumStr(n2)
        } 
    }

    const dayNames = [
        "Sunday", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday"
    ], monthNames = [
        "January", "February", "March", "April", "May",
        "June", "July", "August", "September",
        "October", "November", "December"
    ]

    let dateStr = args["DD.MM.YYYY"]

    function dateEq(d1, d2) {
        return (d1.getFullYear() == d2.getFullYear()
        && d1.getMonth() == d2.getMonth()
        && d1.getDate() == d2.getDate())
    }

    function sayDay(date) {
        let day = dayToStr(date.getDate())
        let month = monthNames[date.getMonth()].toLowerCase()
        let year = yearToStr(date.getFullYear())
        let dayName = dayNames[date.getDay()].toLowerCase()
        if (dateEq(new Date(), date)) {
            terminal.printLine(`today is a ${dayName}`)
        } else {
            if (new Date() > date) {
                terminal.printLine(`the ${day} of ${month} of the year ${year} was a ${dayName}`)
            } else {
                terminal.printLine(`the ${day} of ${month} of the year ${year} will be a ${dayName}`)
            }
        }
    }

    if (dateStr.toLowerCase() == "t" || dateStr.toLowerCase() == "today") {
        sayDay(new Date())
        return
    } else if (/^[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,4}$/.test(dateStr)) {
        let [d, m, y] = dateStr.split(".").map(i => parseInt(i))
        let date = new Date()
        date.setFullYear(y, m - 1, d)
        if (date.getDate() != d || (date.getMonth() + 1) != m || date.getFullYear() != y) {
            throw new Error("Invalid day - doesn't exist.")
        }
        sayDay(date)
    } else {
        terminal.printLine("Date-Format: DD:MM:YYYY, e.g. 01.01.1970")
        throw new Error(`Invalid date: ${dateStr}`)
    }
    
}, {
    description: "get the weekday of a date",
    args: ["DD.MM.YYYY"]
})



// ------------------- js/commands/whatis.js --------------------
terminal.addCommand("whatis", async function(args) {
    if (args.command == "*") {
        let maxFuncLength = terminal.visibleFunctions.reduce((p, c) => Math.max(p, c.name.length), 0)
        let functions = [...terminal.visibleFunctions].sort((a, b) => a.name.localeCompare(b.name))
        for (let func of functions) {
            let funcStr = stringPadBack(func.name, maxFuncLength)
            terminal.printCommand(funcStr, func.name, Color.WHITE, false)
            terminal.printLine(`  ${func.description}`)
        }
        return
    }

    if (args.command == "whatis")
        throw new Error("Recursion.")

    if (!terminal.commandExists(args.command))
        throw new Error(`command not found: ${args.command}`)

    let func = await terminal.loadCommand(args.command)
    terminal.printLine(`${func.name}: ${func.description}`)
}, {
    description: "display a short description of a command",
    args: ["command"]
})

// ------------------- js/commands/whoami.js --------------------
terminal.addCommand("whoami", async function() {
    terminal.printLine("fetching data...")

    function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1)
    }

    const infos = {
        Localtime: new Date().toLocaleString(),
        Timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        Pageon: window.location.pathname,
        Referrer: document.referrer,
        PreviousSites: history.length,
        BrowserVersion1a: navigator.appVersion,
        BrowserVersion1b: navigator.userAgent,
        BrowserLanguage: navigator.language,
        BrowserOnline: navigator.onLine,
        BrowserPlatform: navigator.platform,
        JavaEnabled: navigator.javaEnabled(),
        DataCookiesEnabled: navigator.cookieEnabled,
        ScreenWidth: screen.width,
        ScreenHeight: screen.height,
        WindowWidth: innerWidth,
        WindowHeight: innerHeight,
        AvailWidth: screen.availWidth,
        AvailHeights: screen.availHeight,
        ScrColorDepth: screen.colorDepth,
        ScrPixelDepth: screen.pixelDepth,
    }

    try {
        let response = await (await fetch("https://api.db-ip.com/v2/free/self")).json()
        for (let [key, value] of Object.entries(response)) {
            infos[capitalize(key)] = value
        }
    } catch {}

    const longestInfoName = Math.max(...Object.keys(infos).map(k => k.length)) + 2
    for (let [infoName, infoContent] of Object.entries(infos)) {
        terminal.print(stringPadBack(infoName, longestInfoName), Color.COLOR_1)
        terminal.printLine(infoContent)
    }
}, {
    description: "get client info"
})

// ------------------- js/commands/wurzle-admin.js --------------------
terminal.addCommand("wurzle-admin", async function(args) {
    const apiUrlBase = "https://www.noel-friedrich.de/wurzle-api"

    const localStoragePasswordKey = "wurzle-challenge-password"
    const password = args.password ?? localStorage.getItem(localStoragePasswordKey)

    async function apiGet(action, params=null) {
        params ??= {}
        params["password"] = password
        let url = `${apiUrlBase}/${action}.php?`
        for (const [key, value] of Object.entries(params)) {
            url += `${encodeURIComponent(key)}=${encodeURIComponent(value)}&`
        }
        url = url.slice(0, -1)

        const response = await fetch(url)
        try {
            const jsonData = await response.json()
            if (localStorage.getItem(localStoragePasswordKey) != password) {
                localStorage.setItem(localStoragePasswordKey, password)
                terminal.printSuccess("Saved Password to Localstorage.")
            }
            return jsonData
        } catch (e) {
            console.error(e)
            localStorage.removeItem(localStoragePasswordKey)
            throw new Error("Incorrect Password.")
        }
    }

    if (args.action == "show") {
        const jsonData = await apiGet("get_all_wurzles")
        const headerColumns = Array.from(Object.keys(jsonData[0]))
        terminal.printTable(jsonData.map(r => headerColumns.map(h => r[h])), headerColumns)
    }

    else if (args.action == "set") {
        if (!args.date || !args.term) {
            throw new Error("No date or term provided to set.")
        }

        const jsonData = await apiGet("insert_wurzle", {date: args.date, term: args.term, author: args.author})
        terminal.printLine(`success=${jsonData.success} action=${jsonData.action}`)
    }

    else if (args.action == "delete") {
        if (!args.date) {
            throw new Error("No date provided to delete.")
        }

        const jsonData = await apiGet("remove_wurzle", {date: args.date})
        terminal.printLine(`success=${jsonData.success} deleted=${jsonData.deleted}`)
        if (jsonData.error) {
            terminal.printLine(`error=${jsonData.error}`)
        }
    }
}, {
    description: "manage wurzles (recmaths.ch/wurzle)",
    args: {
        "action:e:show|set|delete": "<enum>",
        "?d=date:s": "date to set or delete",
        "?t=term:s": "term to set",
        "?a=author:s": "author of wurzle",
        "?password:s": "admin password required to see stats"
    },
    defaultValues: {
        author: "noel"
    },
    isSecret: true
})

// ------------------- js/commands/wurzle-stats.js --------------------
terminal.addCommand("wurzle-stats", async function(args) {
    const apiUrlBase = "https://www.noel-friedrich.de/wurzle-api/get_data.php"

    const localStoragePasswordKey = "wurzle-stats-password"
    const password = args.password ?? localStorage.getItem(localStoragePasswordKey)
    const date = args.date ?? new Date().toJSON().slice(0, 10).split("-").reverse().join(".")

    const fullApiUrl = `${apiUrlBase}?password=${encodeURIComponent(password)}&date=${encodeURIComponent(date)}`

    const response = await fetch(fullApiUrl)
    let jsonData = null

    try {
        jsonData = await response.json()

        // yay, password seems to be correct!
        if (localStorage.getItem(localStoragePasswordKey) != password) {
            localStorage.setItem(localStoragePasswordKey, password)
            terminal.printSuccess("Saved correct password locally.")
        }
    } catch (e) {
        // no, password seems to be incorrect!
        localStorage.removeItem(localStoragePasswordKey)
        terminal.printError("Incorrect Password. Aborting.")
        return
    }

    if (!args.date) {
        terminal.printLine(`selected date: ${date}`)
    }

    if (jsonData.length == 0) {
        terminal.printLine("no records found on selected date.")
        return
    }

    const rowHeaders = (["index"]).concat(Array.from(Object.keys(jsonData[0])))
    jsonData = jsonData.reverse().map((r, i) => {r.index = i + 1; return r})
    const dataRows = jsonData.map(rowData => rowHeaders.map(h => rowData[h]))

    const totalStartCount = jsonData.map(r => r.start_count).reduce((p, c) => p + c, 0)
    const totalFinishCount = jsonData.map(r => r.finish_count).reduce((p, c) => p + c, 0)
    const totalSuccessCount = jsonData.map(r => r.success_count).reduce((p, c) => p + c, 0)

    terminal.printTable(dataRows, rowHeaders)
    terminal.addLineBreak()

    terminal.printLine(`total starts: ${totalStartCount}`)    
    terminal.printLine(`total finishes: ${totalFinishCount}`) 

    const successPercent = Math.round(totalSuccessCount / totalFinishCount * 10000) / 100
    terminal.printLine(`total successes: ${totalSuccessCount} (${successPercent}%)`)
    
}, {
    description: "show usage stats about wurzle (recmaths.ch/wurzle)",
    args: {
        "?d=date:s": "date to see the stats of",
        "?password": "admin password required to see stats",
    },
    isSecret: true
})



// ------------------- js/commands/yes.js --------------------
terminal.addCommand("yes", async function(args) {
    let message = args.message
    while (true) {
        terminal.printLine(message)
        terminal.scroll("auto")
        await sleep(args.s ? 100 : 0)
    }
}, {
    description: "print a message repeatedly",
    args: {
        "?message": "the message to print",
        "?s:b": "slow mode"
    },
    standardVals: {
        message: "y"
    }
})



// ------------------- js/commands/zip.js --------------------
terminal.addCommand("zip", async function() {
    await terminal.animatePrint("zip it lock it put it in your pocket")
    await terminal.animatePrint("(Sorry, this command is not yet implemented)")
    await terminal.animatePrint("It's very high on the priority list though!")
    await sleep(1000)
    await terminal.animatePrint("I promise!")
    await sleep(1000)
    await terminal.animatePrint("I'm working on it!")
    await sleep(1000)
    await terminal.animatePrint("I swear!")
    await sleep(1000)
    await terminal.animatePrint("I'm not lying!")
    await sleep(1000)
    await terminal.animatePrint("Maybe I'm lying...")
    await sleep(3000)
    await terminal.animatePrint("Zipping is hard!!")

    terminal.printEasterEgg("Zipper-Egg")

}, {
    description: "zip a file"
})



// ------------------- js/modules/binom.js --------------------
function binom(n, k) {
    let res = 1
    for (let i = 1; i <= k; i++) {
        res *= n - k + i
        res /= i
    }
    return res
}

function binompdf(n, p, k) {
    return binom(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k)
}

function binomcdf(n, p, lower, upper) {
    let res = 0
    for (let i = lower; i <= upper; i++)
        res += binompdf(n, p, i)
    return res
}

terminal.modules.binom = {binom, binompdf, binomcdf}

// ------------------- js/modules/cliapi.js --------------------
class CliApi {

    static urlBase = "api/"

    static KEY_REGEX = /^[a-zA-Z\_\-][a-zA-Z\_\-0-9\#\~]*$/

    static async get(name) {
        let url = `${CliApi.urlBase}get.php?key=${encodeURIComponent(name)}`
        return await fetch(url).then(response => response.text())
    }

    static async set(name, value) {
        let url = `${CliApi.urlBase}set.php`
        return await fetch(`${url}?key=${encodeURIComponent(name)}&value=${encodeURIComponent(value)}`)
    }

    static async pullFile(name) {
        let url = `${CliApi.urlBase}pull_file.php?key=${encodeURIComponent(name)}`
        return await fetch(url).then(response => response.text())
    }

    static async pushFile(name, content) {
        let url = `${CliApi.urlBase}push_file.php`
        let formData = new FormData()
        formData.append("file_name", name)
        formData.append("content", content)
        let result = await fetch(url, {
            method: "POST",
            body: formData
        }).then(response => response.json())
        return result
    }

}

terminal.modules.cliapi = CliApi

// ------------------- js/modules/game.js --------------------
function angleDifference(a, b) {
    let diff = a - b
    while (diff < -Math.PI/2) diff += Math.PI
    while (diff > Math.PI/2) diff -= Math.PI
    return diff
}

class Vector2d {

    constructor(x, y) {
        this.x = x
        this.y = y
    }

    static get zero() {
        return new Vector2d(0, 0)
    }

    static fromFunc(f) {
        return new Vector2d(f(0), f(1))
    }

    copy() {
        return new Vector2d(this.x, this.y)
    }

    add(v) {
        return new Vector2d(this.x + v.x, this.y + v.y)
    }

    iadd(v) {
        this.x += v.x
        this.y += v.y
    }

    sub(v) {
        return new Vector2d(this.x - v.x, this.y - v.y)
    }

    isub(v) {
        this.x -= v.x
        this.y -= v.y
    }

    mul(v) {
        return new Vector2d(this.x * v.x, this.y * v.y)
    }

    imul(v) {
        this.x *= v.x
        this.y *= v.y
    }

    div(v) {
        return new Vector2d(this.x / v.x, this.y / v.y)
    }

    idiv(v) {
        this.x /= v.x
        this.y /= v.y
    }

    get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }

    get normalized() {
        let m = this.length
        return new Vector2d(this.x / m, this.y / m)
    }
    
    scale(x) {
        return new Vector2d(this.x * x, this.y * x)
    }

    lerp(v, t) {
        let delta = v.sub(this)
        return this.add(delta.scale(t))
    }

    dot(v) {
        return this.x * v.x + this.y * v.y
    }

    iscale(x) {
        this.x *= x
        this.y *= x
    }

    distance(v) {
        return this.sub(v).length
    }

    cross(v) {
        return this.x * v.y - this.y * v.x
    }

    round() {
        return new Vector2d(Math.round(this.x), Math.round(this.y))
    }

    static fromAngle(angle) {
        return new Vector2d(Math.cos(angle), Math.sin(angle))
    }

    static fromPolar(mag, angle) {
        return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
    }

    static fromArray(arr) {
        return new Vector2d(arr[0], arr[1])
    }

    set(x, y) {
        if (x instanceof Vector2d && y == undefined) {
            this.x = x.x
            this.y = x.y
        } else {
            this.x = x
            this.y = y
        }
        
    }

    addX(x) {
        return new Vector2d(this.x + x, this.y)
    }

    addY(y) {
        return new Vector2d(this.x, this.y + y)
    }

    rotate(angle) {
        let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
        let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
        return new Vector2d(x, y)
    }

    irotate(angle) {
        let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
        let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
        this.x = x
        this.y = y
    }

    static random() {
        let direction = Math.random() * Math.PI * 2
        return Vector2d.fromAngle(direction)
    }

    get angle() {
        return Math.atan2(this.y, this.x)
    }

    angleDifference(v) {
        return angleDifference(this.angle, v.angle)
    }

    angleTo(v) {
        return Math.atan2(v.y - this.y, v.x - this.x)
    }

    equals(v) {
        return this.x == v.x && this.y == v.y
    }

    map(f) {
        return new Vector2d(f(this.x), f(this.y))
    }

    product() {
        return this.x * this.y
    }

    get array() {
        return [this.x, this.y]
    }

    get min() {
        return Math.min(...this.array)
    }

    get max() {
        return Math.max(...this.array)
    }

    abs() {
        return new Vector2d(Math.abs(this.x), Math.abs(this.y))
    }

    toArray() {
        return [this.x, this.y]
    }

    static fromEvent(event, element) {
        let x = 0, y = 0

        if (event.touches && event.touches[0]) {
            x = event.touches[0].clientX
            y = event.touches[0].clientY
        } else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
            x = event.originalEvent.changedTouches[0].clientX
            y = event.originalEvent.changedTouches[0].clientY
        } else if (event.clientX !== undefined && event.clientY !== undefined) {
            x = event.clientX
            y = event.clientY
        } else if (event.changedTouches && event.changedTouches.length > 0) {
            x = event.changedTouches[0].clientX
            y = event.changedTouches[0].clientY
        }

        const rect = element.getBoundingClientRect()
        return new Vector2d(x - rect.left, y - rect.top)
    }

}

function distancePointLineSegment(point, lineStart, lineEnd) {
    const delta = lineEnd.sub(lineStart)
    const deltaLength = delta.length
    if (deltaLength == 0) {
        return point.distance(lineStart)
    }

    const t = Math.max(0, Math.min(1, point.sub(lineStart).dot(delta) / deltaLength ** 2))
    const projection = lineStart.add(delta.scale(t))
    return point.distance(projection)
}

function calcLineIntersection(s1, e1, s2, e2) {
    // get intersection point between two lines defined each
    // by start and end position (start n, end n)
    // algorithm found on https://paulbourke.net/geometry/pointlineplane/

    const denominator = (e2.y - s2.y)*(e1.x - s1.x) - (e2.x - s2.x)*(e1.y - s1.y)
    if (denominator == 0) {
        return null
    }

    const ua = ((e2.x - s2.x) * (s1.y - s2.y) - (e2.y - s2.y) * (s1.x - s2.x)) / denominator
    const ub = ((e1.x - s1.x) * (s1.y - s2.y) - (e1.y - s1.y) * (s1.x - s2.x)) / denominator

    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null
    return new Vector2d(
        s1.x + ua * (e1.x - s1.x),
        s1.y + ua * (e1.y - s1.y),
    )
}

class Vector3d {
	
	constructor(x, y, z) {
		this.x = x
		this.y = y
		this.z = z
	}
	
	get length() {
		return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z)
	}

    get normalized() {
        return this.div(this.length)
    }

    get array() {
        return [this.x, this.y, this.z]
    }

    get min() {
        return Math.min(...this.array)
    }

    get max() {
        return Math.max(...this.array)
    }

    copy() {
        return new Vector3d(this.x, this.y, this.z)
    }
	
	add(other) {
		return new Vector3d(
			this.x + other.x,
			this.y + other.y,
			this.z + other.z
		)
	}

    lerp(other, t) {
        return this.add(other.sub(this).mul(t))
    }

    distanceTo(other) {
        return this.sub(other).length
    }
	
	mul(scalar) {
		return new Vector3d(
			this.x * scalar,
			this.y * scalar,
			this.z * scalar
		)
	}
	
	sub(other) {
		return this.add(other.mul(-1))
	}
	
	div(scalar) {
		return this.mul(1 / scalar)
	}
	
	cross(other) {
		return new Vector3d(
			this.y * other.z - this.z * other.y,
			this.z * other.x - this.x * other.z,
			this.x * other.y - this.y * other.x
		)
	}
	
	dot(other) {
		return (
			this.x * other.x +
			this.y * other.y +
			this.z * other.z
		)
	}
	
	get angleX() {
		return Math.atan2(this.z, this.y)
	}
	
	rotateX(angle) {
        let cos = Math.cos(angle)
        let sin = Math.sin(angle)
        return new Vector3d(
            this.x,
            this.y * cos - this.z * sin,
            this.y * sin + this.z * cos
        )
	}

    setAngleX(angle) {
        return this.rotateX(angle - this.angleX)
    }

    get angleY() {
        return Math.atan2(this.z, this.x)
    }

    rotateY(angle) {
        let cos = Math.cos(angle)
        let sin = Math.sin(angle)
        return new Vector3d(
            this.x * cos - this.z * sin,
            this.y,
            this.x * sin + this.z * cos
        )
    }

    setAngleY(angle) {
        return this.rotateY(angle - this.angleY)
    }

    get angleZ() {
        return Math.atan2(this.y, this.x)
    }

    rotateZ(angle) {
        let cos = Math.cos(angle)
        let sin = Math.sin(angle)
        return new Vector3d(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos,
            this.z
        )
    }

    setAngleZ(angle) {
        return this.rotateZ(angle - this.angleZ)
    }

    rotateUp(angle) {
        let temp = this.angleZ
        return this.setAngleZ(0).rotateY(angle).setAngleZ(temp)
    }

    setAngleUp(angle) {
        let temp = this.angleZ
        return this.setAngleZ(0).setAngleY(angle).setAngleZ(temp)
    }

    get angleUp() {
        return this.setAngleZ(0).angleY
    }

    rotateRight(angle) {
        return this.rotateZ(angle)
        let temp = this.angleUpS
        return this.setAngleUp(0).rotateZ(angle).setAngleUp(temp)
    }

    apply(func) {
        return new Vector3d(
            func(this.x),
            func(this.y),
            func(this.z)
        )
    }

    round() {
        return this.apply(Math.round)
    }

    floor() {
        return this.apply(Math.floor)
    }

}

const ZeroVector2d = new Vector2d(0, 0)
const UnitVector2d = new Vector2d(1, 1)
const ZeroVector3d = new Vector3d(0, 0, 0)
const UnitVector3d = new Vector3d(1, 1, 1)

class HighscoreApi {

    static baseUrl = "./api/"
    static tempName = null
    static tempGame = null
    static tempPassword = null
	static username = null

    static async req(url, data) {
        url = terminal.baseUrl + this.baseUrl + url + ".php?"
        for (let key in data)
            url += encodeURIComponent(key) + "=" + encodeURIComponent(data[key]) + "&"
        let response = await fetch(url.slice(0, -1))
        return await response.text()
    }

    static async getHighscores(game) {
        let data = await this.req("get_highscores", {game})
        try {
            return JSON.parse(data)
        } catch (e) {
            if (e instanceof SyntaxError) {
                throw new Error("Highscore-Api returned invalid data. Are you hosting the website locally?")
            } else {
                throw e
            }
        }
    }

    static async addHighscore(game, name, score) {
        await this.req("upload_highscore", {game, name, score})
    }

    static async removeHighscore(uid) {
        if (!this.savedPassword) {
            throw new Error("Permission denied [E2]")
        }

        await this.req("remove_highscore", {password: this.savedPassword, uid})
    }
    
    static async getUsername() {
    	if (this.username) {
    		this.tempName = this.username
    		return
    	}
    
    	this.tempName = await terminal.prompt("[highscores] Your name: ")
        while (!/^[a-zA-Z0-9_\-]{1,20}$/.test(this.tempName)) {
            terminal.printError("Name must be 1-20 characters long and only contain letters, numbers, dashes and underscores")
            this.tempName = await terminal.prompt("[highscores] Your name: ")
        }

        terminal.print("Tip: You can set your username permanently using ")
        terminal.printCommand(`name set ${this.tempName}`)
    }

    static async registerProcess(game, {
        ask=true
    }={}) {
        if (ask) {
            try {
                await terminal.acceptPrompt("[highscores] Do you want to upload your score?", false)
            } catch {
                terminal.printLine("[highscores] Score not uploaded")
                this.tempGame = null
                return
            }
        }

        this.tempGame = game
        await this.getUsername()
    }

    static async getRank(game, score, scores) {
        let highscores = scores ?? await this.getHighscores(game)
        let rank = 1
        let lastScore = null
        for (let highscore of highscores) {
            if (lastScore != null && lastScore == highscore.score) {
                continue
            }
            if (highscore.score > score) rank++
            lastScore = highscore.score
        }
        return rank
    }

    static async uploadScore(score) {
        if (this.tempGame == null) return
        await this.addHighscore(this.tempGame, this.tempName, score)

        let rank = await this.getRank(this.tempGame, score)

        if (rank == 1) {
            terminal.printSuccess("You got the new highscore! Congratulations!")
        } else if (rank == 2) {
            terminal.printSuccess("You got the second best score! Congratulations!")
        } else if (rank == 3) {
            terminal.printSuccess("You got the third best score! Congratulations!")
        } else {
            terminal.printSuccess("You got rank " + rank)
        }

        terminal.printLine("[highscores] The highscore won't be public until approved (to prevent abuse).")
        terminal.print("You can view the public highscores using ")
        terminal.printCommand("highscores " + this.tempGame)

        this.tempGame = null
    }

    static async getHighscore(game) {
        let highscores = await this.getHighscores(game)
        if (highscores.length == 0) return null
        return highscores[0]
    }

    static get savedPassword() {
        return localStorage.getItem("highscore_password")
    }

    static async getUnconfirmedHighscores() {
        if (!this.savedPassword) {
            throw new Error("Permission denied")
        }

        let data = await this.req("get_unconfirmed_highscores", {password: this.savedPassword})
        return JSON.parse(data)
    }

    static async confirmHighscore(uid, value=1) {
        if (!this.savedPassword) {
            throw new Error("Permission denied")
        }

        await this.req("confirm_highscore",
            {uid, password: this.savedPassword, value})
    }

    static async loginAdmin(silent=false) {
        if (this.tempPassword != null) return

        let password = null

        if (localStorage.getItem("highscore_password") != null) {
            password = localStorage.getItem("highscore_password")
        } else {
            password = await terminal.prompt("Password: ", {password: true})
        }

        let data = await this.req("admin", {confirm: true, password})
        if (data === "Confirmed") {
            if (!silent) {
                terminal.printSuccess("Logged in as admin")
            }
            this.tempPassword = password
            localStorage.setItem("highscore_password", password)
        } else {
            localStorage.removeItem("highscore_password")
            throw new Error("Permission denied [E1]")
        }
    }

    static async removeHighscoreProcess() {
        await this.loginAdmin()
    }
    
    static async setUsername(newUsername) {
    	this.username = newUsername
    	localStorage.setItem("highscore_username", newUsername)
    }
    
    static async resetUsername() {
        this.username = null
    	localStorage.removeItem("highscore_username")
    }
    
    static async loadUsernameFromLocalStorage() {
    	this.username = localStorage.getItem("highscore_username") || null
    }

}

class CanvasDrawer {

    static async promptOptions(context, {
        options=[
            "Respawn",
            "Upload Score",
            "Exit"
        ],
        infoLines=[]
    }={}) {
        let promptActive = true

        let canvas = context.canvas

        let extraLines = [
            "Use arrow keys to select an option",
            "Press enter to select an option"
        ].concat(infoLines).concat([""])

        const drawBackground = () => {
            context.fillStyle = "black"
            context.fillRect(0, 0, canvas.width, canvas.height)
        }

        let optionsIndex = 0

        const drawOptions = () => {
            let textSize = 20
            let textMargin = 10
            let textHeight = textSize + textMargin
            context.font = textSize + "px monospace"
            context.textAlign = "center"
            context.textBaseline = "middle"
            context.fillStyle = "white"

            let lines = extraLines.concat(options)
            lines[optionsIndex + extraLines.length] = `> ${lines[optionsIndex + extraLines.length]} <`

            let yOffset = canvas.height / 2 - textHeight * (lines.length - 1) / 2
            for (let i = 0; i < lines.length; i++) {
                context.fillText(
                    lines[i],
                    canvas.width / 2,
                    yOffset + textHeight * i
                )
            }
        }

        const draw = () => {
            drawBackground()
            drawOptions()
        }

        terminal.onInterrupt(() => promptActive = false)

        terminal.window.addEventListener("keydown", e => {
            if (!promptActive) return

            if (e.key == "ArrowUp" || e.key == "ArrowLeft") {
                optionsIndex--
                e.preventDefault()
                if (optionsIndex < 0) optionsIndex = options.length - 1
            } else if (e.key == "ArrowDown" || e.key == "ArrowRight") {
                optionsIndex++
                e.preventDefault()
                if (optionsIndex >= options.length) optionsIndex = 0
            }

            if (e.key == "Enter") {
                promptActive = false
                e.preventDefault()
            }

            draw()
        })

        draw()

        while (promptActive) {
            await terminal.sleep(100)
            draw()
        }

        return optionsIndex
    }

}

HighscoreApi.loadUsernameFromLocalStorage()

function printSquareCanvas({widthChars=60}={}) {
    let canvas = terminal.document.createElement("canvas")
    let sizePx = terminal.charWidth * widthChars
    canvas.width = sizePx
    canvas.height = sizePx
    terminal.parentNode.appendChild(canvas)
    return canvas
}

terminal.modules.game = {
    Vector2d,
    Vector3d,
    distancePointLineSegment,
    calcLineIntersection,
    UnitVector2d, UnitVector3d, ZeroVector2d, ZeroVector3d,
    angleDifference,
    HighscoreApi,
    CanvasDrawer,
    addEventListener: terminal.window.addEventListener,
    removeEventListener: terminal.window.removeEventListener,
    requestAnimationFrame: terminal.window.requestAnimationFrame,
    setInterval: terminal.window.setInterval,
    clearInterval: terminal.window.clearInterval,
    setTimeout: terminal.window.setTimeout,
    clearTimeout: terminal.window.clearTimeout,
    printSquareCanvas: printSquareCanvas
}

// ------------------- js/modules/geometry2d.js --------------------
class UnknownGeometry2dComparisonError extends Error {

    constructor(message = "", ...args) {
        super(message, ...args)
        this.message = message + " cannot be compared (yet?)"
    }

}

class NotImplementedGeometry2dError extends Error {

    constructor(message = "", ...args) {
        super(message, ...args)

        if (message.length > 0) {
            this.message = message + " has not been implemented (yet?)"
        } else {
            this.message = "Not implemented (yet?)"
        }
    }

}


class Geometry2dObject {

    constructor(type) {
        this.type = type
    }

    intersect(geometry2dObject) {
        throw NotImplementedGeometry2dError()
    }

    distance(geometry2dObject) {
        throw NotImplementedGeometry2dError()
    }

    copy() {
        throw NotImplementedGeometry2dError()
    }

    equals(geometry2dObject) {
        if (geometry2dObject.type != this.type) {
            return false
        }
        return this._equalsSameType(geometry2dObject)
    }

    _equalsSameType() {
        throw NotImplementedGeometry2dError()
    }

}

class Point extends Geometry2dObject {

    constructor(x, y) {
        super("Point")
        this.x = x
        this.y = y
    }

    static get zero() {
        return new Point(0, 0)
    }

    static get unit01() {
        return new Point(0, 1)
    }

    static get unit10() {
        return new Point(1, 0)
    }

    static get unit11() {
        return new Point(1, 1)
    }

    static fromFunc(f) {
        return new Point(f(0), f(1))
    }

    applyFunc(f) {
        return new Point(f(this.x), f(this.y))
    }

    iapplyFunc(f) {
        this.x = f(this.x)
        this.y = f(this.y)
    }

    copy() {
        return new Point(this.x, this.y)
    }

    add(v) {
        return new Point(this.x + v.x, this.y + v.y)
    }

    iadd(v) {
        this.x += v.x
        this.y += v.y
    }

    sub(v) {
        return new Point(this.x - v.x, this.y - v.y)
    }

    isub(v) {
        this.x -= v.x
        this.y -= v.y
    }

    mul(v) {
        return new Point(this.x * v.x, this.y * v.y)
    }

    imul(v) {
        this.x *= v.x
        this.y *= v.y
    }

    div(v) {
        return new Point(this.x / v.x, this.y / v.y)
    }

    idiv(v) {
        this.x /= v.x
        this.y /= v.y
    }

    get length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }

    get normalized() {
        let m = this.length
        return new Point(this.x / m, this.y / m)
    }
    
    scale(x) {
        return new Point(this.x * x, this.y * x)
    }

    lerp(v, t) {
        let delta = v.sub(this)
        return this.add(delta.scale(t))
    }

    ilerp(v, t) {
        let delta = v.sub(this)
        this.iadd(delta.scale(t))
    }

    dot(v) {
        return this.x * v.x + this.y * v.y
    }

    iscale(x) {
        this.x *= x
        this.y *= x
    }

    cross(v) {
        return this.x * v.y - this.y * v.x
    }

    round() {
        return new Point(Math.round(this.x), Math.round(this.y))
    }

    static fromAngle(angle) {
        return new Point(Math.cos(angle), Math.sin(angle))
    }

    static fromPolar(mag, angle) {
        return new Point(mag * Math.cos(angle), mag * Math.sin(angle))
    }

    static fromArray(arr) {
        return new Point(arr[0], arr[1])
    }

    set(x, y) {
        if (x instanceof Point && y == undefined) {
            this.x = x.x
            this.y = x.y
        } else {
            this.x = x
            this.y = y
        }
        
    }

    addX(x) {
        return new Point(this.x + x, this.y)
    }

    addY(y) {
        return new Point(this.x, this.y + y)
    }

    rotate(angle) {
        let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
        let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
        return new Point(x, y)
    }

    irotate(angle) {
        let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
        let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
        this.x = x
        this.y = y
    }

    static randomAngle() {
        let direction = Math.random() * Math.PI * 2
        return Point.fromAngle(direction)
    }

    static random() {
        return new Point(Math.random(), Math.random())
    }

    get angle() {
        return Math.atan2(this.y, this.x)
    }

    angleDifference(v) {
        return angleDifference(this.angle, v.angle)
    }

    angleTo(v) {
        return Math.atan2(v.y - this.y, v.x - this.x)
    }

    equals(v) {
        return this.x == v.x && this.y == v.y
    }

    map(f) {
        return new Point(f(this.x), f(this.y))
    }

    product() {
        return this.x * this.y
    }

    get array() {
        return [this.x, this.y]
    }

    get min() {
        return Math.min(...this.array)
    }

    get max() {
        return Math.max(...this.array)
    }

    abs() {
        return new Point(Math.abs(this.x), Math.abs(this.y))
    }

    toArray() {
        return [this.x, this.y]
    }

    static fromEvent(event, element) {
        let x = 0, y = 0

        if (event.touches && event.touches[0]) {
            x = event.touches[0].clientX
            y = event.touches[0].clientY
        } else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
            x = event.originalEvent.changedTouches[0].clientX
            y = event.originalEvent.changedTouches[0].clientY
        } else if (event.clientX !== undefined && event.clientY !== undefined) {
            x = event.clientX
            y = event.clientY
        } else if (event.changedTouches && event.changedTouches.length > 0) {
            x = event.changedTouches[0].clientX
            y = event.changedTouches[0].clientY
        }

        const rect = element.getBoundingClientRect()
        return new Point(x - rect.left, y - rect.top)
    }

    distance(geometry2dObject) {
        if (geometry2dObject.type == "Line") {
            return geometry2dObject.distance(this)
        } else if (geometry2dObject.type == "LineSegment") {
            return geometry2dObject.distance(this)
        } else if (geometry2dObject.type == "Point") {
            return this.sub(geometry2dObject).length
        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.distance(this)
        } else {
            throw UnknownGeometry2dComparisonError()
        }
    }

    intersect(geometry2dObject) {
        if (geometry2dObject.type == "Line") {
            return geometry2dObject.distance(this) == 0 ? this.copy() : null
        } else if (geometry2dObject.type == "LineSegment") {
            return geometry2dObject.distance(this) == 0 ? this.copy() : null
        } else if (geometry2dObject.type == "Point") {
            return this.sub(v).length == 0 ? this.copy() : null
        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.distance(this) == 0 ? this.copy() : null
        } else {
            throw UnknownGeometry2dComparisonError()
        }
    }

    _equalsSameType(point) {
        return this.x == point.x && this.y == point.y
    }

}

class Line extends Geometry2dObject {

    constructor(point, angle) {
        super("Line")
        this.point = point
        this.angle = angle
    }

    get directionVector() {
        return Point.fromAngle(this.angle)
    }

    copy() {
        return new Line(this.point.copy(), this.angle)
    }

    intersect(geometry2dObject) {
        if (geometry2dObject.type == "Line") {
            let firstLinePoint = this.point
            let firstLineDirection = this.directionVector
            let secondLinePoint = geometry2dObject.point
            let secondLineDirection = new Point(
                Math.cos(geometry2dObject.angle),
                Math.sin(geometry2dObject.angle)
            )

            let crossOfDirections = firstLineDirection.cross(secondLineDirection)
            if (crossOfDirections === 0) {
                return null
            }

            let vectorBetweenLinePoints = secondLinePoint.sub(firstLinePoint)
            let intersectionParameterOnFirstLine = vectorBetweenLinePoints.cross(secondLineDirection) / crossOfDirections

            return firstLinePoint.add(
                firstLineDirection.scale(intersectionParameterOnFirstLine)
            )
        } else if (geometry2dObject.type == "LineSegment") {
            let infiniteLinePoint = this.point
            let infiniteLineDirection = this.directionVector
            let segmentStart = geometry2dObject.startPoint
            let segmentEnd = geometry2dObject.endPoint
            let segmentVector = segmentEnd.sub(segmentStart)

            let crossOfDirections = infiniteLineDirection.cross(segmentVector)
            if (crossOfDirections === 0) {
                return null
            }

            let vectorFromLineToSegmentStart = 
                segmentStart.sub(infiniteLinePoint)

            let segmentParameter = 
                vectorFromLineToSegmentStart.cross(infiniteLineDirection)
                / crossOfDirections

            if (segmentParameter < 0 || segmentParameter > 1) {
                return null
            }

            let lineParameter = 
                vectorFromLineToSegmentStart.cross(segmentVector)
                / crossOfDirections

            return infiniteLinePoint.add(
                infiniteLineDirection.scale(lineParameter)
            )
        } else if (geometry2dObject.type == "Point") {
            return geometry2dObject.intersect(this)

        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.intersect(this)

        } else {
            throw UnknownGeometry2dComparisonError()
        }
    }

    distance(geometry2dObject) {
        if (geometry2dObject.type === "Point") {
            // distance from point to infinite line
            let pointToProject = geometry2dObject
            let basePointOnLine = this.point
            let directionUnitVector = this.directionVector  // already unit length
            let vectorFromLineToPoint = pointToProject.sub(basePointOnLine)
            let perpendicularMagnitude = 
                Math.abs(vectorFromLineToPoint.cross(directionUnitVector))
            return perpendicularMagnitude

        } else if (geometry2dObject.type === "Line") {
            // distance between two infinite lines
            let otherLinePoint = geometry2dObject.point
            let otherLineDirection = new Point(
                Math.cos(geometry2dObject.angle),
                Math.sin(geometry2dObject.angle)
            )
            let crossOfDirections = 
                this.directionVector.cross(otherLineDirection)
            if (crossOfDirections === 0) {
                // parallel lines → distance is point-to-line
                return this.distanceTo(otherLinePoint)
            }
            // non-parallel lines intersect → distance is zero
            return 0

        } else if (geometry2dObject.type === "LineSegment") {
            // distance from infinite line to finite segment:
            // minimal distance to either endpoint
            let startPointOfSegment = geometry2dObject.startPoint
            let endPointOfSegment = geometry2dObject.endPoint
            let distanceToStart = this.distanceTo(startPointOfSegment)
            let distanceToEnd = this.distanceTo(endPointOfSegment)
            return Math.min(distanceToStart, distanceToEnd)

        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.distance(this)

        } else {
            throw new UnknownGeometry2dComparisonError()
        }
    }

    paramaterise(t) {
        return this.point.add(this.directionVector.scale(t))
    }

    _equalsSameType(line) {
        return this.angle == line.angle && this.point.equals(line.point)
    }

}

class LineSegment extends Geometry2dObject {

    constructor(startPoint, endPoint) {
        super("LineSegment")
        this.startPoint = startPoint
        this.endPoint = endPoint
    }

    toArray() {
        return [this.startPoint, this.endPoint]
    }

    intersect(geometry2dObject) {
        if (geometry2dObject.type == "LineSegment") {
            // algorithm found on https://paulbourke.net/geometry/pointlineplane/
            const [s1, e1] = this.toArray()
            const [s2, e2] = geometry2dObject.toArray()

            const denominator = (e2.y - s2.y)*(e1.x - s1.x) - (e2.x - s2.x)*(e1.y - s1.y)
            if (denominator == 0) {
                return null
            }

            const ua = ((e2.x - s2.x) * (s1.y - s2.y) - (e2.y - s2.y) * (s1.x - s2.x)) / denominator
            const ub = ((e1.x - s1.x) * (s1.y - s2.y) - (e1.y - s1.y) * (s1.x - s2.x)) / denominator

            if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null
            return new Point(
                s1.x + ua * (e1.x - s1.x),
                s1.y + ua * (e1.y - s1.y),
            )

        } else if (geometry2dObject.type == "Line") {
            return geometry2dObject.intersect(this)

        } else if (geometry2dObject.type == "Point") {
            return geometry2dObject.intersect(this)

        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.intersect(this)

        } else {
            throw UnknownGeometry2dComparisonError()
        }
    }

    distance(geometry2dObject) {
        if (geometry2dObject.type === "Point") {
            // distance from point to this segment
            let point = geometry2dObject
            let segmentVector = this.endPoint.sub(this.startPoint)
            let lengthSquared = segmentVector.dot(segmentVector)
            if (lengthSquared === 0) {
                // degenerate segment → just a point
                return point.distance(this.startPoint)
            }
            // project (point – start) onto segmentVector
            let t = point.sub(this.startPoint).dot(segmentVector) / lengthSquared
            if (t < 0) {
                return point.distance(this.startPoint)
            } else if (t > 1) {
                return point.distance(this.endPoint)
            }
            let projection = this.startPoint.add(segmentVector.scale(t))
            return point.distance(projection)

        } else if (geometry2dObject.type === "Line") {
            // distance from infinite line to this segment
            // delegate to line.distanceTo(segment)
            return geometry2dObject.distanceTo(this)

        } else if (geometry2dObject.type === "LineSegment") {
            // minimal distance between two finite segments
            // if they intersect, distance is zero
            if (this.intersect(geometry2dObject) !== null) {
                return 0
            }
            // otherwise, consider endpoint‐to‐segment distances
            let otherSegment = geometry2dObject
            let distances = [
                this.distanceTo(otherSegment.startPoint),
                this.distanceTo(otherSegment.endPoint),
                otherSegment.distanceTo(this.startPoint),
                otherSegment.distanceTo(this.endPoint)
            ]
            return Math.min(...distances)

        } else if (geometry2dObject.type === "GeometryObjectCollection") {
            return geometry2dObject.distance(this)

        } else {
            throw new UnknownGeometry2dComparisonError()
        }
    }
    
    paramaterise(t) {
        if (t < 0 || t > 1) {
            throw Error("Invalid t value")
        }
        return this.startPoint.lerp(this.endPoint, t)
    }

    _equalsSameType(lineSegment) {
        return this.startPoint.equals(lineSegment.startPoint) && this.endPoint.equals(lineSegment.endPoint)
    }

}

class GeometryObjectCollection extends Geometry2dObject {

    constructor(objects) {
        super("GeometryObjectCollection")
        this.objects = objects ?? []
    }

    get size() {
        return this.objects.length
    }

    addObject(object) {
        this.objects.push(object)
    }

    addObjects(objects) {
        this.objects.push(...objects)
    }

    concat(geometryObjectCollection) {
        const collection = this.copy()
        for (const obj of geometryObjectCollection.objects) {
            collection.addObject(obj.copy())
        }
        return collection
    }

    selfIntersect() {
        const intersections = []
        for (let i = 0; i < this.size; i++) {
            for (let j = 0; j < this.size; j++) {
                if (i <= j) continue
                    
                const intersection = this.objects[i].intersect(this.objects[j])
                if (intersection !== null) {
                    intersections.push(intersection)
                }
            }
        }
        return new GeometryObjectCollection(intersections)
    }

    intersect(geometry2dObject) {
        const intersections = []
        for (const object of this.objects) {
            const intersection = object.intersect(geometry2dObject)
            if (intersection !== null) {
                intersections.push(intersection)
            }
        }
        return new GeometryObjectCollection(intersections)
    }

    distance(geometry2dObject) {
        let minDistance = Infinity
        for (const object of this.objects) {
            const distance = object.distance(geometry2dObject)
            if (distance < minDistance) {
                minDistance = distance
            }
        }
        return minDistance
    }

    copy() {
        return new GeometryObjectCollection(
            this.objects.map(o => o.copy())
        )
    }

    _equalsSameType(objectCollection) {
        return (
            this.length == objectCollection.length
            && objectCollection.objects.every((o, i) => o.equals(this.objects[i]))
        )
    }

}

terminal.modules.geometry2d = {
    Point,
    Line,
    LineSegment,
    Geometry2dObject,
    GeometryObjectCollection,
    UnknownGeometry2dComparisonError,
    NotImplementedGeometry2dError
}

// ------------------- js/modules/mathenv.js --------------------
class JsEnvironment {
    constructor() {
        this.iframe = document.createElement("iframe")
        this.iframe.style.display = "none"
        document.body.appendChild(this.iframe)
        this.document = this.iframe.contentDocument || this.iframe.contentWindow.document
    }

    eval(code) {
        try {
            let evaluation = this.iframe.contentWindow.eval(code)
            return [evaluation, null]
        } catch (e) {
            return [null, `${e.name}: ${e.message}`]
        }
    }

    getVars() {
        return this.iframe.contentWindow
    }

    getValue(name) {
        return this.getVars()[name]
    }

    setValue(name, value) {
        this.getVars()[name] = value
    }
}

terminal.modules.mathenv = new JsEnvironment()
terminal.modules.mathenv.setValue("sin", Math.sin)
terminal.modules.mathenv.setValue("cos", Math.cos)
terminal.modules.mathenv.setValue("tan", Math.tan)
terminal.modules.mathenv.setValue("asin", Math.asin)
terminal.modules.mathenv.setValue("acos", Math.acos)
terminal.modules.mathenv.setValue("atan", Math.atan)
terminal.modules.mathenv.setValue("atan2", Math.atan2)
terminal.modules.mathenv.setValue("sinh", Math.sinh)
terminal.modules.mathenv.setValue("cosh", Math.cosh)
terminal.modules.mathenv.setValue("tanh", Math.tanh)
terminal.modules.mathenv.setValue("asinh", Math.asinh)
terminal.modules.mathenv.setValue("acosh", Math.acosh)
terminal.modules.mathenv.setValue("atanh", Math.atanh)
terminal.modules.mathenv.setValue("exp", Math.exp)
terminal.modules.mathenv.setValue("log", Math.log)
terminal.modules.mathenv.setValue("log10", Math.log10)
terminal.modules.mathenv.setValue("sqrt", Math.sqrt)
terminal.modules.mathenv.setValue("abs", Math.abs)
terminal.modules.mathenv.setValue("ceil", Math.ceil)
terminal.modules.mathenv.setValue("floor", Math.floor)
terminal.modules.mathenv.setValue("round", Math.round)
terminal.modules.mathenv.setValue("PI", Math.PI)
terminal.modules.mathenv.setValue("e", Math.E)
terminal.modules.mathenv.setValue("E", Math.E)

terminal.modules.mathenv.setValue("sum", (startX, endX, func) => {
    let sum = 0
    for (let x = startX; x <= endX; x++) {
        sum += func(x)
    }
    return sum
})

terminal.modules.mathenv.setValue("sha256", function sha256(ascii) {
    // from https://geraintluff.github.io/sha256/
    
	function rightRotate(value, amount) {
		return (value>>>amount) | (value<<(32 - amount));
	};
	
	var mathPow = Math.pow;
	var maxWord = mathPow(2, 32);
	var lengthProperty = 'length'
	var i, j; // Used as a counter across the whole file
	var result = ''

	var words = [];
	var asciiBitLength = ascii[lengthProperty]*8;
	
	//* caching results is optional - remove/add slash from front of this line to toggle
	// Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes
	// (we actually calculate the first 64, but extra values are just ignored)
	var hash = sha256.h = sha256.h || [];
	// Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes
	var k = sha256.k = sha256.k || [];
	var primeCounter = k[lengthProperty];
	/*/
	var hash = [], k = [];
	var primeCounter = 0;
	//*/

	var isComposite = {};
	for (var candidate = 2; primeCounter < 64; candidate++) {
		if (!isComposite[candidate]) {
			for (i = 0; i < 313; i += candidate) {
				isComposite[i] = candidate;
			}
			hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;
			k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;
		}
	}
	
	ascii += '\x80' // Append Ƈ' bit (plus zero padding)
	while (ascii[lengthProperty]%64 - 56) ascii += '\x00' // More zero padding
	for (i = 0; i < ascii[lengthProperty]; i++) {
		j = ascii.charCodeAt(i);
		if (j>>8) return; // ASCII check: only accept characters in range 0-255
		words[i>>2] |= j << ((3 - i)%4)*8;
	}
	words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);
	words[words[lengthProperty]] = (asciiBitLength)
	
	// process each chunk
	for (j = 0; j < words[lengthProperty];) {
		var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration
		var oldHash = hash;
		// This is now the undefinedworking hash", often labelled as variables a...g
		// (we have to truncate as well, otherwise extra entries at the end accumulate
		hash = hash.slice(0, 8);
		
		for (i = 0; i < 64; i++) {
			var i2 = i + j;
			// Expand the message into 64 words
			// Used below if 
			var w15 = w[i - 15], w2 = w[i - 2];

			// Iterate
			var a = hash[0], e = hash[4];
			var temp1 = hash[7]
				+ (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1
				+ ((e&hash[5])^((~e)&hash[6])) // ch
				+ k[i]
				// Expand the message schedule if needed
				+ (w[i] = (i < 16) ? w[i] : (
						w[i - 16]
						+ (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0
						+ w[i - 7]
						+ (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1
					)|0
				);
			// This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble
			var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0
				+ ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj
			
			hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()
			hash[4] = (hash[4] + temp1)|0;
		}
		
		for (i = 0; i < 8; i++) {
			hash[i] = (hash[i] + oldHash[i])|0;
		}
	}

    const hashArray = []
	
	for (i = 0; i < 8; i++) {
		for (j = 3; j + 1; j--) {
			var b = (hash[i]>>(j*8))&255
            hashArray.push(b)
		}
	}

	return hashArray;
})

terminal.modules.mathenv.setValue("terminal", terminal)

// ------------------- js/modules/matrix.js --------------------
const MatrixCellType = {
    Numeric: 0,
    Expression: 1
}

class MatrixCell {

    constructor(value) {
        this.value = value
    }

    get type() {
        return (typeof this.value === "number") ? MatrixCellType.Numeric : MatrixCellType.Expression
    }

    static toMatrixCell(object) {
        if (object instanceof MatrixCell) {
            return object
        } else {
            return new MatrixCell(object)
        }
    }

    static get Default() {
        return new MatrixCell(0)
    }

    toString() {
        return this.value.toString()
    }

    toSimplifiedString() {
        if (this.type != MatrixCellType.Numeric) {
            return this.toString()
        }

        if (Number.isInteger(this.value)) {
            return this.value.toString()
        }

        if (this.value == 0) {
            return "0"
        }

        // find fraction approximation (very inefficiently!)
        // only works for denominator < 10000

        let bestFraction = null
        let bestError = Infinity
        let bestNumerator = null
        let bestDenominator = null
        for (let denominator = 1; denominator < 10000; denominator++) {
            let numerator = Math.round(this.value * denominator)
            const newValue = numerator / denominator
            
            const error = Math.abs(this.value - newValue)

            if (error == 0) {
                return `${numerator}/${denominator}`
            }

            if (error < bestError) {
                bestError = error
                bestFraction = `${numerator}/${denominator}`
                bestNumerator = numerator
                bestDenominator = denominator
            }
        }

        if (bestNumerator == 0) {
            return "0"
        }

        if (bestDenominator == 1) {
            return bestNumerator.toString()
        }

        if (bestError > 1e-5) {
            return this.toString()
        }

        return bestFraction
    }

    _arithmeticFunc(other, f, templateString) {
        other = MatrixCell.toMatrixCell(other)
        if (this.type == MatrixCellType.Numeric && other.type == MatrixCellType.Numeric) {
            return new MatrixCell(f(this.value, other.value))
        } else {
            let str = `(${templateString})`
                .replace("$1", this.value)
                .replace("$2", other.value)
            return new MatrixCell(str)
        } 
    }

    mul(other) {
        return this._arithmeticFunc(other, (x, y) => x * y, "$1*$2")
    }

    add(other) {
        return this._arithmeticFunc(other, (x, y) => x + y, "$1+$2")
    }

    sub(other) {
        return this._arithmeticFunc(other, (x, y) => x - y, "$1-$2")
    }

    div(other) {
        return this._arithmeticFunc(other, (x, y) => x / y, "$1/$2")
    }

    copy() {
        return new MatrixCell(this.value)
    }

    simplify(steps=100) {
        if (this.type == MatrixCellType.Numeric) {
            return this.copy()
        }

        let newValue = this.value

        if (this.type == MatrixCellType.Expression) {
            for (let i = 0; i < steps; i++) {
                newValue = newValue
                    .replaceAll("0+", "")
                    .replaceAll("+0", "")
                    .replaceAll("+-", "-")
                    .replaceAll("--", "+")
                    .replaceAll(/([a-zA-Z])\*-1/g, "-$1")
                    .replaceAll(/-1\*([a-zA-Z])/g, "-$1")
                    .replaceAll(/\(([a-zA-Z])\*1\)/g, "$1")
                    .replaceAll(/\(1\*([a-zA-Z])\)/g, "$1")
                    .replaceAll(/\(([a-zA-Z])\*0\)/g, "0")
                    .replaceAll(/\(0\*([a-zA-Z])\)/g, "0")
                    .replaceAll(/\(([a-zA-Z0-9])\)/g, "$1")
                    .replaceAll(/\(\(([a-zA-Z])\*([a-zA-Z])\)\*([a-zA-Z])\)/g, "($1*$2*$3)")
                    .replaceAll(/\(([a-zA-Z])\*\(([a-zA-Z])\*([a-zA-Z])\)\)/g, "($1*$2*$3)")
                    .replaceAll(/\(\(([a-zA-Z])\+([a-zA-Z])\)\+([a-zA-Z])\)/g, "($1*$2*$3)")
                    .replaceAll(/\(([a-zA-Z])\+\(([a-zA-Z])\+([a-zA-Z])\)\)/g, "($1*$2*$3)")
            }
        }

        return new MatrixCell(newValue)
    }

}

class MatrixDimensions {

    constructor(rows, columns) {
        this.rows = rows
        this.columns = columns
    }

    transpose() {
        return new MatrixDimensions(this.columns, this.rows)
    }

    add(n) {
        return new MatrixDimensions(
            this.rows + n,
            this.columns + n
        )
    }

    copy() {
        return new MatrixDimensions(this.rows, this.columns)
    }

    static get Undefined() {
        return new MatrixDimensions(undefined, undefined)
    }

    toString() {
        return `${this.rows}x${this.columns}`
    }

    get isSquare() {
        return this.rows == this.columns
    }

    equals(otherDimensions) {
        return this.rows == otherDimensions.rows && this.columns == otherDimensions.columns
    }

}

class Matrix {

    constructor(dimensions, arrayData=undefined) {
        this.dimensions = dimensions

        this._data = Array.from({length: dimensions.rows},
            () => Array.from({length: dimensions.columns}, () => MatrixCell.Default))

        if (Array.isArray(arrayData)) {
            for (let i = 0; i < arrayData.length; i++) {
                if (Array.isArray(arrayData[i])) {
                    for (let j = 0; j < arrayData[i].length; j++) {
                        if (i < this._data.length && j < this._data[i].length && arrayData[i][j] !== undefined) {
                            this._data[i][j].value = arrayData[i][j]
                        }
                    }
                }
            }
        }
    }

    static fromArray(arr) {
        const dimensions = new MatrixDimensions(arr.length, arr[0].length)
        return new Matrix(dimensions, arr)
    }

    static vector(arr, transpose=false) {
        const v = Matrix.fromFunc(arr.length, 1, i => arr[i])
        if (transpose) {
            return v.transpose()
        } else {
            return v
        }
    }

    static fromFunc(n, m, f) {
        return Matrix.fromArray(
            Array.from({length: n}).map((_, i) => Array.from({length: m}).map((_, j) => f(i, j)))
        )
    }

    static zero(n) {
        return Matrix.fromFunc(n, n, () => 0)
    }

    static unit(n) {
        return Matrix.fromFunc(n, n, (i, j) => i == j ? 1 : 0)
    }

    get nRows() {
        return this.dimensions.rows
    }

    get nCols() {
        return this.dimensions.columns
    }

    get(rowIndex, columnIndex) {
        return this._data[rowIndex][columnIndex].value
    }

    set(rowIndex, columnIndex, value) {
        this._data[rowIndex][columnIndex].value = value
    }

    setCell(rowIndex, columnIndex, cell) {
        if (!(cell instanceof MatrixCell)) {
            throw new Error("cell must be instance of MatrixCell")
        }

        this._data[rowIndex][columnIndex] = cell
    }

    setCellValue(rowIndex, columnIndex, value) {
        this._data[rowIndex][columnIndex].value = value
    }

    getCell(rowIndex, columnIndex) {
        return this._data[rowIndex][columnIndex]
    }

    getCellValue(rowIndex, columnIndex) {
        return this._data[rowIndex][columnIndex].value
    }

    get rows() {
        return this._data
    }

    get rowsValues() {
        return this._data.map(
            row => row.map(
                cell => cell.value
            )
        )
    }

    get columns() {
        return Array.from({length: this.dimensions.columns}, (_, ci) => this.getColumn(ci))
    }

    get columnsValues() {
        return this.columns.map(
            column => column.map(
                cell => cell.value
            )
        )
    }

    toStringArray(simplify=true) {
        return this._data.map(
            row => row.map(
                element => {
                    if (typeof element.value === "number" && simplify) {
                        return element.toSimplifiedString()
                    }
                    return element.toString()
                }
            )
        )
    }

    getColumn(i) {
        return this.rows.map(row => row[i])
    }

    getRow(i) {
        return this._data[i]
    }

    toString(simplify=true) {
        let stringArray = this.toStringArray(simplify)
        const getColumnWidth = ci => Math.max(...stringArray.map(row => row[ci].length))
        const columnWidths = Array.from({length: this.dimensions.columns}, (_, ci) => getColumnWidth(ci))

        const padMiddle = (str, length) => {
            if (str.length >= length) return str
            let padLength = length - str.length
            let half = Math.floor(padLength / 2)
            return " ".repeat(half) + str + " ".repeat(padLength - half)
        }

        let outString = ""
        for (let ri = 0; ri < this.dimensions.rows; ri++) {
            outString += "[ "
            for (let ci = 0; ci < this.dimensions.columns; ci++) {
                outString += padMiddle(stringArray[ri][ci], columnWidths[ci])
                outString += " "
            }
            outString = outString.slice(0, -1) + " ]\n"
        }

        return outString.slice(0, -1)
    }

    multiply(other) {
        let result = new Matrix(new MatrixDimensions(
            this.dimensions.rows, other.dimensions.columns))
        for (let ri = 0; ri < result.dimensions.rows; ri++) {
            for (let ci = 0; ci < result.dimensions.columns; ci++) {
                let row = this.getRow(ri)
                let column = other.getColumn(ci)

                let dotProduct = row.map((n, i) => n.mul(column[i]))
                    .reduce((p, c) => p.add(c))
                result.setCell(ri, ci, dotProduct)
            }
        }
        return result
    }

    norm(squared=false) {
        if (this.dimensions.rows != 1 && this.dimensions.columns != 1) {
            throw new Error("Can't take norm of non-vector")
        }

        let squaredSum = null
        if (this.dimensions.rows == 1) {
            squaredSum = this.getRow(0).map(v => v.mul(v)).reduce((p, c) => p.add(c), new MatrixCell(0))
        } else if (this.dimensions.columns == 1) {
            squaredSum = this.getColumn(0).map(v => v.mul(v)).reduce((p, c) => p.add(c), new MatrixCell(0))
        } else {
            throw new Error("Can't take norm of non-vector matrix")
        }

        if (squared) {
            return squaredSum
        } else {
            return Math.sqrt(squaredSum.value)
        }
    }

    transpose() {
        return new Matrix(this.dimensions.transpose(), this.columnsValues)
    }

    without(rowIndex, columnIndex) {
        const result = new Matrix(this.dimensions.add(-1))

        for (let i = 0; i < this.dimensions.rows; i++) {
            for (let j = 0; j < this.dimensions.columns; j++) {
                if (i == rowIndex || j == columnIndex) {
                    continue
                }

                let newRowIndex = i
                let newColumnIndex = j

                if (i > rowIndex) {
                    newRowIndex--
                }

                if (j > columnIndex) {
                    newColumnIndex--
                }

                result._data[newRowIndex][newColumnIndex] = this._data[i][j]
            }   
        }

        return result
    }

    get isSquare() {
        return this.dimensions.isSquare
    }

    get n() {
        return this.dimensions.rows
    }

    determinant() {
        if (!this.isSquare) {
            throw new Error("Determinant is undefined for non-square matrices")
        }

        if (this.n == 1) {
            return this._data[0][0]
        }

        let sum = new MatrixCell(0)

        for (let j = 0; j < this.n; j++) {
            const sgn = new MatrixCell((j % 2 == 0) ? 1 : -1)
            sum = sum.add(this.getCell(0, j).mul(sgn).mul(this.without(0, j).determinant()))
        }

        return sum
    }

    mapValue(mapFunc) {
        const result = new Matrix(this.dimensions.copy())
        for (let i = 0; i < result.dimensions.rows; i++) {
            for (let j = 0; j < result.dimensions.columns; j++) {
                result._data[i][j].value = mapFunc(this.getCell(i, j), i, j)
            }
        }
        return result
    }

    map(mapFunc) {
        const result = new Matrix(this.dimensions.copy())
        for (let i = 0; i < result.dimensions.rows; i++) {
            for (let j = 0; j < result.dimensions.columns; j++) {
                result._data[i][j] = mapFunc(this.getCell(i, j), i, j)
            }
        }
        return result
    }

    copy() {
        return this.map(c => c.copy())
    }

    static RandomIntegers(n, m, maxInt=10) {
        if (m === undefined) {
            m = n
        }

        return new Matrix(new MatrixDimensions(n, m)).mapValue(
            () => Math.floor(Math.random() * maxInt)
        )
    }

    minors() {
        return this.map((cell, i, j) => {
            return this.without(i, j).determinant()
        })
    }

    cofactor() {    
        return this.minors().map((cell, i, j) => {
            return cell.mul(new MatrixCell(((i + j) % 2 == 0) ? 1 : -1))
        })
    }

    adjunct() {
        return this.cofactor().transpose()
    }

    inverse() {
        const det = this.determinant()
        if (det == 0) {
            throw new Error("Matrix is not invertible (det = 0)")
        }

        return this.adjunct().scale(new MatrixCell(1).div(det))
    }

    simplify() {
        return this.map(cell => cell.simplify())
    }

    add(otherMatrix) {
        if (!this.dimensions.equals(otherMatrix.dimensions)) {
            return new Error("Matrix Dimensions must be equal")
        }

        return this.map((cell, i, j) => {
            return cell.add(otherMatrix.getCell(i, j))
        })
    }

    scale(scalar) {
        return this.map(cell => {
            return cell.mul(MatrixCell.toMatrixCell(scalar))
        })
    }

    // row operations (inplace)

    swapRows(r1, r2) {
        const temp = this._data[r1]
        this._data[r1] = this._data[r2]
        this._data[r2] = temp
    }

    scaleRow(rowIndex, scalar) {
        const scalarCell = MatrixCell.toMatrixCell(scalar)
        for (let columnIndex = 0; columnIndex < this.nCols; columnIndex++) {
            const newCell = this.getCell(rowIndex, columnIndex).mul(scalarCell)
            this.setCell(rowIndex, columnIndex, newCell)
        }
    }

    addScalarRow(r1, r2, scalar) {
        const scalarCell = MatrixCell.toMatrixCell(scalar)
        for (let columnIndex = 0; columnIndex < this.nCols; columnIndex++) {
            const newCell = this.getCell(r2, columnIndex).add(this.getCell(r1, columnIndex).mul(scalarCell))
            this.setCell(r2, columnIndex, newCell)
        }
    }

    isZeroColumn(columnIndex) {
        for (let i = 0; i < this.nRows; i++) {
            if (this.get(i, columnIndex) != 0) {
                return false
            }
        }
        return true
    }

    isZeroMatrix() {
        for (let i = 0; i < this.nCols; i++) {
            if (!this.isZeroColumn(i)) {
                return false
            }
        }
        return true
    }

    containsOnlyNumbers() {
        return !this._data.flat().some(cell => cell.type != MatrixCellType.Numeric)
    }

}

async function inputMatrixDimensions({
    matrixName="A",
    forcedRows=undefined,
    square=false
}={}) {
    let message = `Matrix ${matrixName} Dimensions [e.g. 3x2]: `
    if (forcedRows) {
        message += `${forcedRows}x`
    }

    if (square) {
        while (true) {
            const input = await terminal.prompt(`Matrix ${matrixName} size: `)
            if (/^[0-9]+$/.test(input)) {
                const n = parseInt(input)
                return new MatrixDimensions(n, n)
            } else {
                terminal.printError("Invalid Format! Valid format is positive integer, e.g. \"3\"", "ParserError")
            }
        }
    }

    while (true) {
        const input = await terminal.prompt(message)
        if (forcedRows === undefined) {
            if (/^[0-9]+x[0-9]+$/.test(input)) {
                const splitValues = input.split("x").map(v => parseInt(v))
                if (Math.min(...splitValues) == 0) {
                    terminal.printError("Dimensions must be larger than 0", "ValueError")
                } else {
                    return new MatrixDimensions(...splitValues)
                }
            } else {
                terminal.printError("Invalid Format! Valid format is RxC, e.g. \"3x2\"", "ParserError")
            }
        } else {
            if (/^[0-9]+$/.test(input)) {
                if (parseInt(input) == 0) {
                    terminal.printError("Dimensions must be larger than 0", "ValueError")
                } else {
                    return new MatrixDimensions(forcedRows, parseInt(input))
                }
            } else {
                terminal.printError("Invalid Format: Please enter a valid number of columns!", "ParserError")
            }
        }
    }
}

async function inputMatrix(dimensions) {
    let matrix = new Matrix(dimensions)
    const minInputWidth = 3
    let inputWidth = minInputWidth
    const badColor = "rgba(255, 0, 0, 0.5)"
    const goodColor = "rgba(0, 255, 0, 0.5)"

    let inputs = []
    let elements = []
    let finishButton = null

    const updateInputWidth = () => {
        let maxInputWidth = Math.max(...inputs.map(inp => inp.value.length)) + 1
        inputWidth = Math.max(maxInputWidth, minInputWidth)

        for (let input of inputs) {
            input.style.width = `${inputWidth * terminal.charWidth}px`
            input.style.marginTop = "5px"
            input.style.marginBottom = "5px"
        }

        const finishButtonWidth = Math.max(
            (dimensions.columns * (inputWidth + 1) + 1) * terminal.charWidth, 9 * terminal.charWidth)

        finishButton.style.width = `${finishButtonWidth}px`
    }

    for (let ri = 0; ri < dimensions.rows; ri++) {
        for (let ci = 0; ci < dimensions.columns; ci++) {
            elements.push(terminal.print(ci == 0 ? "[" : " ", undefined, {forceElement: true}))
            let input = terminal.createStyledInput()

            const setBad = () => {
                input.style.backgroundColor = badColor
                input.dataset.valid = false
            }

            const setGood = () => {
                input.style.backgroundColor = goodColor
                input.dataset.valid = true
            }

            input.addEventListener("keydown", event => {
                if (event.ctrlKey && event.key == "c") {
                    terminal.interrupt()
                }
            })

            input.style.textAlign = "center"
            setBad()
            input.style.width = `${terminal.charWidth * inputWidth}px`
            terminal.parentNode.appendChild(input)

            input.oninput = () => {
                updateInputWidth()
                if (input.value.match(/^\-?[0-9]+\/[0-9]+$/)) {
                    const parts = input.value.split("/")
                    let numericValue = parseInt(parts[0]) / parseInt(parts[1])
                    matrix.setCell(ri, ci, new MatrixCell(numericValue))
                    setGood()
                } else if (input.value.toString().match(/^\-?[0-9]+(?:\.[0-9]+)?$/)) {
                    let numericValue = parseFloat(input.value)
                    matrix.setCell(ri, ci, new MatrixCell(numericValue))
                    setGood()
                } else if (input.value.toString().match(/^[a-z]$/)) {
                    matrix.setCell(ri, ci, new MatrixCell(input.value.toString()))
                    setGood()
                } else {
                    setBad()
                }
            }

            inputs.push(input)
        }
        elements.push(terminal.printLine("]", undefined, {forceElement: true}))
    }

    inputs[0].focus()

    let finished = false

    finishButton = terminal.createTerminalButton({
        text: "Submit",
        charWidth: dimensions.columns * (inputWidth + 1) + 1,
        onPress: () => {
            if (inputs.find(inp => inp.dataset.valid == "false")) {
                return
            }

            for (let input of inputs) {
                input.style.backgroundColor = "transparent"
                input.oninput = () => {}
            }

            for (let element of elements) {
                element.remove()
            }

            terminal.printLine(matrix.toString())

            finished = true
        }
    })

    terminal.parentNode.appendChild(finishButton)
    updateInputWidth()

    elements.push(finishButton)
    elements.push(...inputs)

    while (!finished) {
        await terminal.sleep(500)
    }

    return matrix
}

terminal.modules.matrix = {
    Matrix, MatrixCellType,
    MatrixCell, MatrixDimensions,
    inputMatrixDimensions,
    inputMatrix
}

// ------------------- js/modules/neural.js --------------------
const sigmoid = t => 1 / (1 + Math.pow(Math.E, -t))

class Node {
    
    constructor(layer, previousRow, {biasEnabled=false}={}) {
        this.output = 0.0
        this.weights = []
        this.layer = layer
        this.biasEnabled = biasEnabled
        this.bias = (Math.random() - 0.5)

        for (let i = 0; i < previousRow.length; i++) {
            this.weights.push(Math.random())
        }

    }

    fire(previousRow) {
        let cumulativeWeight = 0.0
        for (let i = 0; i < previousRow.length; i++) {
            let combined = previousRow[i].output * this.weights[i]
            cumulativeWeight += combined
        }
        let average = cumulativeWeight / previousRow.length
        if (this.biasEnabled) {
            average += this.bias
        }
        this.output = sigmoid(average)
    }

    copy() {
        let newNode = new Node(this.layer, [])
        newNode.output = this.output
        newNode.weights = this.weights.slice()
        return newNode
    }

}

class Net {

    constructor(nodes, {biasEnabled=false}={}) {
        this.nodes = []

        let previousRow = []
        for (let i = 0; i < nodes.length; i++) {
            let newRow = []
            for (let j = 0; j < nodes[i]; j++) {
                let newNode = new Node(i, previousRow, {biasEnabled})
                newRow.push(newNode)
            }
            previousRow = newRow
            this.nodes.push(newRow)
        }
    }

    train(inputs, expected, cycles = 200, learningRate = 0.5) {
        for (let i = 0; i < cycles; i++) {
            for (let j = 0; j < inputs.length; j++) {
                this.input(inputs[j])
                this.backpropagation(expected[j])
                this.updateWeights(learningRate)
            }
        }
    }

    input(inputData) {
        if (inputData.length != this.nodes[0].length)
            throw new Error("Input Array must be same size as Input Neuron Layer")
        for (let i = 0; i < inputData.length; i++) {
            this.nodes[0][i].output = inputData[i]
        }

        this.fire()

        let output = []
        for (let i = 0; i < this.nodes[this.nodes.length - 1].length; i++) {
            output.push(this.nodes[this.nodes.length - 1][i].output)
        }
        return output
    }

    fire() {
        for (let i = 1; i < this.nodes.length; i++) {
            let previousRow = this.nodes[i - 1]
            for (let j = 0; j < this.nodes[i].length; j++) {
                this.nodes[i][j].fire(previousRow)
            }
        }
    }

    updateWeights(learningRate) {
        for (let i = 1; i < this.nodes.length; i++) {
            let inputs = []
            for (let j = 0; j < this.nodes[i - 1].length; j++)
                inputs.push(this.nodes[i - 1][j].output)
            for (let j = 0; j < this.nodes[i].length; j++) {
                for (let k = 0; k < inputs.length; k++) {
                    this.nodes[i][j].weights[k] += learningRate * this.nodes[i][j].delta * inputs[k]
                }
            }
        }
    }

    backpropagation(expected) {
        function derivative(output) {
            return output * (1.0 - output)
        }

        for (let i = this.nodes.length - 1; i >= 0; i--) {
            let layer = this.nodes[i]
            let errors = []
            if (i != this.nodes.length - 1) {
                for (let j = 0; j < layer.length; j++) {
                    let error = 0.0
                    for (let k = 0; k < this.nodes[i + 1].length; k++) {
                        let neuron = this.nodes[i + 1][k]
                        error += neuron.weights[j] * neuron.delta
                    }
                    errors.push(error)
                }
            } else {
                for (let j = 0; j < layer.length; j++) {
                    let neuron = layer[j]
                    errors.push(expected[j] - neuron.output)
                }
            }
            for (let j = 0; j < layer.length; j++) {
                let neuron = this.nodes[i][j]
                neuron.delta = errors[j] * derivative(neuron.output)
            }
        }
    }

    copy() {
        let newNet = new Net([])
        for (let i = 0; i < this.nodes.length; i++) {
            let newRow = []
            for (let j = 0; j < this.nodes[i].length; j++) {
                newRow.push(this.nodes[i][j].copy())
            }
            newNet.nodes.push(newRow)
        }
        return newNet
    }

    mutate(rate) {
        for (let i = 0; i < this.nodes.length; i++) {
            for (let j = 0; j < this.nodes[i].length; j++) {
                for (let k = 0; k < this.nodes[i][j].weights.length; k++) {
                    if (Math.random() < rate) {
                        this.nodes[i][j].weights[k] = Math.random()
                    }

                    if (Math.random() < rate) {
                        this.nodes[i][j].bias += (Math.random() - 0.5)
                    }
                }
            }
        }
    }

    static crossover(net1, net2) {
        let newNet = net1.copy()
        for (let i = 0; i < newNet.nodes.length; i++) {
            for (let j = 0; j < newNet.nodes[i].length; j++) {
                for (let k = 0; k < newNet.nodes[i][j].weights.length; k++) {
                    if (Math.random() < 0.5) {
                        newNet.nodes[i][j].weights[k] = net2.nodes[i][j].weights[k]
                    }

                    if (Math.random() < 0.5) {
                        newNet.nodes[i][j].bias = net2.nodes[i][j].bias
                    }
                }
            }
        }
        return newNet
    }
}

function indexOfMax(arr) {
    if (arr.length === 0) {
        return -1
    }

    let max = arr[0]
    let maxIndex = 0

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            maxIndex = i
            max = arr[i]
        }
    }

    return maxIndex
}

terminal.modules.neural = {
    Net, Node, sigmoid, indexOfMax
}

// ------------------- js/modules/np.js --------------------
const NpDataType = Object.freeze({
    Int8: "Int8",
    Uint8: "Uint8",
    Uint8Clamped: "Uint8Clamped",
    Int16: "Int16",
    Uint16: "Uint16",
    Int32: "Int32",
    Uint32: "Uint32",
    Float16: "Float16",
    Float32: "Float32",
    Float64: "Float64",
    BigInt64: "BigInt64",
    BigUint64: "BigUint64"
})

const int8 = "Int8"
const uint8 = "Uint8"
const uint8Clamped = "Uint8Clamped"
const int16 = "Int16"
const uint16 = "Uint16"
const int32 = "Int32"
const uint32 = "Uint32"
const float16 = "Float16"
const float32 = "Float32"
const float64 = "Float64"
const bigInt64 = "BigInt64"
const bigUint64 = "BigUint64"

const NpAllDataTypes = new Set(Object.keys(NpDataType))

function* iterateShape(shape) {
    const totalSize = shape.reduce((p, c) => p * c, 1)
    const shapeIndeces = shape.map(() => 0)
    for (let i = 0; i < totalSize; i++) {
        let t = i
        for (let j = 0; j < shape.length; j++) {
            const shapeIndex = shape.length - j - 1
            shapeIndeces[shapeIndex] = t % shape[shapeIndex]
            t = (t - shapeIndeces[shapeIndex]) / shape[shapeIndex]
        }
        yield shapeIndeces
    }
}

class NpArray {

    constructor(arrayData, dtype=null) {
        // make sure initialization is correct
        dtype ??= float64
        if (!NpAllDataTypes.has(dtype)) {
            throw new TypeError(`data type '${dtype}' not understood`)
        }

        if (!Array.isArray(arrayData)) {
            throw new TypeError("expected arrayData to be an array")
        }

        // find shape of data
        this.shape = []
        let tempData = arrayData
        while (Array.isArray(tempData)) {
            this.shape.push(tempData.length)
            tempData = tempData[0]
        }

        // initialize 1d array representing NpArray
        const totalSize = this.shape.reduce((p, c) => p * c, 1)
        const relevantClass = terminal.window[dtype + "Array"]
        this._data = new relevantClass(totalSize)

        // fill data
        let i = 0
        for (const shapeIndeces of iterateShape(this.shape)) {
            // use shapeIndeces to locate value
            let value = arrayData
            for (const shapeIndex of shapeIndeces) {
                if (!Array.isArray(value)) {
                    throw new Error("arrayData has invalid shape: must be (hyper-)rectangular")
                }

                value = value[shapeIndex]
            }

            // check if it even exists
            if (value === undefined) {
                throw new Error("arrayData has invalid shape: must be (hyper-)rectangular")
            }

            // fill value in array
            this._data[i] = value
            i++
        }
    }

    *[Symbol.iterator]() {
        for (let i = 0; i < this.size; i++) {
            yield this._data[i]
        }
    }

    get size() {
        return this._data.length
    }

    at(...indeces) {
        if (indeces.length > this.shape.length) {
            throw new Error("got too many indeces")
        } else if (indeces.length == this.shape.length) {
            let totalIndexSum = 0
            let cumulativeFactor = 1
            for (let i = 0; i < this.shape.length; i++) {
                const shapeSize = this.shape[this.shape.length - i - 1]
                const givenIndex = indeces[this.shape.length - i - 1]
                if (!Number.isInteger(givenIndex)) {
                    throw new Error("expected integers as indeces")
                }
                
                const realIndex = mod(givenIndex, shapeSize)
                totalIndexSum += realIndex * cumulativeFactor
                console.log(realIndex, shapeSize)
                cumulativeFactor *= shapeSize
            }
            return this._data[totalIndexSum]
        } else {
            throw new Error("Not Implemented")
        }
    }

    toString() {
        let outstring = "array("
        for (let i = 0; i < this.size; i++) {
            for (const shapeSize of this.shape) {
                if (i % shapeSize == 0) {
                    outstring += "."
                }
            }
            outstring += `${this._data[i]}`
        }
        return outstring
    }

    static isNpArray(data) {
        if (data instanceof NpArray) {
            return true
        } else {
            return false
        }
    }

    get _val() {
        if (this.size > 1) {
            throw new Error("Can't get value of multivalued array")
        }
        return this._data[0]
    }

}

function array(data, dtype=null) {
    return new NpArray(data, dtype)
}

function asarray(data, dtype=null) {
    if (NpArray.isNpArray(data)) {
        return data
    } else if (Array.isArray(data)) {
        return new NpArray(data, dtype)
    } else if (typeof data === "number") {
        return new NpArray([data], dtype)
    } else {
        throw new Error("Unable to convert data to array")
    }
}

function mod(n, modulus) {
    return ((n % modulus) + modulus) % modulus
}

terminal.modules.np = {
    NpArray, NpDataType, NpAllDataTypes, array,
    asarray, mod, iterateShape,
    int8,
    uint8,
    uint8Clamped,
    int16,
    uint16,
    int32,
    uint32,
    float16,
    float32,
    float64,
    bigInt64,
    bigUint64,
}

// ------------------- js/modules/progressbar.js --------------------
class ProgressBar {

    constructor({
        width = 40
    }={}) {
        this.width = width
        this.outputElement = terminal.print("", undefined, {forceElement: true})
        this.removed = false
    }

    update(progress) {
        if (this.removed) {
            return
        }

        const borderHorizontal = "+" + "-".repeat(this.width - 2) + "+"
        const text = borderHorizontal + "\n|"
        const middleChars = Array.from({length: this.width - 2}).map((_, i) => {
            const p = i / (this.width - 3)
            return (p <= progress) ? "#" : " "
        })

        const progressText = Math.floor(100 * progress) + "%"
        let cursorIndex = Math.round(middleChars.length / 2 - Math.floor(progressText.length / 2))
        middleChars[cursorIndex - 1] = " "
        middleChars[cursorIndex + progressText.length] = " "
        for (let i = 0; i < progressText.length; i++) {
            middleChars[cursorIndex + i] = progressText[i]
        }

        this.outputElement.textContent = text + middleChars.join("") + "|\n" + borderHorizontal + "\n"
    }

    finish() {
        this.update(1)
    }

    remove() {
        this.outputElement.remove()
        this.removed = true
    }

}

function printProgressBar(opts) {
    const bar = new ProgressBar(opts)
    bar.update(0)
    return bar
}

terminal.modules.progressbar = {
    printProgressBar, ProgressBar
}

// ------------------- js/modules/pyscript.js --------------------
const changePromptCode = `from js import terminalPrompt
input = terminalPrompt
__builtins__.input = terminalPrompt`

function load(addStyling=false) {
    return new Promise(resolve => {
        let script = document.createElement("script")
        script.src = "https://pyscript.net/latest/pyscript.js"
        script.onload = async function() {
            while (!terminal.window.loadPyodide) {
                await sleep(100)
            }
            terminal.modules.pyscript.pyodide = await terminal.window.loadPyodide({
                stdout: (msg) => {
                    terminal.printLine(msg)
                },
                stderr: (msg) => {
                    terminal.printError(msg)
                },
                fullStdLib: false
            })

            terminal.window.terminalPrompt = prompt
            terminal.modules.pyscript.pyodide.runPython(changePromptCode)

            terminal.modules.pyscript.hasLoaded = true
            resolve()
        }
        terminal.document.head.appendChild(script)
        terminal.modules.pyscript.script = script
    
        if (addStyling) {
            let link = document.createElement("link")
            link.rel = "stylesheet"
            link.href = "https://pyscript.net/latest/pyscript.css"
            terminal.document.head.appendChild(link)
            terminal.modules.pyscript.link = link
        }
    })
}


terminal.modules.pyscript = {
    hasLoaded: false,
    load,
    pyodide: null,
    script: null,
    link: null
}

// ------------------- js/modules/statistics.js --------------------
function drawLine(context, x1, y1, x2, y2, {
    color = "black",
    lineWidth = 1
}={}) {
    context.strokeStyle = color
    context.lineWidth = lineWidth
    context.beginPath()
    context.moveTo(x1, y1)
    context.lineTo(x2, y2)
    context.stroke()
}

function drawTurnedText(context, text, x, y, {
    angle = 0
}={}) {
    context.save()
    context.translate(x, y)
    context.rotate(angle)
    context.fillText(text, 0, 0)
    context.restore()
}

function drawTriangle(context, x, y, width, height, {
    color = "black",
    angle = 0
}={}) {
    let pos1 = {
        x: 0,
        y: -height
    }

    let pos2 = {
        x: -width,
        y: height
    }

    let pos3 = {
        x: width,
        y: height
    }

    context.save()
    context.translate(x, y)
    context.rotate(angle)
    context.beginPath()
    context.fillStyle = color
    context.moveTo(pos1.x, pos1.y)
    context.lineTo(pos2.x, pos2.y)
    context.lineTo(pos3.x, pos3.y)
    context.closePath()
    context.fill()
    context.restore()
}

function drawAxis(context, {
    color = "black",
    xAxisName = null,
    yAxisName = null,
    xAxisNameColor = "black",
    yAxisNameColor = "black",
    xAxisNameSize = 20,
    yAxisNameSize = 20,
    font = "monospace",
    lineWidth = 1,
    backgroundColor = "white",
    paddingPx = 50,
    arrowSize = 0
}={}) {
    fillBackground(context, {color: backgroundColor})

    const canvas = context.canvas

    context.strokeStyle = color
    context.lineWidth = lineWidth
    context.font = `${xAxisNameSize}px ${font}`
    context.textAlign = "center"
    context.textBaseline = "middle"
    context.beginPath()

    let yAxisStartX = paddingPx
    let xAxisStartY = canvas.height - paddingPx
    let xAxisEndX = canvas.width - paddingPx
    let xAxisMiddleY = (xAxisStartY + paddingPx) / 2
    let yAxisMiddleX = (yAxisStartX + canvas.width - paddingPx) / 2

    if (xAxisName != null) {
        context.fillStyle = xAxisNameColor
        while (context.measureText(xAxisName).width > canvas.width - paddingPx * 2) {
            xAxisNameSize--
            context.font = `${xAxisNameSize}px ${font}`
        }
        context.fillText(xAxisName, yAxisMiddleX, xAxisStartY)
        xAxisStartY -= xAxisNameSize
    }

    if (yAxisName != null) {
        context.fillStyle = yAxisNameColor
        while (context.measureText(yAxisName).width > canvas.height - paddingPx * 2) {
            yAxisNameSize--
            context.font = `${yAxisNameSize}px ${font}`
        }
        drawTurnedText(context, yAxisName, yAxisStartX, xAxisMiddleY, {
            angle: -Math.PI / 2
        })
        yAxisStartX += yAxisNameSize
    }
    
    drawLine(context, yAxisStartX, paddingPx, yAxisStartX, xAxisStartY, {color, lineWidth})
    drawLine(context, yAxisStartX, xAxisStartY, xAxisEndX, xAxisStartY, {color, lineWidth})

    if (arrowSize > 0) {
        drawTriangle(context, yAxisStartX, paddingPx + arrowSize / 2, arrowSize, arrowSize, {color, angle: 0})
        drawTriangle(context, xAxisEndX - arrowSize / 2, xAxisStartY, arrowSize, arrowSize, {color, angle: Math.PI / 2 * 5})
    }

    return {
        x: yAxisStartX,
        y: xAxisStartY,
        width: xAxisEndX - yAxisStartX,
        height: xAxisStartY - paddingPx
    }
}

function fillBackground(context, {
    color = "white",
}={}) {
    const canvas = context.canvas
    context.fillStyle = color
    context.clearRect(0, 0, canvas.width, canvas.height)
    context.fillRect(0, 0, canvas.width, canvas.height)
}

function drawCircle(context, x, y, radius) {
    context.beginPath()
    context.arc(x, y, radius, 0, 2 * Math.PI)
    context.fill()
}

class Dataset {

    constructor(numbers) {
        this.numbers = numbers
    }

    static random({
        length=10,
        min=0,
        max=10,
    }={}) {
        let numbers = []
        for (let i = 0; i < length; i++)
            numbers.push(Math.random() * (max - min) + min)
        return new Dataset(numbers)
    }

    static randomSorted({
        length=10,
        min=0,
        max=10,
    }={}) {
        let numbers = []
        for (let i = 0; i < length; i++)
            numbers.push(Math.random() * (max - min) + min)
        numbers.sort((a, b) => a - b)
        return new Dataset(numbers)
    }

    static fromFunc(func, {
        min=0,
        max=10,
        length=10
    }={}) {
        let numbers = []
        let step = (max - min) / length
        let x = min
        for (let i = 0; i < length; i++) {
            x += step
            numbers.push(func(x))
        }
        return new Dataset(numbers)
    }

    get length() {
        return this.numbers.length
    }

    static fromString(string) {
        const numbersRegex = /^(?:-?\d+(\.\d+)?\s?)+$/g
        if (!numbersRegex.test(string))
            throw new Error("Invalid numbers format. Use \"1 2 3 4 5\"")
        let numbers = string.split(" ").map(n => parseFloat(n))
        return new Dataset(numbers)
    }

    toString() {
        let out = "Dataset(["
        for (let i = 0; i < this.numbers.length; i++) {
            out += this.numbers[i]
            if (i < this.numbers.length - 1)
                out += ","
        }
        return out + `], length=${this.length})`
    }

    get average() {
        let sum = 0
        for (let i = 0; i < this.numbers.length; i++)
            sum += this.numbers[i]
        return sum / this.numbers.length
    }
    
    get median() {
        let sorted = this.numbers.slice().sort((a, b) => a - b)
        let middle = Math.floor(sorted.length / 2)
        if (sorted.length % 2 === 0)
            return (sorted[middle - 1] + sorted[middle]) / 2
        else
            return sorted[middle]
    }

    get mode() {
        let counts = {}
        for (let i = 0; i < this.numbers.length; i++) {
            let num = this.numbers[i]
            if (counts[num] === undefined)
                counts[num] = 0
            counts[num]++
        }
        let max = 0
        let maxNum = null
        for (let num in counts) {
            if (counts[num] > max) {
                max = counts[num]
                maxNum = num
            }
        }
        return maxNum
    }

    get range() {
        let min = this.numbers[0]
        let max = this.numbers[0]
        for (let i = 1; i < this.numbers.length; i++) {
            let num = this.numbers[i]
            if (num < min)
                min = num
            if (num > max)
                max = num
        }
        return max - min
    }

    get variance() {
        let avg = this.average
        let sum = 0
        for (let i = 0; i < this.numbers.length; i++)
            sum += Math.pow(this.numbers[i] - avg, 2)
        return sum / this.numbers.length
    }

    get standardDeviation() {
        return Math.sqrt(this.variance)
    }

    get max() {
        return Math.max(...this.numbers)
    }

    get min() {
        return Math.min(...this.numbers)
    }

    addNumber(n) {
        this.numbers.push(n)
    }

    subset(start, end) {
        return new Dataset(this.numbers.slice(start, end))
    }

    lineplot(context, axisOptions={}, {
        color="red",
        lineWidth=1,
        displayPoints=true,
    }={}) {
        const drawArea = drawAxis(context, axisOptions)

        context.strokeStyle = color
        context.fillStyle = color
        let xStep = drawArea.width / (this.numbers.length - 1)
        let prevX = null
        let prevY = null
        let minValue = Math.min(...this.numbers)
        let maxValue = Math.max(...this.numbers)
        let yRange = maxValue - minValue
        let yStep = drawArea.height / yRange
        if (yRange == 0) {
            yStep = 0
            minValue = 0
            yRange = 1
        }
        for (let i = 0; i < this.numbers.length; i++) {
            let x = drawArea.x + i * xStep
            let y = drawArea.y - (this.numbers[i] - minValue) * yStep
            let circleSize = Math.min(xStep * 0.4, 5)
            if (circleSize > 1.5 && displayPoints)
                drawCircle(context, x, y, circleSize)
            if (prevX != null && prevY != null)
                drawLine(context, prevX, prevY, x, y, {color, lineWidth})
            prevX = x
            prevY = y
        }
    }

}

terminal.modules.statistics = {
    Dataset,
}

// ------------------- js/modules/turtlo.js --------------------
terminal.turtlo = {}

function removeExistingTurtlos() {
    let count = 0
    for (let element of terminal.document.querySelectorAll(".turtlo")) {
        if (!element.classList.contains("gone")) {
            element.classList.add("gone")
            count++
        }
    }
    return count
}

const TURTLO_CONTAINER = terminal.document.querySelector("#turtlo-container")

const TURTLO_STATE = {
    IDLE: "idle",
    WALKING: "walking"
}

function resetTurtlo() {
    terminal.turtlo = {
        x: -500,
        y: -500,
        goalX: terminal.window.innerWidth / 2,
        goalY: terminal.window.innerHeight / 2,
        rot: 0,
        moving: false,
        intervalFunc: null,
        imageElement: terminal.document.createElement("img"),
        startTime: Date.now(),
        state: TURTLO_STATE.WALKING,
        shellDuration: 0,
        lastShellTime: Date.now(),
        inShell: () => ((terminal.turtlo.lastShellTime + terminal.turtlo.shellDuration) > Date.now()),
        toungeDuration: 0,
        lastToungeTime: Date.now(),
        hasToungeOut: () => ((terminal.turtlo.lastToungeTime + terminal.turtlo.toungeDuration) > Date.now()),
        spinDuration: 3000,
        lastSpinTime: Date.now(),
        inSpin: () => ((terminal.turtlo.lastSpinTime + terminal.turtlo.spinDuration) > Date.now()),
        prevRot: 120,
        hugeSpinDuration: 0,
        lastHugeSpinTime: Date.now(),
        radiusFactor: 0.9,
        inHugeSpin: () => ((terminal.turtlo.lastHugeSpinTime + terminal.turtlo.hugeSpinDuration) > Date.now()),
        starTurtlos: [],
        hasStars: () => (terminal.turtlo.starTurtlos.length > 0),
        mouseStartX: 0,
        mouseStartY: 0,
    }
}

terminal.window.addEventListener("mousemove", function(event) {
    terminal.turtlo.goalX = event.clientX
    terminal.turtlo.goalY = event.clientY
    if (terminal.turtlo.imageElement) {
        terminal.turtlo.goalX -= terminal.turtlo.imageElement.clientWidth / 2
        terminal.turtlo.goalY -= terminal.turtlo.imageElement.clientHeight - 10
    }
})

function drawTurtlo() {
    let x = terminal.turtlo.x
    let y = terminal.turtlo.y

    let timeElapsed = (Date.now() - terminal.turtlo.startTime) % 1000
    if (terminal.turtlo.inHugeSpin()) {
        let walkingImages = ["walking-0", "walking-1", "walking-2", "walking-1"]
        let imageIndex = Math.floor(timeElapsed / 1001 * walkingImages.length)
        let currImage = walkingImages[imageIndex]
        terminal.turtlo.imageElement.src = "res/img/turtlo/" + currImage + ".png"
        let spinTimeElapsed = Date.now() - terminal.turtlo.lastHugeSpinTime
        let timeFactor = spinTimeElapsed / (terminal.turtlo.hugeSpinDuration * terminal.turtlo.spinAmountFactor)
        //terminal.turtlo.rot = timeFactor * 360 + terminal.turtlo.prevRot
        let windowRadius = Math.min(terminal.window.innerHeight, terminal.window.innerWidth) / 2 * terminal.turtlo.radiusFactor
        let [midX, midY] = [terminal.window.innerWidth / 2, terminal.window.innerHeight / 2]
        terminal.turtlo.goalX = Math.cos(timeFactor * Math.PI * 2 + terminal.turtlo.radiusStart) * windowRadius + midX
        terminal.turtlo.goalY = Math.sin(timeFactor * Math.PI * 2 + terminal.turtlo.radiusStart) * windowRadius + midY
    } else if (terminal.turtlo.inSpin()) {
        terminal.turtlo.imageElement.src = "res/img/turtlo/walking-0.png"
        let timeElapsed = Date.now() - terminal.turtlo.lastSpinTime
        terminal.turtlo.rot = ((timeElapsed / terminal.turtlo.spinDuration) * 360 + terminal.turtlo.prevRot)
    } else if (terminal.turtlo.inShell()) {
        terminal.turtlo.imageElement.src = "res/img/turtlo/hidden.png"
    } else if (terminal.turtlo.hasToungeOut()) {
        terminal.turtlo.imageElement.src = "res/img/turtlo/tounge.png"
    } else if (terminal.turtlo.state == TURTLO_STATE.WALKING) {
        let walkingImages = ["walking-0", "walking-1", "walking-2", "walking-1"]
        let imageIndex = Math.floor(timeElapsed / 1001 * walkingImages.length)
        let currImage = walkingImages[imageIndex]
        terminal.turtlo.imageElement.src = "res/img/turtlo/" + currImage + ".png"
    } else if (terminal.turtlo.state == TURTLO_STATE.IDLE) {
        terminal.turtlo.imageElement.src = "res/img/turtlo/walking-0.png"
    }

    if (terminal.turtlo.hasStars()) {
        for (let star of terminal.turtlo.starTurtlos) {
            star.x += star.directionX
            star.y += star.directionY
            star.element.style.top = star.y + "px"
            star.element.style.left = star.x + "px"
            let starAge = Date.now() - star.startOfLife
            let rotation = starAge / star.rotationTime * 360
            star.element.style.transform = `rotate(${rotation}deg)`
            star.element.style.opacity = Math.max(1, starAge / 1000)
        }

        function removeStar(star) {
            star.element.remove()
        }

        terminal.turtlo.starTurtlos = terminal.turtlo.starTurtlos.filter(star => {
            let starSize = star.element.clientWidth * 2
            if (star.x + starSize < 0 || star.x - starSize > terminal.window.innerWidth
                || star.y + starSize < 0 || star.y - starSize > terminal.window.innerHeight) {
                removeStar(star)
                return false
            }
            return true
        })
    }

    terminal.turtlo.imageElement.style.top = y + "px"
    terminal.turtlo.imageElement.style.left = x + "px"
    terminal.turtlo.imageElement.style.transform = `rotate(${terminal.turtlo.rot}deg)`
}

function randomTurtloActivity() {
    let activities = {
        goIntoShell() {
            terminal.turtlo.lastShellTime = Date.now()
            terminal.turtlo.shellDuration = 5000 + 8000 * Math.random()
        },
        stickToungeOut() {
            terminal.turtlo.lastToungeTime = Date.now()
            terminal.turtlo.toungeDuration = 1000 + 1000 * Math.random()
        },
        moveToRandomSpot() {
            terminal.turtlo.goalX = Math.random() * terminal.window.innerWidth
            terminal.turtlo.goalY = Math.random() * terminal.window.innerHeight
        },
        spinAround() {
            terminal.turtlo.lastSpinTime = Date.now()
            terminal.turtlo.spinDuration = 300 + Math.random() * 2000
            terminal.turtlo.prevRot = terminal.turtlo.rot
        },
        spinWalkAround() {
            terminal.turtlo.lastHugeSpinTime = Date.now()
            terminal.turtlo.hugeSpinDuration = 5000 + Math.random() * 5000
            terminal.turtlo.spinAmountFactor = Math.random()
            terminal.turtlo.prevRot = terminal.turtlo.rot
            terminal.turtlo.radiusFactor = (0.4 + Math.random() * 0.5)
            terminal.turtlo.radiusStart = Math.random() * Math.PI * 2
        },
        walkout() {
            let prevX = terminal.turtlo.x
            let prevY = terminal.turtlo.y
            terminal.turtlo.goalX += (Math.random() - 0.5) * 2 * 300
            terminal.turtlo.goalX = -terminal.turtlo.imageElement.clientWidth * 2 - 100
            setTimeout(function() {
                if (terminal.turtlo.x > 0) return
                terminal.turtlo.x = terminal.window.innerWidth + 100
                terminal.turtlo.goalX = prevX
                terminal.turtlo.goalY = prevY
            }, Math.random() * 1000 + 2000)
        },
        starCopy() {
            let starTurtlos = []
            const numCopies = Math.floor(Math.random() * 10) + 10
            let speed = Math.random() * 5 + 5
            for (let i = 0; i < numCopies; i++) {
                let element = document.createElement("img")
                element.src = terminal.turtlo.imageElement.src
                let directionAngle = (i / numCopies) * Math.PI * 2
                element.style.transform = `rotate(${directionAngle * 180 / Math.PI}deg)`
                element.style.opacity = 0
                let speedFactor = Math.random() + 0.5
                let directionX = Math.cos(directionAngle) * speed * speedFactor
                let directionY = Math.sin(directionAngle) * speed * speedFactor
                starTurtlos.push({
                    element,
                    x: terminal.turtlo.x,
                    y: terminal.turtlo.y,
                    directionX,
                    directionY,
                    speed,
                    rotationTime: Math.random() * 1000 + 500,
                    startOfLife: Date.now(),
                })
                element.classList.add("turtlo")
                TURTLO_CONTAINER.appendChild(element)
            }
            terminal.turtlo.starTurtlos = terminal.turtlo.starTurtlos.concat(starTurtlos)
        }
    }
    
    let activityChances = [
        [activities.goIntoShell,      2],
        [activities.stickToungeOut,   6],
        [activities.spinAround,       4],
        [activities.spinWalkAround,   4],
        [activities.moveToRandomSpot, 4],
        [activities.walkout,          2],
        [activities.starCopy,         1],
    ]

    let totalChance = activityChances.map(e => e[1]).reduce((a, e) => a + e, 0)
    let randomValue = Math.random() * totalChance
    let cumulativeChance = 0
    for (let [activity, chance] of activityChances) {
        cumulativeChance += chance
        if (cumulativeChance > randomValue) {
            activity()
            break
        }
    }
}

function moveTurtlo() {
    if (!terminal.turtlo.inShell()) {
        let xDiff = terminal.turtlo.goalX - terminal.turtlo.x
        let yDiff = terminal.turtlo.goalY - terminal.turtlo.y
        terminal.turtlo.x += xDiff * 0.05
        terminal.turtlo.y += yDiff * 0.05

        while (terminal.turtlo.rot < 0)
            terminal.turtlo.rot += 360
        while (terminal.turtlo.rot > 360)
            terminal.turtlo.rot -= 360

        let rotation = (Math.atan2(yDiff, xDiff) + Math.PI / 2) * 180 / Math.PI
        let rotDiff = (terminal.turtlo.rot - rotation)
        if (rotDiff > 180)
            rotDiff -= 360
        if (rotDiff < -180)
            rotDiff += 360
        terminal.turtlo.rot -= rotDiff * 0.5

        let length = Math.sqrt(xDiff ** 2 + yDiff ** 2)
        terminal.turtlo.state = (length > 25) ? TURTLO_STATE.WALKING : TURTLO_STATE.IDLE
    }

    if (terminal.turtlo.state == TURTLO_STATE.IDLE) {
        let chance = Math.random() < 0.01
        if (!chance)
            return
        if (terminal.turtlo.hasToungeOut() || terminal.turtlo.inShell() || terminal.turtlo.inSpin() || terminal.turtlo.inHugeSpin())
            return
        randomTurtloActivity()
    }
}

function updateTurtlo() {
    drawTurtlo()
    moveTurtlo()
}

function startTurtlo(cssClass=null, silent=false) {
    if (!silent) {
        terminal.print("to remove turtlo, use ")
        terminal.printCommand("kill turtlo", "kill turtlo", Color.COLOR_1)
    }
    removeExistingTurtlos()
    if (terminal.turtlo.intervalFunc)
        clearInterval(terminal.turtlo.intervalFunc)
    resetTurtlo()
    terminal.turtlo.imageElement.classList.add("turtlo")
    if (cssClass) terminal.turtlo.imageElement.classList.add(cssClass)
    drawTurtlo()
    TURTLO_CONTAINER.appendChild(terminal.turtlo.imageElement)
    terminal.turtlo.intervalFunc = setInterval(updateTurtlo, 50)
}

terminal.modules.turtlo = {

    spawn({size=1, silent=false}={}) {
        switch(size) {
            case 1:
                startTurtlo(null, silent)
                break
            case 2:
                startTurtlo("huge", silent)
                break
            case 3:
                startTurtlo("hugehuge", silent)
                break
            default:
                throw new Error("invalid size for turtlo")
        }
        terminal.log("spawned turtlo")
    },

    kill() {
        if (terminal.turtlo.intervalFunc)
            clearInterval(terminal.turtlo.intervalFunc)
        if (removeExistingTurtlos() != 0) {
            terminal.log("killed turtlo")
            return true
        } else {
            return false
        }
    }

}

// ------------------- js/modules/upload.js --------------------
async function fileFromUpload(fileType=null) {
    return new Promise(async (resolve, reject) => {
        let input = terminal.document.createElement("input")
        input.setAttribute("type", "file")
        if (fileType)
            input.setAttribute("accept", fileType)
        input.click()

        input.onchange = function(event) {
            if (!input.value.length) {
                reject()
                return
            }
            let fileReader = new FileReader()
            let fileName = input.files[0].name
            let readAsDataURL = (
                fileName.endsWith(".jpg")
                || fileName.endsWith(".png")
                || fileName.endsWith(".jpeg")
                || fileName.endsWith(".svg")
                || fileName.endsWith(".bmp")
                || fileName.endsWith(".gif")
            )
            fileReader.onload = function(event) {
                resolve([fileName, event.target.result, readAsDataURL])
            }
            if (readAsDataURL) {
                fileReader.readAsDataURL(input.files[0])
            } else {
                fileReader.readAsText(input.files[0])
            }
        }

        terminal.document.body.onfocus = () => {
            setTimeout(() => {
                if (!input.value.length)
                    reject()
            }, 1000)
        }  
    })
}

async function getMP3FromUpload() {
    return new Promise(async (resolve, reject) => {
        let input = terminal.document.createElement("input")
        input.setAttribute("type", "file")
        input.setAttribute("accept", "audio/mpeg3")
        input.click()

        input.onchange = function(event) {
            if (!input.value.length) {
                reject()
                return
            }
            let fileReader = new FileReader()
            fileReader.onload = function(event) {
                let audio = terminal.document.createElement("audio")
                audio.src = event.target.result
                resolve(audio)
            }
            fileReader.readAsDataURL(input.files[0])
        }

        terminal.document.body.onfocus = () => {if (!input.value.length) reject()}  
    })
}

async function getImageFromUpload({
    multiple=false
}={}) {
    return new Promise(async (resolve, reject) => {
        let input = terminal.document.createElement("input")
        input.setAttribute("type", "file")
        input.setAttribute("accept", "image/*")

        if (multiple) {
            input.setAttribute("multiple", "true")
        }

        input.click()

        let images = []
        let numExpectedImages = []

        input.onchange = function(event) {
            if (!input.value.length) {
                reject(new Error("No image selected"))
                return
            }

            numExpectedImages = input.files.length
            for (let file of input.files) {
                let fileReader = new FileReader()
                fileReader.onload = function(event) {
                    let image = terminal.document.createElement("img")
                    image.name = file.name
                    image.onload = function() {
                        if (multiple) {
                            images.push(image)
                            if (images.length >= numExpectedImages) {
                                resolve(images)
                            }
                        } else {
                            resolve(image)
                        }
                    }
                    image.src = event.target.result
                }
                fileReader.readAsDataURL(file)
            }
        }

        terminal.document.body.onfocus = () => {
            setTimeout(() => {
                if (!input.value.length) {
                    reject(new Error("No image selected"))
                }
            }, 500)
        }
    })
}

terminal.modules.upload = {
    file: fileFromUpload,
    mp3: getMP3FromUpload,
    image: getImageFromUpload,
}

// ------------------- js/modules/window.js --------------------
terminal.modules.window = {

    make({
        backgroundColor="black",
        name="My new Window",
        iframeUrl=undefined,
        fullscreen=false,
        addResizeListener=true,
        removeBar=false
    }={}) {
        const windowContainer = terminal.document.createElement("div")
        windowContainer.classList.add("terminal-window")
        
        const header = terminal.document.createElement("div")
        header.classList.add("terminal-window-header")
        windowContainer.appendChild(header)

        const title = terminal.document.createElement("div")
        title.classList.add("terminal-window-title")
        title.textContent = name
        header.appendChild(title)

        const exitBtn = terminal.document.createElement("div")
        exitBtn.classList.add("terminal-window-exit")
        exitBtn.textContent = "✕"
        exitBtn.title = `Close ${name}`
        header.appendChild(exitBtn)

        exitBtn.addEventListener("click", function() {
            terminal.interrupt()
            windowContainer.remove()
            setTimeout(() => {
                if (terminal.currInputElement) {
                    terminal.currInputElement.focus()
                }
            }, 200)
        })

        const content = terminal.document.createElement("div")
        content.classList.add("terminal-window-content")
        windowContainer.appendChild(content)
        
        if (fullscreen) {
            windowContainer.style.width = "100%"
            windowContainer.style.height = "100%"
            windowContainer.style.margin = "0"
            windowContainer.style.position = "fixed"
            windowContainer.style.transform = "translate(0, 0)"

            windowContainer.style.setProperty("--border-radius", "0px")
		}

        if (iframeUrl) {
            const iframe = terminal.document.createElement("iframe")
            iframe.src = iframeUrl
            content.appendChild(iframe)
            terminal.body.appendChild(windowContainer)

            if (fullscreen) {
                iframe.style.borderRadius = "0"
                iframe.style.border = "0"
                windowContainer.style.borderRadius = "0"
            }

            return {
                iframe,
                windowContainer,
                close() {
                    windowContainer.remove()
                }
            }
        } else {
            if (removeBar) {
                content.style.width = "100%"
                content.style.height = "100%"
                content.style.margin = "0"
                content.style.position = "fixed"
            }

            const CANVAS = terminal.document.createElement("canvas")
            CANVAS.style.backgroundColor = backgroundColor
            content.appendChild(CANVAS)
            const CONTEXT = CANVAS.getContext("2d")

            terminal.body.appendChild(windowContainer)
            CANVAS.width = CANVAS.clientWidth
            CANVAS.height = CANVAS.clientHeight
        
            CONTEXT.font = "15px Courier New"
        
            if (addResizeListener)
            terminal.window.addEventListener("resize", function() {
                CANVAS.width = CANVAS.clientWidth
                CANVAS.height = CANVAS.clientHeight
                CHARWIDTH = CONTEXT.measureText("A").width * 1.8
                CONTEXT.font = "15px Courier New"
            })

            if (fullscreen) {
                CANVAS.style.borderRadius = "0"
                CANVAS.style.border = "0"
            }
        
            return {
                CANVAS,
                CONTEXT,
                windowContainer,
                close() {
                    windowContainer.remove()
                    setTimeout(() => {
                        if (terminal.currInputElement) {
                            terminal.currInputElement.focus()
                        }
                    }, 200)
                }
            }
        }
    }
    
}

